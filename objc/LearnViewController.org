#+TITLE:Apple View Controller Programming Guide for iOS
#+OPTIONS: ^:{}
#+STARTUP: indent

* ViewController 의 개념.
ViewController 는 앱의 데이터와 UI간의 중요한 연결고리 역할. iOS앱이
UI를 표시할 때, 표시된 컨텐츠는 모두 1개 이상 ViewController 에 의해
관리되거나 여러 ViewController 그룹들간 상호 작용을 통해 관리된다.

전통적인 MView Controller 디자인에서 컨트롤러 역할 뿐 아니라 더 많은 작업을
iOS에서는 수행(화면회전등에 대한 표준 구현...)

* ViewController 기초
iOS장치들은 화면이 작음. 따라서, 많은 양의 데이터를 표시할 때 조금씩
여러단계에 걸쳐서 나누어 표시. ViewController 는 *데이터를 표시* 하고
*숨기는 작업* 을 조율하고 그 *내용을 관리* 하는 인프라를 제공.

** Screen, Windows, 그리고 Views 가 시각적 인터페이스를 생성
- =UIScreen= 객체 : 장치에 연결된 물리적 스크린
- =UIWindow= 객체 : 스크린상에 그리기 기능을 제공
- 일련의 =UIView= 객체들 : 윈도우가 요청하면 각각 자신의 영역에
  그림을 그림.
- 뷰 시스템
  [[file:img/LearnViewController_20130324_164341_.png]]
  
  View 는 다음과 같은 특징을 가짐.
  1) UI요소(특정영역을 점유하면서 컨텐츠를 사용자에게 표시하고
     사용자 이벤트에 반응).
  2) View계층을 구성. (부모-자식 관계)
  3) 속성 애니메이션을 구현.
  4) 앱 내에서 로직을 수행하지는 않음. UIButton 처럼 단순히
     클릭했다는 사실만을 인식하고 그에 맞는 화면표시만 담당.
     
** ViewController 는 View들을 관리.

View 및 기타 리소스들을 간리하는 역할. 윈도우의 rootViewController
속성을 설정하면, 윈도우의 서브뷰로서 해당 ViewController 의 뷰 계층이
들어간다.

[[file:img/LearnViewController_20130324_165126_.png]]

ViewController 는 필요할때가 되어야 View 를 로딩함. 특정상황에서는
View 의 리소스를 해제하기도 하므로, 앱내에서 리소스 관리에 있어
중요한 역할을 함.

ViewController 는 연결된 뷰들의 연계 동작을 구현하는 곳. View 는
"버튼이 눌림"이 실제 어떤 작업으로 연결되는지 몰라도, ViewController
는 알 수 있다.

ViewController 는 앱의 전체 데이터 중 일부만을 화면에 표시하는 경우가
대부분. 독립적으로 데이터를 나누어 맡아 처리하므로, ViewController 간
연계도 필요하다.

*** Recipe 앱 예제.

[[file:img/LearnViewController_20130324_165545_.png]]

ViewController 의 공통점이 드러나는 예제.
1) 모든 Vie는 오직 하나의 ViewController 에 의해 제어됨.
   UIViewController 의 =view= 속성을 통해 소유됨. view 가 subview
   라면, 소유하는 ViewController 에 의해서 제어될 수 도, 아닐 수도
   있음.
2) 모든 ViewController 는 데이터의 전체가 아닌 부분만을 다룬다.
3) 위 2) 와 같이 되어 있으므로, 결국, ViewController 끼리는 서로
   협력을 해야만 전체 데이터를 관리할 수 있다. 
   
** ViewController 의 분류

아래 그림은 UIKit 프레임웍의 ViewController 과 관련한 주요 클래스들을
표시.

[[file:img/LearnViewController_20130324_170052_.png]]
크게 2가지로 나눔.

** Content ViewController
다음의 역할을 담당
- 데이터를 사용자에게 표시
- 사용자로 부터 데이터를 수집
- 특정 작업을 수행
- 게임 시작 옵션과 같은 일련의 명령/옵션을 선택
  
*** UITableViewController 예.
UITabeViewController 는 =view= 속성 외에도 =tableView= 속성을 가지고
table view를 소유/제어

** Cotainer ViewController
다른 ViewController 에 의해 소유되는 컨텐츠를 포함. 다음과 같은
차이가 있음.
- 자식을 다루기 위한 전용 API
- 자식들간의 관계유무와 종류를 결정
- 원래는 자식 ViewController 가 하는 view-subview 간 레이아웃
  재배치등과 같은 것을 직접 함.
  
*** UINavigationController 예
자식 ViewController 를 stack 기반 자료구조에 저장/관리(맨 아래쪽은
첫화면, 맨 위는 현재화면). 주로 자식 ViewController 만 관리하지만,
자신이 직접 챙기는 View 도 있다. (Bar Button)

*** UITabBrController 예
tab 대화상자와 비슷.

*** 기타
- UISplitViewController : 화면을 Master /Detail 로 나란히 배치하여
  Master 에서 선택한 사항의 상세 내용을 Detail 쪽에 표시.
- UIPopoverController : portrait 모드에서 마스터 뷰가 표시할 수 있는
  특별한 컨트롤. =popover=.
- UIPageViewController : 페이지 레이아웃을 구현. 책과 같은 UI 를
  생성.
  
** ViewController 의 컨텐츠는 여러방법으로 표시
아래와 같은 방법으로 ViewController 의 컨텐츠가 사용자에게 보여짐.
1) 윈도우의 rootViewController 로 설정
2) Container ViewController 의 자식으로 설정
3) Popover 컨트롤에 표시
4) 다른 ViewController 로 부터 present
   
** 여러 ViewController 가 모여 앱의 인터페이스를 구성
ViewController 는 자기의 View들 및 연관된 객체들을 관리하지만, 다른
ViewController 들과 협업으로 사용자 인터페이스를 구성. -->
ViewController 간의 통신이 중요. --> ViewController 간의 관계를 맺어
상호작용함. 그 관계는 어떤것들이?

*** 부모-자식 관계 : 포함(Containment)
탭 4개로 구성된 UITabViewController 의 예. 첫번째 탭은 네비게이션
컨트롤러. 나머지는 컨텐트 뷰 컨트롤러. 네비게이션 컨트롤러는 다시
마스터와 디테일 컨트롤러를 구성.
[[file:img/LearnViewController_20130325_195604_.png]]

화살표는 부모->자식 관계를 표시. 가장 상위의 ViewController 가
rootViewController 임. 얘는 window 로부터 크기를 가져와 탭바 를
구성하고 나머지 화면공간을 자식들에 배분. 각 자식 ViewController 는
배분 받은 걸 기준으로 자신의 view 에게 화면을 배분. 이러한
View-ViewController 관계로 앱의 이벤트 처리를 위한 Responder Chain 도
구성.

*** 컨테이너 안에서의 이웃관계
뷰컨에 따라서는 자신의 자식들간에 독특한 관계를 형성하기도 함.

- 탭 뷰컨트롤러 에서 각 탭은 컨텐츠를 구분된 화면의 컨텐츠를 의미.
  따라서, 자식들간에는 특별한 관계가 필요는 없음(만들 수는 있겠지만).
- 네비 뷰컨트롤러 에서 자식들은 선택/복귀의 관계가 있음(스택의 형태로
  이웃하는 자식들이 관리됨) --> 이 경우, 이웃하는 것들끼리는 어떤
  연결의 형태가 있음.
  
네비 뷰컨의 예. 네비뷰에서 특정 자식이 선택되면, 스택의 맨 앞으로
push된다(그럼 화면에 보여진다).

[[file:img/LearnViewController_20130325_200558_.png]]

*** 다른 인터페이스상에 동적화면을 프리젠테이션
ViewController 는 어떤 작업을 수행하기 위한 다른 ViewController 가
필요할 때 화면에 띄울 수 있다("Present"). "대화상자"처럼.
[[file:img/LearnViewController_20130325_201550_.png]]

다음 예에서, Content가 Modal 을 띄울 때, rootViewController 로 부터
Presentation Context를 제공받는데, 이 Context 에서 Modal이 표시될
화면 영역이 정의된다. Presentation Context 는 Modal을 Present하는
Content 로 부터 제공받을 수 도 있는데... 그럼 아마 화면 표시영역이
달라지겠지.

[[file:img/LearnViewController_20130325_202314_.png]]

*** 컨텐츠 컨트롤러들간의 연동이 순서도로 표현
여러 ViewController 를 가지는 앱에서는 보통, 앱이 수행되는 동안,
생성/파괴를 반복하게 된다. ViewController 가 파괴되기 전까지, 서로
통신하여 부드러운 사용자 경험을 제공한다. 이러한 관계가 앱의 제어
흐름으로 표현된다.

ViewController 가 생성될때 새로운 순서도의 동작이 일어난다. 보통,
ViewController 는 다른 ViewController 안에서의 동작으로 인해
생성된다.

1) Source ViewController : 동작이 일어난 ViewController
2) Destination ViewController : 그로인해 생성된 ViewController
   
보통 2) 가 표시할 데이터는 1) 에 의해서 제공됨. 만일 2) 로부터
데이터를 1) 로 가져와야 한다면, 1)은 둘간의 연결을 구성하도록 해야
한다.

source-desitnation 간 통신의 종류
- 내비 컨트롤러가 스택에 다른 자식을 push
- 다른 ViewController 를 present
- 다른 ViewController 를 popover
  
[[file:img/LearnViewController_20130325_203833_.png]]  


각 컨트롤러는 자신보다 앞선 컨트롤러에 의해 설정 --> 통신 체인 형성
위 그림의 위 각 연결에서 제어흐름은 다음과 같은 규칙으로 구성된다.

- Destination ViewController 는 데이터와 Presentation을 설정하기 위해
  사용되는 속성을 제공한다.
- Destination ViewController가 위 그림과 같은 연결고리상에서 자신보다
  앞에 있는 컨트롤러와 통신해야 하면, delegation 을 사용한다. 즉
  Source ViewController 가 Destination ViewController 의 delegation
  을 위한 프로토콜을 구현한다. 
  
제어흐름을 구현시 가장 중요한 점은 *Source ViewController 는
Destination 을 알아도, Destination 은 Source 에 대해 모르게 구현*
해야 한다는 것. -> 가급적 커플링을 끝어서 재사용성을 높임. 

*** 스토리 보드
별로 안조은거. 생략.

* ViewController 사용하기.
** 스토리 보드로 ViewController 생성하기.
*** 스토리 보드란?
제어흐름이 Visual하게 보이는 장점. 코딩안해도 되는 점. ViewController
들을 작업흐름에 따라 화면에 보이는 순서를 정해 생성하고, 이들간의
관계를 설정함으로써, 앱 전체를 개발하는 식.

관계를 어떻게 맺느냐에 따라 각 ViewController 의 생성시기가 다름.

1) Segue : Destination ViewController 는 Segue 가 trigger 될 때
   자동으로 생성된다.
2) Containment : Child ViewController 는 부모가 생성될 때 자동으로
   생성된다.
3) 위 1) 혹은 2) 어느쪽도 아니면, 절대 자동생성되지 않는다. 직접 코드를
   짜서 스토리보드로 부터 생성해야 한다.
   
스토리 보드내에서의 ViewController 또는 Segue 는 IB 에서 Identifier
String 문자열로 참조할 수 있음(특히, 코드로 직접 ViewController 를
생성하고자 한다면, 이게 있어야 함). 맘편하게 아예 모든 Segue /
ViewController 에 Identifier String 을 붙여놓는게 나중에 편하다(특히,
segue 동작시 이 값이 함수로 전달되어 어느 segue에 의해 ViewController
가 생성되었는지 알 수 있단다).

*** 스토리보드의 ViewController 를 iOS가 생성하게 하기.
앱의 info.plist 파일에 Main Storyboard 가 설정되어 있다면, 앱이
실행될때 iOS 는 다음과 같은 작업을 함.
1) window 를 생성해줌
2) Main Storyboard 를 불러들이고, initial ViewController 를 생성.
3) 2)에서 생성된 ViewController 를 window 의 =rootViewController= 로
   설정함.
   
Segue 가 trigger 되면, iOS 는 다음을 수행.

1) Instantiation : 스토리 보드에서 제공된 어트리뷰트 값을 사용해 Destination
   ViewController 를 생성
2) Configuration : Source ViewController 에게 Destination
   ViewController 를 설정할 수 있는 기회제공(메소드 호출)
3) Transition : Segue 에 설정된 transition 을 수행
   
*유의사항* Custom ViewController 를 직접 만들고 스토리 보드에서
사용되도록 할 경우, 위의 동작이 이루어질 수 있도록 속성/메소드를
선언해야 한다. 

**** Segue 를 코드로 trigger 하기.
보통은 control 이나 gesture recognizer 와 같은 Source ViewController
와 연관된 객체들이 Segue 를 tirgger한다. 하지만, Segue 에 identifier
string 이 지정되어 있다면, 이걸가지고 코드상에서 trigger가 가능.
예를들면, 게임에서 경기가 끝나면 어떤 Segue 를 강제로 trigger할
필요가 있다.

ViewController 의 performSegueWithIdentifier:sender: 메소드를
호출하되, segue 의 identifier 와 sender 객체를 넘겨주면 된다. Source
ViewController 로 하여금 새로이 생기는 이 ViewController 를
설정하도록 메소드가 호출될때, 이 2개의 인자가 넘어가서 작업을 수행할
수 있다. 다음 예는 기기의 방향이 바뀔 때, 바뀐 방향에 맞는 새로운
ViewController 가 생성되도록 Segue가 trigger 된다.

#+BEGIN_SRC objc
  -(void)orientationChanged:(NSNotification *)notification
  {
      UIDeviceOrientation *devOrient = [UIDevice currentDevice].orientation;
      if (UIDeviceOrientationIsLandscape(devOrient) &&
          !isShowingLandscapeView)
      {
          [self performSegueWithIdentifier:@"DisplayAlternateView"
                                    sender:self];
          isShowingLandscapeView = YES;
      }
  
      // 나머지 구현부는 생략.
  }
#+END_SRC

*** 스토리보드의 ViewController 를 코드로 직접 생성하기.
Segue 를 사용하지 않고, VieController 를 코드로 생성한다고? 그래도
여전히 스토리보드는 값어치가 있다. View의 계층 뿐 아니라
ViewController 의 속성까지 스토리보드상에서 설정할 수 있기 때문이다.

이렇게 하면 된다.

1) UIStoryboard 클래스의 객체를 얻는다. 
   
   동일 스토리 보드 상에서 이미 생성된 ViewController 로 부터 새로운
   ViewController 를 만드는 경우라면, 기존 ViewController 의
   =sotryboard= 속성값을 사용해 스토리보드 객체를 참조가능.
   
   그렇제 않은 경우라면, UIStoryboard 클래스의
   storyboardWithName:bundle: 클래스 메소드에 스토리보드 파일명과
   선택적 인자인 번들객체를 넘겨서 새로이 UIStoryboard 객체를 만들 수
   있다. 
   
2) 스토리보드 객체의 instantiateVieControllerWithIdentifier: 메소드에
   IB에서 해당 ViewController에 지정한 indentifier string 를 넘겨서
   원하는 ViewController 를 생성할 수 있다.
   
   또는 instantiateInitialViewController 를 쓰면 특별하게 initial
   ViewController 를 만들수 있다(이 경우 identifier string 이 필요없음).
   
3) 새로운 ViewController 객체의 속성값을 정하는 등의 설정작업을
   수행한다.
   
4) 만들어진 ViewController 를 화면에 표시한다.
   
   Window의 rootViewController 로 설정하거나, present하거나, Container
   ViewController의 자식으로 만들거나, Popover하거나....
   
   다음은 자주 사용되는 기법의 예. 
   #+BEGIN_SRC objc
     -(IBAction)presentMySpecialViewController:(id)sender
     {
         // UIStoryboard 객체 참조를 얻음.
         UIStoryboard *sb = self.storyboard;
     
         // storyboard를 통해 ViewController 객체 생성
         MySpecialViewController *svc
             = [stroyboard instatiateViewControllerWithIdentifier:@"MySpecialViewCon"];
     
         // svc 에 대한 설정작업을 여기에서 한다.
     
         // 화면에 표시
         [self presentViewController:svc
                            animated:YES
                          completion:nil];
     }
   #+END_SRC
   
   다음은 또 다른 자주 사용되는 용례. AppDelegate 에서 아래와 같은
   메소드를 호출해서 window 객체를 얻은 다음, makeKeyAndVisible 을
   호출 할 수 있겠다.
   #+BEGIN_SRC objc
     -(UIWindow *)windowFromStoryboard:(NSString *)storyboardName
                              onScreen:(UIScreen *)screen
     {
         UIWindow *window = [[UIWindow alloc] initWithFrame:[screen bounds]];
         window.screen = screen;
     
         UIStoryboard *sb = [UIStoryboard storyboardWithName:storyboardName
                                                      bundle:nil];
         MainViewController *mainView = [sb instantiateInitialViewController];
     
         // 새로이 생성된 mainView 객체의 속성을 설정
     
         // root ViewController 로 지정
         window.rootViewController = mainView;
     
         return window;
     }
   #+END_SRC
   
**** 별도의 스토리보드로 장면전환하기 위해서는 코드로 해야...
Segue 는 하나의 스토리보드내에 있는 장면들만을 연결한다. 다른
스토리보드 파일에 있는 ViewController 를 표시하기 위해서는 해당
스토리보드 파일을 불러들여 코드로 생성해야 함.

*앱내에서 스토리보드 파일은 몇개라도 사용가능* ! 다수의 스토리보드
파일을 사용하는 경우의 이점은 다음과 같음.

- 대규모 프로그래밍 팀이 작업을 나누어서 하는 경우
- 상용 라이브러리가 별도의 스토리보드를 가지고 있는 경우
- 외부화면에 표시되어야 할 컨텐츠가 있는 경우, 외부화면용 스토리보드
  파일을 따로 두면 편함.
  
*** Container ViewController 는 자식 ViewController 를 자동생성
스토리보드 파일내의 Container ViewController 가 생성될 때는, 자식
ViewController 들도 함께 생성됨. 자식 ViewController 가 Container 인
경우 그 놈의 자식들도 함께 동시 생성됨.

생성한 다음, 설정하기 전까지 모든 자식/손자 ViewController 들이 주욱
생성된다. 설정작업은 주로 컨텐츠 ViewController 에 대하여 수행되는
경우가 많으므로 이러한 동작특성은 중요하다(컨텐츠 ViewController
수준의 자식레벨까지 전부 생성되므로).

** 스토리보드가 아닌 ViewController 생성하기.
Objective-C 코드로 ViewController 를 할당하고, 초기화. -_-; 

** ViewController 를 코딩으로 표시하기.
ViewController 의 화면표시방법
1) Window 의 rootViewController 로 만들기
   #+BEGIN_SRC objc
     -(void) applicationDidFinishLaunching:(UIApplication *)application
     {
         UIWindow *window = [[UIWindow alloc]
                                initWithFrame:[[UIScreen mainScreen] bounds]];
         levelViewController = [[LevelViewController alloc] init];
         window.rootViewController = levelViewController;
         [window makeKeyAndVisible];
     }
   #+END_SRC
2) 현재 표시중인 Container ViewController 의 자식으로 만들기
3) 다른 표시중인 ViewController 로 부터 Present
4) Popover로 Present 하기 (iPad만 지원!)
   
**** *주의사항*
ViewController 의 =view= 를 특정 =view= 부모-자식 계층에 직접 넣지
말것!(=view= 에 addSubview 호출하지 말아라?)

그런데, UICatalog 같은 Sample Code 를 보면 아래와 같이 하던데? 흠..
이전에 만든거라 좀 다른가?
#+BEGIN_SRC objc
  - (void)applicationDidFinishLaunching:(UIApplication *)application
  {
      // add the navigation controller's view to the window
      [window addSubview: navigationController.view];
      [window makeKeyAndVisible];
  }
#+END_SRC

View 를 적절히 present 하고 관리하기 위해, 시스템은 표시하고자 하는 각
view들(그리고 연관된 ViewController들)을 기억해 놓는다. 이 정보는
나중에 사용자의 앱에 ViewController 관련 이벤트를 보고할 때 사용된다.
예를들어, 장치의 방향이 바뀌면 Window 는 이 계층 정보를 사용해, 가장
앞쪽에 있는 ViewController 를 찾는다.

커스텀 Container ViewController 를 구현하려 한다면, 다른
ViewController 의 view 를 자신의 view계층에 추가하는 것에 앞서
부모-자식 관계를 먼저 생성해 주어야 한다. 이렇게 해야 이벤트가 옳바르게
전달된다.

* TODO 커스텀 Content ViewController 만들기
기존에 없는 Content ViewController를 구현하는 일은 어플 개발의
핵심이다. 앱의 독특한 컨텐츠를 표시하기 위해 필요. 모든 어플은 적어도
1개의 커스텀 Content ViewController 를 가진다.

ViewController에는 많은 요구사항이 있다. 이런 요구사항들은 어플에서
정의된 요구되는 역할들이지만, 그 중 일부는 iOS가 요구하는 것도 있다.

** 커스텀 Content ViewController 의 구성
UIViewController 클래스는 커스텀 ViewController 를 구현하기 위한
기본적인 인프라를 제공한다. 우선 UIViewController 를 상속받은
클래스를 정의한다. 이 서브클래스는 데이터를 표시하는 view 를 생성하기
위한 코드를 제공하며, 사용자의 동작에 반응한다. ViewController 의
기본 동작을 변경하기 위해서는 UIViewController 클래스의 메소드를
오버라이드한다. 원하는 동작을 구현하기 위해 다른 UIKit 클래스들과
상호작용을 해야 할 수도 있다.

다음과 같은 요소를 가진다.
- 표시할 커스텀 데이터 객체들
- view 와 이 view의 subview로 구성된 계층
  
  [[file:img/LearnViewController_20130325_233123_.png]]
  
결국, 새로운 ViewController 설계시 다음과 같은 요구사항으로 귀결
- 내부적 관리 : 자신의 데이터 객체나 view 계층
- 외부적 관리 : 다른 ViewController 들과의 동작
  
*** ViewController 는 리소스를 관리한다.
1) 처음부터 끝까지 항상 필요한 리소스
2) contents가 화면에 표시될 때만 필요한 리소스 : "view"
필요한 리소스만 메모리에 들고 있도록 잘 짜야 한다.

*** ViewController 는 View(또는 여러 View들)를 관리한다.
- 자신의 =view= 와 그 view의 subview 들을 관리
- =view= 의 frame 은 ViewController 가 관리하지 못한다(다른 요소. ex:
  기기 방향. 등에 의해 결정)
- 외부로 부터 제공받은 frame 에 자신의 view 를 잘 layout 하도록
  설계해야 함.
  
*** ViewController 는 이벤트에 반응한다.
ViewController는 자신이 관리하는 view들 및 control들 간의 동작을
조율하는 데 있어 중심적인 역할을 함. 대개, 사용자가 controls을 조작할
때, control로 하여금 자신의 ViewController 에 메시지를 보내어
처리되도록 설계함. ViewController 는 이 메시지를 처리하여,
ViewController 내에 저장된 데이터나 view들에 필요한 변경을 가하는
식으로 구현되어야 한다.

ViewController 는 또한 *Responder Chain* 에 속해, 이벤트를 앱에
전달한다. 기존 ViewController 메소드를 오버라이드해서 이벤트처리에
직접 참여할 수도 있고, 시스템 통지, 타이머, 혹은 앱에 특화된 어떤
이벤트에 반응하기 위한 메소드를 정의할 수 도 있다.

*** ViewController 는 다른 ViewController 와 협업한다.
그럴려면, 한 ViewController 의 기능/속성/데이터를 외부에 노출시켜야
하는데, 너무 많이 노출시키면, 작업을 지속할 수록 점점 일이 어려워
진다. 가능한 최소한으로 노출시키자.

*** ViewController 는 Container 와 자주 연동된다.
ViewController 가 Container 내에 위치하면, 추가적인 제약사항이
부여된다. 아래 그림에서 "Optional objects requested by containing
view controller" 라고 표시된 부분이 그런거. 원래 관리하는 것과는
별도의 데이터가 요구되는 것. 이게 있어야 Container 의 UI 를 제대로
설정할 수 있다. 예) Tab ViewController 내에 있는 Content
ViewController 는 탭에 표시할 Tab Bar Item 을 제공해야 한다.

[[file:img/LearnViewController_20130325_235237_.png]]

UIKit 에서 제공되는 이런 추가적인 속성들은 UIViewController 클래스에
정의되어 있다. "View Controller Catalog for iOS" 문서를 참조.

*** ViewController 는 다른 ViewController 로 부터 Present될 수 있다.
대화상자 doModal() 하는 것과 유사. 앱의 작업흐름을 잠시 중단하고,
임시적인 정보의 수집/표시를 위해 필요. 작업을 마치면 원래의 흐름으로
돌아감.


** 커스텀 Content ViewController 설계하기
코딩하기 전, 다음의 체크리스트 확인.
1) 스토리보드를 쓸 것인가?
2) 언제 생성하는가?
3) 무슨 데이터를 표시하는가?
4) 어떤 작업을 수행하는가?
5) 화면에 어떻게 표현할 것인가?
6) 다른 ViewController 와 어떻게 연동되는가?
   
*** 스토리보드를 사용해 ViewController 구현하기
상세 구현을 위해 스토리보드를 사용할 것인지 아닌지 고려해야 하는데, 그
결과에 따라 ViewController 가 어떻게 구현되는지 및 다른 객체가 어떻게
새로운 ViewController 와 협업하는지에 영향을 준다.

*특별한 이유가 없다면 스토리보드를 사용해야 한다*

스토리보드를 통해 사용할 경우 설계:

- iOS는 보통 ViewController 를 자동으로 생성하게 된다.
- 생성과정을 마무리하기 위해 awakeFromNib 메소드를 오버라이드 한다.
  nib의 로딩이 끝나고, outlet과 action 연결이 다 끝난 상태에서
  호출된다. 
- 다른 객체들이 이 ViewController 속성을 통해 ViewController 를
  설정한다. 
- IB에서 View 계층과 다른 연관객체들을 만든다. 이 객체들은 View가
  필요로 할때 자동으로 로딩된다.
- 다른 ViewController 들과의 관계를 스토리보드상에서 맺어준다.
  
ViewController 를 코딩으로 생성/사용할 경우 설계:

- alloc/init 으로 ViewController 를 생성한다.
- ViewController 를 초기화하기 위한 커스텀 초기화 메소드를
  만든다.
- 다른 객체들이 ViewController의 초기화 메소드 및 속성을 통해
  ViewController를 설정한다.
- 마찬가지로 코딩을 통해 다른 ViewController 들과의 관계를 맺어준다.
  
*** 설계된 ViewController 가 언제 생성되는지 확인하자.
ViewController 의 생성시점은 앱이 어떻게 동작하는지에 대한 정보를
알려준다. 예로, 동일 객체에서만 ViewController 가 생성되는 경우가
있을 것이다. ViewController 를 생성하는 것은 (다른) ViewController
들인 경우가 많다. 어떤경우라도, 언제, 왜, 무엇에 의해 ViewController
가 생성되었는지를 안다면 ViewController들 및 이들을 생성한 객체간에
주고받는 정보에 대해 파악하기 쉬울 것이다.

"이해가 안가네."

*** 설계된 ViewController 가 표시하고 반환하는 데이터를 확인하자.
이 내용을 확인하게 되면, 앱에 대한 데이터 모델을 뿐 아니라 그 데이터가
ViewController들 사이에 상호교환되어야 하는지에 대하여 이해할 수
있다.

ViewController 에서 흔희 보여지는 패턴들을 살펴보자.

- View Controller 는 다른 View Controller로 부터 데이터를 받아서 화면에 표시하되 편집하지
  않으면 ? 그 어떤 데이터도 반환되지 않는다.
- View Controller 가 새로운 데이터를 입력받는 기능을 한다면, 사용자의 편집작업이
  끝나고 새로 생성된 데이터를 다른 View Controller 에게 반환해야 한다.
- View Controller 가 다른 View Controller 로 부터 데이터를 받고 사용자가 이를 편집할 수 있다면,
  편집 종료후 새로운 데이터를 다른 View Controller 에게 반환한다.
- View Controller 가 데이터를 주지도 받지도 않는다면, 얘는 Static View 를 표시하는 것.
- View Controller 가 데이터를 주지도 받지도 않지만, 내부 구현상으로 데이터를 다른
  곳에서 받아오는 경우. 예를 들면, GKAchievementViewController
  클래스는 게임플레이어가 기기에 접속했는지를 확인하고 접속했으면
  플레이어의 데이터를 게임 센터로 부터 가져와 표시하는 방법을
  내부적으로 가지고 있다. 
  
위와 같은 설계에만 국한될 필요는 없다.

데이터가 View Controller 의 안팎으로 들락거린다면, 데이터 모델 클래스를 설계하여
다른 View Controller에게 전송될 데이터를 들고 있도록 할 수 도 있다.  예로,
/Your Second iOS App: Storyboards/ 에서는 마스터 View Controller 가 BirdSighting
객체를 사용해 sighting 과 관련된 데이터를 디테일 View Controller 에게 전송한다.
이런식으로 구현하면, View Controller 클래스의 메소드 시그너쳐를 바꾸지 않고도
추가적인 속성을 데이터에 더하는게 쉬워진다.

*** 설계된 View Controller 는 사용자에게 어떤 작업을 수행할 수 있게 하는지를 확인하자.
어떤 View Controller 는 CRUD 한다. 또 어떤 View Controller 는 컨텐츠의 내용을 여러 화면에 걸쳐
조회할 수 있게 한다. 그리고, 어떤 View Controller 는 사용자가 수행할 수 있는
작업을 제공하기도 한다. 예로, MFMailComposeViewController 는 사용자로
하여금 email 을 작성/전송할 수 있게 해 준다. 저수준의 메일전송과
관련한 상세구현을 포함하고 있는 것이다.

*** View Controller 가 화면에 어떻게 표시되는지 확인하자.
어떤 View Controller 는 rootViewController 용으로 설계되었다. 또 어떤 View Controller 는 다른 View Controller
에 의해 present 되거나, 컨테이너 View Controller 내에 배치될 용도로 설계되었다.
보통은, View Controller 를 설계할 때, 여러 방법으로 표시될 수 있도록 하는 게
일반적이다. 예를 들면, Split View Controller 의 마스터뷰는 landscape모드에서는
split view내에 표시되지만, portrait모드에서는 popover control내에
표시된다.

작성된 View Controller가 어떻게 표시되도록 할 지는 화면에서의 크기와 위치가 어떻게
바뀌어야 하는지 알 수 있게해준다. 또 View Controller 가 협업할 다른 View Controller들이
무엇인지를 결정하는 것과 같은 다른 부분들에도 영향을 준다.

*** 다른 View Controller 와 어떻게 협업할지를 확인하자.
여기까지 학습했다면, 이제 View Controller간의 협업이 어떤것인지 이미 알 것이다.
예를 들어, 어떤 View Controller가 Segue를 통해 생성되었다면, 이View Controller는 Source View Controller에
의해 설정될 것이다. 그리고, 작성된 View Controller가 어떤 컨테이너의 자식이라면,
컨테이너와 협업할 것이다. 전혀 다른 각도에서의 관계도 생각해 볼 수
있다. 이를테면, View Controller가 자신의 작업을 다른 View Controller에게 넘기고 손을 떼는 것
같은 것 말이다. 기존의 View Controller와 데이터를 주고받을 수 도 있다.

이러한 연관관계를 생각해 볼 때, 어떤 View Controller 는, 다른 View Controller 가 사용하게될
인터페이스를 제공하거나, 다른 View Controller의 존재를 먼저 알고 사용할 수 도 있다.
이러한 연관관계는 동작을 매끄럽게 하는데 있어 필수적이다. 이러한 관계를
통해 앱내의 클래스들간 상호의존성이 드러나기 때문이다. 하지만, 이러한
의존성때문에 다른 클래스로 부터 격리된 어떤 클래스에 변경을 가하는
것이 더 어렵게 된다. 이러한 이유로, 앱에서 요구하는 기능과 추후
추가 변경을 용이하게 하려는 노력 사이에 균형을 맞추는게 필요하다.

** 일반적인 View Controller 설계의 예

*** 게임 타이틀 스크린

*** 마스터뷰 View Controller

*** 디테일뷰 View Controller

*** 메일 작성 View Controller

** 커스텀 컨텐트 View Controller 구현시의 점검사항
- View Controller에 의해 로딩되는 View 를 설정해야 한다.
  
  커스텀 클래스는 자신의 View계층이 어떻게 로딩되고 언로딩될지를
  관리할 특정의 메소드를 오버라이드해야 한다. 이 메소드들은 함께
  생성된 다른 리소스들을 관리할 수 도 있다.
  
- View Controller 가 지원하는 장치 방향이 어떤것인지, 장치방향이 바뀔 때 어떻게
  반응하는지에 대해서도 결정해야 한다.
  
View Controller를 구현하면서, 액션 메소드나 View와 사용하게 될 아웃렛들을 정의해야
할 필요가 있다는 것을 깨닫게 될 것이다. 예를들어, View계층이 테이블을
포함한다면, 나중에 테이블을 참조하기 위해 아웃렛에 포인터를 저장하게
될 것이다.  마찬가지로, View 계층이 버튼 또는 다른 컨트롤을 가진다면,
이들을 통해 어떤 액션 메소드가 호출되게 할 수 있다.  View Controller 클래스의
정의를 쭈욱 훝어보다 보면 다음괕은 사항을 작성중인 View Controller에 추가해야 할
필요가 있음을 알게된다.

- 해당 View에 의해 표시될 데이터를 포함하는 객체를 가리키는 /선언된 속성들/
- 커스텀 동작을 다른 View Controller에 제공하기 위한 공용 메소드/속성
- View Controller가 상호작용해야 하는 View 계층내 각 View들에 대한 아웃렛
- View 계층내 버튼 및 다른 컨트롤과 연관된 동작을 수행하기 위한 액션
  메소드
  
*중요* View Controller를 사용하는 클라이언트는 View Controller가 표시할 View들이 뭔지 또는 어떤
액션들이 이 View들에 의해 트리거되는지에 대해 알 필요가 없다.
가급적이면, 아웃렛과 액션들은 클래스의 구현파일(*.m)내 클래스
카테고리로 선언한다. 예를들어 MyViewController 라는 이름의 View Controller
클래스에서 다음과 같은 선언을 카테고리를 추가한다.

#+BEGIN_SRC objc
  // MyViewController.m 파일내에서..
  
  @interface MyViewController()
  
  // 아웃렛과 액션을 여기에 둔다.
  
  @end
  
  @implementation MyViewController
  
  // 위에서 private으로 선언된 카테고리를 여기에 구현한다.
  
  @end
#+END_SRC

이름없는 카테고리를 선언하면, 속성과 액션은 동일한 구현 블럭내에 다른
공용 인터페이스에 선언된 속성/메소드와 함께 구현되어야 한다.  private
카테고리 내에 정의된 아웃렛과 액션들은 IB 에서 접근할 수 있다. 
하지만, 앱내의 다른 클래스에서는 접근할 수 가 없다. 이 기법을 사용해
IB는 여전히 활용하면서 클래스의 비밀스런 부분을 감출 수 있다.

대신, 다른 클래스가 이 View Controller의 기능에 접근해야 할 때는, 공용 메소드 및
속성을 추가하여 이긍을 접근하도록 해야 한다.

* View Controller의 리소스 관리

View Controller 는 앱의 리소스를 관리에 있어 필수적 부분이다. View Controller는 여러분의 앱을
여러 부분으로 나뉘게 해 주고, 각 부분이 필요할 때 생성되게 해 준다.
하지만, 더 중요한 것은, View Controller 자체가 다양한 리소스들을 관리하고 여러
시점에 리소드들을 생성한다는 것이다.  예를 들면, View Controller 의 View 계층은
해당 view 를 누군가 참조할 때 생성된다. 그런 경우는 대부분, view 가
화면에 표시될 때이다.  여러 View Controller 가 네비게이션 스택에 동시에 push 되어
있는 상태에서는 스택 가장 상단의 View Controller 가 보이는 상태이므로, 이 View Controller 의
view 에 대한 접근이 이루어진다. 유사하게, View Controller 는 네비게이션 컨트롤러에
의해 present 되지 않았다면, 그 View Controller의 navigation item 은 생성될 필요가
없다. 필요한 시점이 되서야 대부분의 리소스들은 할당이 되도록
함으로써, View Controller 는 리소스를 덜 잡아먹게 된다.

앱의 메모리가 바닥나면, 모든 View Controller 는 시스템으로 부터 자동적으로 통지를
받는다. 이를 통해 View Controller 는 케쉬나 나중에 메모리에 여유가 생길 때 다시 쉽게
다시 생성할 수 있는 다른 여타의 객체들을 제거한다. 바로 이러한
동작들은 앱이 동작하는 iOS의 버젼이 무엇이냐에 따라 다르며, iOS 의
버젼에 따라 View Controller 의 설계가 영향을 받게 된다.

View Controller와 연관된 리소스들을 신중히 관리하는 것은 앱이 효율적으로 동작하게
함에 있어서 중요한 부분이다.  게으른 할당을 우선적으로 사용해야
하는데, 즉, 나중에 실제로 해당 리소스가 필요한 시점이 된 경우에
생성하도록 해야한다. 이러한 이유로, View Controller 는 자신의 생성시간동안 필요한
별도의 객체들을 특정시간에만 필요한 객체들과 분리시켜 관리해야 한다.
View Controller 가 메모리부족 경고를 수신하면, 화면에 보이지 않는 경우에 한해
메모리 사용량을 줄이도록 작성되어야 한다.

** View Controller 의 초기화

View Controller가 처음 생성되면, 생존기간동안 필요한 객체들을 생성하거나 로딩한다.
View 계층을 만들거나 표시할 내용과 연관된 객체들은 아직 만들면
안된다.  데이터 객체들 및 중요한 동작들의 구현에 필요한 객체들만
생성해야 하는 것이다. 

*** 스토리보드로 부터 불러들인 View Controller 의 초기화
View Controller 를 스토리보드에서 생성할 때는, IB 에서 설정한 어트리뷰트들이
아카이브로 직렬화된다. 나중에, View Controller 가 생성될 때, 이 아카이브는
메모리로 로딩되고 처리된다.  그 결과, 일련의 객체들이 IB에서 설정한
대로의 어트리뷰트를 가진 상태로 생성된다. 이 아카이브는 View Controller의
=initWithCoder:= 메소드가 호출될 때 로딩된다. 그런다음 =awakeFromNib=
메소드가 구현된 모든 객체들에 대해 awakeFromNib 가 호출된다. 이
메소드를 사용하여 이미 생성된 다른 객체들을 필요로 하는 설정단계를
수행하게 된다.

아카이빙에 대해서는 /Archives and Serailization Programming Guide/ 를
참조

*** 코드로 부터 생성된 View Controller 의 초기화
View Controller 가 자신의 리소스를 코드로 부터 할당된다면, 여러분의
View Controller 에 특화된 커스텀 초기화 메소드를 생성해야 한다. 이
메소드는 부모 클래스의 init 메소드를 호출하고 난 다음, 클래스별
초기화작업을 수행한다.

일반적으로 초기화 메소드를 복잡하게 작성하지 않도록 한다. 대신,
단순한 초기화 메소드를 구현한 다음, 동작특성을 설정하기 위해 View Controller의
클라이언트에 대한 속성과 초기화 메소드를 구현한다. 

** View Controller 는 View 에 대한 접근이 일어날 때 View Hiearchy 를 생성
앱의 일부분이 View Controller 에게 View 객체 및 메모리에 현재 없는 객체를
요청하면, View Controller 는 View 계층을 메모리로 불러들이고, =view= 속성값에
저장해 놓는다. 로딩 사이클에 일어나는 작업들은 다음과 같다.

1. View Controller 는 =loadView= 메소드를 호출한다. 기본 구현은 다음의
   작업을 수행.

   - View Controller 가 스토리보드와 연관이 되어 있다면, 스토리보트로
     부터 view 를 로딩한다.
   - View Controller 가 스토리보드와 연관이 없다면, 비어있는 UIView
     객체가 생성되고 =view= 속성에 대입된다.

2. View Controller 는 =viewDidLoad= 메소드를 호출하는데, 이를 통해
   서브클래스는 로딩시, 추가적인 작업을 수행할 수 있게된다. 
   
   다음 그림은 로드 사이클을 표현하고 있는데, 호출되는 몇개의
   메소드들을 포함하고 있다. VC에게 요구되는 동작들이 앱에서 일어나게
   하기위해, =loadView= 와 =viewDidLoad= 메소드 모두를 오버라이드할 수
   있다. 예를 들어, 앱에서 스토리보드가 사용되지 않은 경우, 추가적인
   View 들을 View계층에 추가하려면, =loadView= 메소드를 오버라이드해서
   이 View들을 코드상에서 생성할 수 있다.
   
   (아래 그림에서 Custom Method ? 라는 의미는 오버라이드를 했다는 의미?!)

#+CAPTION:뷰를 메모리에 불러들이는 과정
[[file:img/LearnViewController_20130328_215650_.png]]

*** 스토리보드에서 VC 의 View 불러오기
대부분의 VC 는 연관된 스토리보드로 부터 자신의 view 를 불러올 수
있다. 스토리보드를 사용하는 잇점은 view 를 그래픽환경에서 설정하고
배치할 수  있다는 점이다. 쉽고 빠르게 레이아웃을 조정할 수 있다. 이런
저런 UI 결과물을 확인하여 잘 다듬어지고 정제된 설계를 할 수 있게된다.

**** IB에서 View 생성하기

***** IB 에서 View 의 표시 속성을 설정.
Inspector 에서 각종 속성을 조정한다.

***** VC 에 액션과 아웃렛 설정하기
아래 코드는 2개의 아웃렛과 1개의 액션을 정의.
#+BEGIN_SRC objc
  //
  // class category 로 *.m 파일에서 만든것으로 보이는데?
  //
  @interface MyViewController()
  @property (nonatomic) IBOutlet id myButton;
  @property (nonatomic) IBOutlet id myButton;
  
  -(IBAction)myAction:(id)sender;
  @end
#+END_SRC

위 코드는 객체간에 아래와 같은 연결을 한 것.

[[file:img/LearnViewController_20130329_190539_.png]]

IB 를 통해 미리 설정된 MyViewController 가 생성되고 Present 될 때, VC
의 기반코드는 자동으로 스토리로 부터 view 들을 불러들이고 아웃렛 또는
액션을 다시 설정한다. View 가 사용자에게 보여질 때, VC 의 아웃렛과
액션이 설정되고 사용가능한 상태가 된다. 런타임 코드와 디자인 타임
리소스 파일간의 연결능력은 스토리보드가 갖는 막강한 기능이다.(젠장)

***** View 를 코드로 생성하기
View 를 코드로 부터 직접 생성하는 것을 선호한다면, 스토리보드를
사용하는 대신, VC 의 =loadView= 메소드를 오버라이드하고 아래와 같이
구현한다.

1. root view 객체를 만든다.
   
   Root view 란, VC 와 연관된 다른 모든 View 를 포함하는 View를
   말한다. 보통은 앱의 Window 의 크기와 일치하는 이 View 를 위한
   frame을 정의하여, 화면전체를 꽉 채우게 된다. 하지만, frame 은 VC
   가 어떻게 표시되는지에 따라 조정된다. /Resizing the View
   Controller's Views/ 참조
   
   일반 UIView, 직접 정의한 커스텀 View, 또는 화면을 꽉 채울 수 있는
   다른 View를 사용하여 Root view 객체를 만들 수 있다.

2. 추가적인 Subview 들을 만들어 Root View에 추가한다.
   
   각 View 마다.

   - 생성하고 초기화

   - =addSubview:= 메소드를 사용해 부모 View 에 추가.

3. Auto Layout 을 사용한다면, 생성된 View 각각에 Contraints를 적절히
   넣어서 view 의 위치와 크기를 조정할 수 있다. 또는,
   =viewWillLayoutSubviews= 와 =viewDidLayoutSubviews= 메소드를
   사용해 View 계층내의 subview 들의 frame 을 조정할 수 있다.

4. 생성된 Root View 를 VC 의 =view= 속성에 대입한다. 
   
아래 코드는 =loadView= 메소드를 오버라이드하여 구현한 예이다.

*주의* =loadView= 를 오버라이드할 때, 부모클래스 =super= 의 =loadView=
는 호출하지 않는다. 우리의 =view= 를 만들것인데, 머하러 굳이 빈 view
를 만들어야 할 이유가 없잖은가?

#+BEGIN_SRC objc
  -(void)loadView
  {
      // 주의 : [super loadView] 를 호출하지 않음!!!!
  
      CGRect appFrame = [[UIScreen mainScreen] appFrame];
  
      // rootView 객체 'contentView' 를 생성/설정 -> self.view
      UIView *contentView = [[UIView alloc] initWithFrame:appFrame];
      contentView.backgroundColor = [UIColor blackColor];
      self.view = contentView;
  
      // 추가적인 subview 생성
      levelView = [[LevelView alloc] initWithFrame:appFrame
                                    viewController:self];
      [self.view addSubView:levelView];
  }
#+END_SRC

** 메모리 효율적으로 관리하기
VC 와 메모리 관리에 관해서 다음의 2가지를 염두에 둔다.

- 메모리를 어떻게 할당할 것인가
- 언제 메모리를 해제할 것인가
  
메모리할당은 전적으로 설계시에 결정되는 부분이지만, =UIViewController=
클래스는 메모리관리 작업과 연관된 몇가지 메소드를 제공하고 있다. 다음은
메모리를 할당/해제하기 적당한 장소/시점을 제공하는 메소드들을
나열한다.

*** =init= 또는 =initWithXXXX= 초기화 함수로 VC -> 필수적인 자료구조의 할당
=init= 같은 이름의 커스텀 초기화 메소드를 통해 할당.

*** =loadView=  -> View 객체 생성
이 메소드를 오버라이드해서 View 를 코드로 생성. 스토리보드를
사용한다면, View 는 자동적으로 스토리보드 파일에서 생성

*** =setXXX= 또는 =@property@= 커스텀 속성/메소드 -> 커스텀 객체 생성
=loadView= 와 유사한 패턴으로 구현하면 좋음. 속성값을 읽어보고 nil
이면, 로딩함수같은 걸 만들어서 객체를 생성하는 식.

*** =viewDidLoad= -> view 에 표시할 데이터를 할당 또는 불러오기.
데이터 객체는 VC 의 속성을 설정해서 제공한다. VC 가 생성하려는 그
어떤 추가적인 데이터 객체라도 =viewDidLoad= 메소드를 오버라이드해서
만들수 있다. 이 메소드가 호출될 때는 view 객체가 존재하는 시점 -->
따라서 view 를 핸들링할 수 있음(예: subview추가).

*** =didReceiveMemoryWarning= -> 메모리 부족에 대응
그닥 중요하지 않은 데이터는 이 메소드 호출시에 할당해제한다. iOS6
에서는 이 메소드에서 view 객체의 참조를 릴리즈할 수 있다.

*** =dealloc= -> 필수적 자료구조의 할당해제
VC 최후의 순간에 호출되는 이 메소드를 오버라이드해서 메모리 해제 작업을
수행한다. 참고로, *인스턴스 변수와 속성에 저장된 객체는 자동적으로
릴리즈 되므로 명시적 릴리즈는 필요없다*

** iOS 버젼별 메모리 관리의 차이

*** iOS6 이상에서, VC 는 필요한 경우에만 View 를 unload 한다.
VC 의 디폴트 동작은 =view= 속성 값이 맨 처음 접근될 때, View 계층을
불러들이고, 그 후로는 VC 가 파기될 때 가지 쭈욱 메모리에 유지한다.
View 가 화면 Drawing을 위해 사용하는 메모리는 커지기 쉽상이다. 하지만,
시스템은 View 가 Window 에 붙어있지 않을 때 자동적으로 이러한 고비용의
리소스를 자동으로 릴리즈한다(그리고 나중에 필요할 때 다시 생성한다).

아래 코드는 실제 예.
- 먼저 기본 구현을 실행 : =[super didReceiveMemoryWarning]=
- =view= 가 화면에 없는지 확인 : =if(![self.view window])=

#+BEGIN_SRC objc
  -(void)didReceiveMemoryWarning
  {
      [super didReceiveMemoryWarning];
  
      if ([self.view window] == nil) {
          // 나중에 다시 필요할 데이터를 여기에서 Keep해 둔다.
  
          // view 계층내 view 에 대한 강한 참조를 제거하기 위한 작업을
          // 한다.
  
          // 이제 root view 참조를 제거하여 삭제되도록 함.
          self.view = nil;
      }
  }
#+END_SRC

*** iOS5 및 그 이전에서, 시스템이 메모리 부족시 View 를 unload 한다.
이전버젼의 iOS 에서는, 메모리 부족시, 시스템이 자동으로 VC의 view 를 메모리에서
제거한다.

1. 앱이 시스템으로 부터 메모리 부족 통지를 수신
2. 각 VC 는 didReceiveMemoryWarning 의 메소드 호출을 받는다. 이를
   오버라이드 하면, VC 가 더이상 필요로 하지 않은 메모리 혹은
   객체들을 해제하도록 구현해야 한다.  =super= 의 기본구현은 *반드시*
   호출해야 한다. iOS5 및 그 이전버젼에서는 기본 구현이 view 를
   해제하려고 시도한다. 
3. 어떤 이유에서 View 가 해제되지 못했다면(예를들어, 아직 화면상에
   표시되고 있으면 해제할 수 없다), 기본 구현은 리턴한다(iOS6 및 그
   이후버젼에서는 기본 구현은 (View 해제 하지 않고) 그냥 리턴한다).
   /View 를 해제할 수 있는 상황이면, 아래 4~6 단계가
   수행된다(역자주)./
4. VC 가 =viewWillUnload= 메소드를 호출한다. 서브클래스는 이 메소드를
   오버라이드하여, View 가 파괴되기 전에 View 의 속성값들을 저장해 둘
   필요가 있다.
5. =view= 속성이 nil 로 설정된다.
6. VC 는 =viewDidUnload= 메소드를 호출한다. 서브클래스는 대개 이
   메소드를 오버라이드해서, 자신의 view 들에 대한 강한 참조를
   해제한다.
   
   
* View의 화면표시 관련 통지 처리
VC 의 View 가 visibility 가 변경되면, VC 는 몇몇 내장 메소드을 호출하여
서브클래스들에게 이 변경사항을 통지한다. 이 메소드들을 오버라이드하여
서브클래스들로 하여금 이러한 변경사항에 반응하도록 할 수 있다.
예를들면, 이러한 통지를 받은 시점에, 표시하고 하는 view 의 프리젠테이션
스타일 에 맞추어 상태바의 색상과 방향을 변경할 수 있다.

** View 가 표시될 때 처리하기
아래는 VC의 VC 가 윈도우의 view 계층에 추가될 때 일어나는 이벤트들의
순서를 표시한것임. =viewWillAppear:= 와 =viewDidAppear:= 메소드를
통해 서브클래스가 view표시와 관련된 추가적인 동작을 수행할 수 있는
시점이 주어진다.

[[file:img/LearnViewController_20130331_013106_.png]]

** View 가 사라질 때 처리하기
윈도우로 부터 View 가 제거될 때 일어나는 이벤트의 순서는 다음과 같다.
VC 가 View의 화면에서의 제거 또는 감춰짐을 검출하면,
=viewWillDisappear:= 를 호출하고 =viewDidDisappear:= 메소드를
호출하여 서브클래스로 하여금 추가적인 관련 작업을 수행할 수 있게 해
준다.

[[file:img/LearnViewController_20130331_013420_.png]]

** View 의 화면표시에 대한 변경사항이 왜 생겼는지 알기
종종, view 가 사라지거나 표시되는 데에 대한 이유를 아는 것이 유용할
때가 있다. 예를들면, 컨테이너에 View 가 추가되거나 View 를 덮고 있던
어떤 다른 컨텐츠가 사라져서 View의 표시가 필요하게 되었는지 알기 원할
때가 있을 것이다. 특별히, 네비게이션 컨트롤러를 사용할 때에 그러하다.
네비게이션 스택에 VC 가 push 되어 드러나게 되었는지, 아니면, 이전에
그위를 덮고 있던 다른 VC 가 스택에서 pop 되어서 보이게 되었는지와
같은 사항을 알아야 할 때가 있다.

=UIViewController= 클래스는 사용자의 VC 클래스가 "왜 내가
표시되었는지"를 알게 해주는 메소드들을 제공한다. 아래 표는 그러한
메소드들과 각각의 용도를 표시한다. 이들 메소드들은 =viewWillAppear:=
, =viewDidAppear:= , =viewWillDisappear:= 및 =viewDidDisappear:=
메소드들 에서 호출된다.

|---------------------+-----------------------------------------------|
| 메소드 이름         | 용도                                          |
|---------------------+-----------------------------------------------|
| isMovingFromParent- | viewWillDisapper: 와 viewDidDisappear: 메소드 |
| ViewController      | 에서 호출하여 VC 가 자신의 컨테이너로 부터 제 |
|                     | 거되어 감춰진 것인지를 알 수 있게 한다.       |
|---------------------+-----------------------------------------------|
| isMovingToParent-   | viewwWillAppear: 와 viewDidAppear: 메소드     |
| ViewController      | 에서, VC가 컨테이너에 추가되어 VC의 view가    |
|                     | 화면에 표시되었는지를 알 수 있다              |
|---------------------+-----------------------------------------------|
| isBeginPresented    | viewWillAppear: 와 viewDidAppear: 에서 이 메  |
|                     | 소드들을 호출하여 VC 가 다른 VC 로 부터       |
|                     | present 되어 화면에 표시되었는지 알 수 있다.  |
|---------------------+-----------------------------------------------|
| isBeginDismissed    | viweWillAppear: 와 viewDidDisappear: 에서     |
|                     | 이 메소드를 호출하여, VC가 dismiss 되어       |
|                     | VC 의 view 가 화면에서 사라졌는지 알 수 있다. |
|---------------------+-----------------------------------------------|


* VC의 view 크기변경하기.
VC 는 자기자신만의 view 를 소유하고 그 view의 컨텐츠를 관리한다. 그
과정에서 VC 는 또한, view 의 subview 들을 관리한다. 하지만 대부분,
view의 프레임은 VC 로 부터 직접 설정되지 않는다. 대신, VC의 프레임은
VC의 view가 어떻게 표시되는지에 따라 결정된다. 좀더 직접적으로는,
화면에 표시되도록 하는 객체의 의해 설정된다. 상태바가 존재하는 것
괕은 앱내 다른 조건들로 인해 프레임의 크기가 변경된다. 이런 이유로
사용자의 VC 는 view의 프레임이 변경될 때, view 의 컨텐츠를 변경할
준비를 해야만 한다.

** Root VC 의 View의 프레임은 윈도우가 설정한다.
윈도우의 root VC 와 연관된 view 는, 윈도우의 특성에 따라 프레임 크기를
얻게된다. 윈도우에 의해 설정된 이 프레임의 크기는 다음과 같은 요소들에
의해 결정/변경된다.

- 윈도우의 프레임
- 상태바가 보이는지 여부
- 상태바가 일시적인 정보(예:전화 수신)를 추가적으로 표시하는지 여부
- 장치방향이 Landscape 또는 Portrait
- Root VC 의 =wantsFullScreenLayout= 속성값
  
앱이 상태바를 표시하는 경우, View 는 아래쪽의 상태바에 의해 일부가
가려지지 않기 위해 크기를 줄인다. 상태바가 불투명하다면, 그 밑에 있는
View 는 표시할 수도 상호작용할 수도 없기 때문이다. 하지만, 앱이
반투명한 상태바를 표시한다면, VC 의 =wantsFullScreenLayout= 속성을 YES
로 설정하여 view가 전체화면모드로 표시되게 할 수 도 있다.

전체화면모드는 컨텐츠를 표시하고자하는 영역을 극대화하는 대 유용하다.
상태바 밑에 컨텐츠를 표시하는 경우, 스크롤뷰 안에 컨텐츠를 넣어
사용자가 상태바 밑에 있는 부분을 볼 수 있도록 상호작용하게 할 수 도
있다. 컨텐츠를 스크롤하는 기능은, 반투명 상태바, 툴바, 혹은
네비게이션바 뒤쪽의 내용을 사용자가 볼 수 있게 해 주는 중요한
기능이다. 네비게이션바는 root VC 가 scroll view 면, 자동으로 스크롤
영역 틀(scroll content inset)을 설정한다(0보다 큰 값이면 사각형틀
안쪽으로 영역이 줄어든다. =UIScrollView= 의 =contentInset= 참조.

** 컨테이너는 자식 view 들의 frame들을 설정한다.
VC 가 컨테이너 VC 의 자식이라면, 부모인 컨테이너가 자식들중 어떤 것이
화면에 표시되어야 할 지를 결정한다. View 가 표시되어야 할 때, 자신의
View 계층에 있는 서브뷰들을 추가하고, 각 프레임을 UI에 맞추어
설정한다. 예를들어,

- 탭 VC 는 자신의 view 밑 부분에 탭바를 위한 공간을 남겨둔다. 그리고
  현재 화면에 보이는 자식 View의 크기를 나머지 공간으로 설정한다.
- 네비게이션 VC 는 자신의 view 윗 부분에 네비게이션바를 위한 공간을
  남겨둔다. 현재 보이는 자식 VC 가 네비게이션바를 표시하고자 한다면,
  view 를 화면 아래쪽에 위치시킨다. view 의 나머지는 자식들이 내용을
  채우기 위해 주어진다. 
  
자식 VC 는 root VC 에 다다를 때 까지 자신의 부모 VC로 부터 frame을
가져오는데, 결국 최종적으로는 윈도우로 부터 frame 을 얻어오게 된다. 

** Preset된 VC 는 Presentation Context 를 사용한다.
VC가 다른 VC에 의해 preset될 때, VC의 frame은 presentation context에
의해 결정된다. /Presetntation Context에 의해 Present된 VC에 의해
점위되는 영역이 결정된다/ 부분을 참조.

** Popover 컨트롤러는 표시되는 View의 크기를 결정한다.
Popover 컨트롤러로 표시된 VC 는 자신의 View 영역의 크기를,
=contentSizeForViewInPopover= 속성값을 원하는 값으로 설정함으로써
결정한다. Popover 컨트롤러가 =popoverContentSize= 속성을 다른크기의
view 값으로 설정했다면, 그 값이 =contentSizeForViewInPopover= 를
오버라이드한다.
다른 VC 에 의해 사용된 모델과 일치하려면, popover 컨트롤러의 속성을
사용해 크기와 위치를 제어한다. 

** VC 가 View 의 레이아웃 처리에 어떻게 참여하는가.
VC 의 view의 크기가 변경될 때, Subivew들은 자신들에게 허락된 새로운
공간에 맞추어 위치가 조정된다. 컨트롤의 View 계층에 View는 레이아웃
제한자(Layout constraints)와 자동크기조절 마스크(autoresizing mask)를
통해 대부분의 작업을 수행할 수 있다. 하지만, VC 는 또한 이 과정에서
다양한 시점에 호출을 받는다. 아래는 이를 정리한 것.

1. VC 의 view 가 새로운 크기로 변경된다.
2. autolayout 이 사용되지 않으면, view 는 autoresizing mask 의 설정에
   따라 크기변경이 된다.
3. VC 의 =viewWillLayoutSubviews= 메소드가 호출된다.
4. view 의 =layoutSubviews= 메소드가 호출된다. 만일 autolayout 이
   view 계층을 설정하는데 사용되고 있으면, 아래의 단계를 수행하여
   layout constraints 를 갱신한다.
   1) VC 의 =updateViewConstraints= 메소드가 호출된다.
   2) =UIViewController= 클래스의 =updateViewConstraints= 메소드가
      view 의 updateConstraint 메소드를 호출한다.
   3) layout constraint 가 갱신된 다음, 새로운 layout이 계산되고,
      view 의 위치가 재조정된다.
5. VC 의 =viewDidLayoutSubviews= 메소드가 호출된다.
   
이상적으로는, view 들은 각각 자기 자신의 위치를 재조정하기 위해
필요한 모든일을, VC 를 전혀 개입시키지 않은 상태에서 수행한다. 종종,
layout 을 IB 안에서만 설정할 수도 있지만, VC 가 view를 동적으로
추가/삭제하는 경우에는 IB 안에서만 설정하는 것으로는 원하는 결과를
얻을 수 없다. 이런 경우, VC 는 layout 을 조정하기 위한 적당한 장소가
되는데, view자체는 화면내에서 이웃하는 다른 view들로의 접근이
제한적이기 때문이다. VC 에서 이런작업은 하는 최고의 접근법은 아래와
같다.

- layout constraint 들을 사용해 view의 위치가 자동 재조정되도록
  한다(iOS6 이후).  =updateViewConstraints= 를 오버라이드해서 view 에
  설정되지 않은 필요한 layout constraint을 추가할 수 있다. 사용자가
  오버라이드한 이 메소드내에서는 반드시 [super updateViewConstraints]
  를 호출해야 한다.
  
  상세한 사항은 /Cocoa Auto Layout Guide/ 를 참고

- autoresizing mask 와 코드를 조합하여 view 의 위치를 재조정한다(iOS
  5.x). =layoutSubviews= 를 오버라이드해서 resizing mask 의
  사용만으로는 자동 재조정되지 않는 view의 위치를 재조정할 수 있다. 
  
  view 의 autoresizing mask 에 대한 정보와 view 미치는 영향에
  대해서는 /View Programming Guide for iOS/ 를 참조.
  
* Responder Chain 에서 VC 사용하기
VC 는 UIResponder 로 부터 상속받은 클래스이므로, 모든 이벤트를 처리할
수 있다. View 가 주어진 이벤트에 응답하지 않을때, 자신의 부모 view 에
그 이벤트를 전달하며, 계속 응답되지 않을 경우 root view 까지 view
계층을 거슬러 올라가게 된다. 하지만, 이러한 chain에서 view 가 VC에
의해서 관리되면, view 는 이벤트를 부모 view 로 올려보내기 전에 먼저
자신을 관리하는 VC 에 이벤트를 보낸다.  이런 방식으로, VC 는 자신의
view들이 응답하지 않은 이벤트에 대한 처리를 할 수 있다. VC 가
이벤트를 처리하지 않으면, view 의 부모 view 로 전달된다.

** Responder Chain 은 이벤트가 App 에서 어떻게 전달되는지를 정의.
다음 그림은 View 계층에서의 이벤트의 흐름을 도식화 한것. 전체화면
크기의 일반적인 view 객체에 들어있는 커스텀 view가 있다고 치자.
커스텀 view의 frame내에 Touch Event가 도달하면, 그 이벤트는 처리를
위해 view에게 전달된다. 만일 view 가 이벤트를 처리하지 않으면, 부모
view로 올려보낸다. 일반적인 view 는 이벤트를 전혀 처리하지 않으므로,
이벤트들은 자신의 VC 에 먼저 전달된다. VC가 그 이벤트를 처리하지
않으면, UIView 객체의 super view에게 전달되며, 여기서는 window 객체가
수신자가 된다.

[[file:img/LearnViewController_20130401_012322_.png]]

*주의* VC 와 자신의 View간의 메시지 전달관계는 VC에 의해서 은밀하게
관리되며, 앱에 의해 코드조작으로 수정될 수 없다.

사용자의 VC 에서 터치 이벤트를 처리하지 않으려 한다 해도, 모션기반
이벤트를 처리하기 위해 사용할 수도 있다. 또, first respondr를
조정하고 설정하기 위해 VC를 사용할 수도 있다. 

iOS내에서 이벤트가 어떻게 분산되고 처리되는지에 대해서는 /Event
Handling Guide for iOS/ 참조

* 여러 장치 방향에 대한 지원
iOS 기반 장치의 가속센서는 장치의 현재 방향을 알 수 있게 해준다.
디폴트로 앱은 portrait 와 landscape 방향을 모두 지원한다. iOS 기반
장치에서 방향이 바뀔 때, 시스템은
=UIDeviceOrientationDidChangeNotification= 통지를 내보내어 이에 따라
처리되어야 하는 객체가 이를 받아 처리할 수 있게 해준다.  UIKit
프렘웍은 이 통지에 대기하다 사용자 인터페이스를 자동으로 갱신할 수
있게 해 준다. 이 말은, 몇몇 예외를 제외하고는 이 통지를 꼭 처리해야
할 필요는 없다는 의미가 된다.

[[file:img/LearnViewController_20130401_012947_.png]]

사용자 인터페이스가 회전하면, 윈도는 새로운 방향에 맞도록 크기가
조정된다. window 는 자신의 root VC 의 frame을 새로운 크기에 맞추고,
그 크기는 다시 view 계층을 따라 다른 view 들로 내려가며 전파된다.
따라서, 여러분의 VC가 여러 방향을 지원하게 하기 위한 가장 간단한
방법은 subview 들의 위치가 root view의 frame 이 변경될 때 마다
갱신되도록 하는 것이다.  대다수의 경우, VC의 가시영역 변경을 유발하는
다른 조건들이 이미 있기 때문에 이런한 작업을 벌써 하고 있었을 수 도
있다. View 레이아웃에 대한 설정에 관한 상세 정보는 "VC 의 View 크기
조정" 부분을 참조

디폴트 동작과 다른 동작을 앱에서 구현하려면 다음과 같은 일을 직접 해
주어야 한다.

- 앱이 지원한 장치 방향
- 두 방향간 회전이 화면상에서 애니메이션되는 방법

전체화면을 채우지 않는 VC 는 UI의 방향을 신경쓰면 안된다. 대신, 부모
VC에 의해 제공되는 영역을 채우도록 해야 한다. Root VC (또는
전체화면으로 present 된 VC) 는 장치의 방향에 좀 더 신경을 써야 할
것인다. 

** 어떤 장치 방향이 지원되는지 제어하기(iOS 6)
UIKit 이 방향 통지를 수신할 때, UIApplication 객체와 root VC를
사용하여 새로운 방향이 허용되는지를 판단한다. 만일 두 객체가 새로운
방향을 지원하는 것으로 허용하면, UI 는 새로운 방향에 맞추 회전한다.
그렇지 않으면 장치의 방향을 무시된다.

VC 가 root VC 위로 preset 되었을때, 시스템의 동작은 2가지 로
변경된다.
1. 해당 방향이 지원되는지에 대해 결정할 때, root VC 대신  Present된
   VC가 사용된다.
2. Presetn된 VC는 *선호 방향(preferred orientation)* 이란 것을 제공할
   수 있다. VC 가 전체화면으로 present 되었다면, UI 는 선호 방향으로
   present된 것이다. 사용자는 화면표시가 장비방향과 맞지 않는 다고
   생각하고 장치를 회전시킬 것이다. *선호 방향* 은 컨텐츠가 새로운
   방향으로 표시되어야만 할 때 종종 사용된다. 
   
*** VC 의 지원 인터페이스 방향 선언하기

