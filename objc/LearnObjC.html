
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Objective-C 배우기</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Objective-C 배우기"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-03-21T20:32+0900"/>
<meta name="author" content="Joonhwan"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><linkrel="stylesheet" type="text/css" href="org-styles.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Objective-C 배우기</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 IOS.Nerd.Ranch.Guide 제2판</a>
<ul>
<li><a href="#sec-1-1">1.1 [receiver selector: argument]</a></li>
<li><a href="#sec-1-2">1.2 ObjC 에서는 함수 시그너쳐에 따른 오버로딩은 불가능하다.</a></li>
<li><a href="#sec-1-3">1.3 NSMutableArray/NSArray 에 추가되는 객체의 참조카운트변화</a></li>
<li><a href="#sec-1-4">1.4 ObjC 의 메소드이름은 라벨 이름을 모두 합친 것. Colon(:)의 갯수가 인자의 갯수</a></li>
<li><a href="#sec-1-5">1.5 @property(애트리뷰트,애트리뷰트&hellip;)</a></li>
<li><a href="#sec-1-6">1.6 @property로 속성선언, @synthesize로 속성접근함수를 정의한다.</a></li>
<li><a href="#sec-1-7">1.7 copy 하게 되면 모든 NSMutableXXX 는 immutable객체로 복제된다.</a></li>
<li><a href="#sec-1-8">1.8 autorelease 는 AutoReleasePool(NSAutoRelease객체?!)가 drain될 때 release.</a></li>
<li><a href="#sec-1-9">1.9 ObjC 의 생성자는 -(void)init.</a></li>
<li><a href="#sec-1-10">1.10 designated initializer.</a></li>
<li><a href="#sec-1-11">1.11 ObjC 의 소멸자는 -(void)dealloc.</a></li>
<li><a href="#sec-1-12">1.12 Target-Action vs Delegation</a></li>
<li><a href="#sec-1-13">1.13 NSObject 는 protocol로서, 또 class로서 존재한다.</a></li>
<li><a href="#sec-1-14">1.14 protocol 의 디폴트는 required. delegate protocol은 대부분 optional</a></li>
<li><a href="#sec-1-15">1.15 delegate 속성은 (&hellip;,retain)이 아니라 (&hellip;, assign).</a></li>
<li><a href="#sec-1-16">1.16 @sythesize window=_window 의 의미.</a></li>
<li><a href="#sec-1-17">1.17 XCode 4.2 이상에서는 Window Based Application 이 사라졌다.</a></li>
<li><a href="#sec-1-18">1.18 ARC사용시 Rule, the sad(책이 오래된 것만 있다 -_-)but the happy(일이 훨씬 간단한해진다).</a></li>
</ul>
</li>
<li><a href="#sec-2">2 IOS.Nerd.Ranch.Guide 제3판</a>
<ul>
<li><a href="#sec-2-1">2.1 4장 위임</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1 프로젝트를 구성하는 것.</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2 5장 MapKit 과 Text Input</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1 @protocol 에 대해 추가 학습</a></li>
<li><a href="#sec-2-2-2">2.2.2 UITextField 와 First Responder</a></li>
<li><a href="#sec-2-2-3">2.2.3 ARC 가 있어 메모리 관리가 편해지긴 했지만&hellip;.</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3 6장 UIView 와 UIScrollView 상속받기.</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1 UIView 에 동그라미와 텍스트 그리기</a></li>
<li><a href="#sec-2-3-2">2.3.2 UIView의 setNeedsDisplay 메시지(win32의 무효화개념).</a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4 7장 View Controller</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1 UIWindow / UIViewController  생성</a></li>
<li><a href="#sec-2-4-2">2.4.2 각 UIViewController 들 view 를 생성하는 방법</a></li>
<li><a href="#sec-2-4-3">2.4.3 IOS6.0 이후 부터는 메모리 여분이 부족해도 view 를 unload 하지 않는다.</a></li>
<li><a href="#sec-2-4-4">2.4.4 view 는 화면표시/제거 되는 각 단계별로 통지 메시지가 있다.</a></li>
</ul>
</li>
<li><a href="#sec-2-5">2.5 8장 Notification 과 Rotation</a>
<ul>
<li><a href="#sec-2-5-1">2.5.1 Notification</a></li>
<li><a href="#sec-2-5-2">2.5.2 UIDevice의 Notification</a></li>
<li><a href="#sec-2-5-3">2.5.3 @selector 구문</a></li>
<li><a href="#sec-2-5-4">2.5.4 Rotation 발생시 view 처리 : 결국 Resizing 처리(가로/세로가 바뀌므로)</a></li>
<li><a href="#sec-2-5-5">2.5.5 UIViewController 의 willAnimateRotationToInterfaceOrientaion:duration:</a></li>
<li><a href="#sec-2-5-6">2.5.6 Proximity : 휴대폰을 얼굴 가까이 갖다 댄 정도에 대한 센서</a></li>
</ul>
</li>
<li><a href="#sec-2-6">2.6 9장 UIITableView 와 UITableViewController</a>
<ul>
<li><a href="#sec-2-6-1">2.6.1 Singleton 구현방법</a></li>
<li><a href="#sec-2-6-2">2.6.2 UITableViewController</a></li>
</ul>
</li>
<li><a href="#sec-2-7">2.7 10장 UITableView 편집</a>
<ul>
<li><a href="#sec-2-7-1">2.7.1 노트</a></li>
<li><a href="#sec-2-7-2">2.7.2 편집모드시 기억사항</a></li>
</ul>
</li>
<li><a href="#sec-2-8">2.8 11장 UINavigationController</a></li>
<li><a href="#sec-2-9">2.9 12장 Camera</a>
<ul>
<li><a href="#sec-2-9-1">2.9.1 인터페이스 빌더에서 target-action pair 을 Ctrl-Drag 하여 생성하기</a></li>
<li><a href="#sec-2-9-2">2.9.2 UIImageView</a></li>
<li><a href="#sec-2-9-3">2.9.3 UIToolbar</a></li>
<li><a href="#sec-2-9-4">2.9.4 UIImagePickerController - UIImagePickerControllerDelegate</a></li>
<li><a href="#sec-2-9-5">2.9.5 UIView 의 presentVieController:animated:completion 메소드</a></li>
<li><a href="#sec-2-9-6">2.9.6 UIView 의 endEditing 메소드 &ndash;&gt; "키보드 화면에서 없애기".</a></li>
<li><a href="#sec-2-9-7">2.9.7 NSDictionary</a></li>
<li><a href="#sec-2-9-8">2.9.8 CoreFoundation 과 Toll-free bridge. 그리고 메모리 관리(CFRelease)</a></li>
</ul>
</li>
<li><a href="#sec-2-10">2.10 13장 UIPopoverController 와 Modal View Controller들</a>
<ul>
<li><a href="#sec-2-10-1">2.10.1 유니버설 바이너리</a></li>
<li><a href="#sec-2-10-2">2.10.2 유니버설화(Universalizing)</a></li>
<li><a href="#sec-2-10-3">2.10.3 기기 상태 코드로 확인하기 : UIDevice 의 userInterfaceIdiom 속성--</a></li>
<li><a href="#sec-2-10-4">2.10.4 기기별로 다른 처리 하는 예</a></li>
<li><a href="#sec-2-10-5">2.10.5 UIPopoverController : IPad 전용 뷰 컨트롤러.</a></li>
<li><a href="#sec-2-10-6">2.10.6 View Controller 간의 관계 : Parent/Child 그리고 Presenting/Presenter</a></li>
</ul>
</li>
<li><a href="#sec-2-11">2.11 14장 Saving, Loading 및 Application States</a>
<ul>
<li><a href="#sec-2-11-1">2.11.1 어플의 세션간 데이터 유지</a></li>
<li><a href="#sec-2-11-2">2.11.2 NSCoding protocol</a></li>
<li><a href="#sec-2-11-3">2.11.3 Application Sandbox</a></li>
<li><a href="#sec-2-11-4">2.11.4 파일경로 생성방법</a></li>
</ul>
</li>
<li><a href="#sec-2-12">2.12 19장 Touch</a>
<ul>
<li><a href="#sec-2-12-1">2.12.1 UIControl 에 대한 설명</a></li>
</ul>
</li>
<li><a href="#sec-2-13">2.13 20장 UIGestureRecognizer 와 UIMenuController</a>
<ul>
<li><a href="#sec-2-13-1">2.13.1 UIGestureRecognizer</a></li>
<li><a href="#sec-2-13-2">2.13.2 UITapGestureRecognizer</a></li>
<li><a href="#sec-2-13-3">2.13.3 UIMenuController : "편집"메뉴(Cut/Copy/Paste/Select/Delete&hellip;)다!</a></li>
<li><a href="#sec-2-13-4">2.13.4 UILongPressGestureRecognizer</a></li>
<li><a href="#sec-2-13-5">2.13.5 UIPanGestureRecognizer</a></li>
</ul>
</li>
<li><a href="#sec-2-14">2.14 22장 Core Animation Layer.</a>
<ul>
<li><a href="#sec-2-14-1">2.14.1 QuartzCore.framework</a></li>
<li><a href="#sec-2-14-2">2.14.2 CALayer 는 UIKit 에서는 모든 View가 가진다.</a></li>
<li><a href="#sec-2-14-3">2.14.3 CALayer의 주요 속성</a></li>
<li><a href="#sec-2-14-4">2.14.4 CALayer 는 암묵적으로 animation기능이 들어간다.</a></li>
<li><a href="#sec-2-14-5">2.14.5 CALayerDelegate 의 drawLayer:inContext: 메시지</a></li>
</ul>
</li>
<li><a href="#sec-2-15">2.15 23장 CAAnimation 을 사용한 애니메이션</a>
<ul>
<li><a href="#sec-2-15-1">2.15.1 Layer를 View에 더하고, Animation을 Layer에 더하다</a></li>
<li><a href="#sec-2-15-2">2.15.2 Animation 객체의 종류</a></li>
<li><a href="#sec-2-15-3">2.15.3 CALayer 의 애니메이션가능 속성</a></li>
<li><a href="#sec-2-15-4">2.15.4 KeyPath 찾는 방법</a></li>
<li><a href="#sec-2-15-5">2.15.5 CABasicAnimation</a></li>
<li><a href="#sec-2-15-6">2.15.6 CAKeyframeAnimation</a></li>
<li><a href="#sec-2-15-7">2.15.7 CAAnimationGroup</a></li>
<li><a href="#sec-2-15-8">2.15.8 CATransition</a></li>
<li><a href="#sec-2-15-9">2.15.9 Timing Function</a></li>
<li><a href="#sec-2-15-10">2.15.10 Animation Completion</a></li>
<li><a href="#sec-2-15-11">2.15.11 CALayer의 Presentation Layer(그리고 Model Layer)</a></li>
</ul>
</li>
<li><a href="#sec-2-16">2.16 24장 UIStoryboard</a>
<ul>
<li><a href="#sec-2-16-1">2.16.1 기본준비</a></li>
<li><a href="#sec-2-16-2">2.16.2 Segue(세그웨이:곡/영화등에서 부드러운 장면전환)s</a></li>
<li><a href="#sec-2-16-3">2.16.3 한번써보기.</a></li>
<li><a href="#sec-2-16-4">2.16.4 스토리보드를 써야 할까?</a></li>
</ul>
</li>
<li><a href="#sec-2-17">2.17 25장 웹 서비스와 UIWebView</a>
<ul>
<li><a href="#sec-2-17-1">2.17.1 목표 어플 "NerdFeed" 의 기능</a></li>
<li><a href="#sec-2-17-2">2.17.2 웹 서비스</a></li>
<li><a href="#sec-2-17-3">2.17.3 NerdFeed 만들기</a></li>
<li><a href="#sec-2-17-4">2.17.4 URL 구성하여 서버에 페이지 요청하기</a></li>
<li><a href="#sec-2-17-5">2.17.5 페이지 XML 데이터 파싱 - NSXMLParser</a></li>
<li><a href="#sec-2-17-6">2.17.6 NSXMLParser 의 delegate 를 동적으로 변경</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3">3 학습메모</a>
<ul>
<li><a href="#sec-3-1">3.1 변수이름 shadowing 문제 : 속성값방식으로 접근하기 vs 멤버변수로 접근하기</a></li>
<li><a href="#sec-3-2">3.2 ARC : property attribute 와 variable qualifier</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1 property attributes</a></li>
<li><a href="#sec-3-2-2">3.2.2 variable qualifier</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3 ARC : factory class method정의시 "이름"에 따라 컴파일러가 달리 처리한다!!!</a></li>
<li><a href="#sec-3-4">3.4 무명 class extension</a></li>
<li><a href="#sec-3-5">3.5 ObjC 에서 singleton 구현</a></li>
<li><a href="#sec-3-6">3.6 Target-Action 은 누가 구현하고 있는가.</a></li>
<li><a href="#sec-3-7">3.7 </a></li>
<li><a href="#sec-3-8">3.8 NSString 이 파일경로 문자열의 parse/manipulate 을 한다.</a></li>
<li><a href="#sec-3-9">3.9 NSString 이 하는 일의 종류</a>
<ul>
<li><a href="#sec-3-9-1">3.9.1 Creating and Initializing Strings</a></li>
<li><a href="#sec-3-9-2">3.9.2 Creating and Initializing a String from a File</a></li>
<li><a href="#sec-3-9-3">3.9.3 Creating and Initializing a String from an URL</a></li>
<li><a href="#sec-3-9-4">3.9.4 Writing to a File or URL</a></li>
<li><a href="#sec-3-9-5">3.9.5 Getting a String’s Length</a></li>
<li><a href="#sec-3-9-6">3.9.6 Getting Characters and Bytes</a></li>
<li><a href="#sec-3-9-7">3.9.7 Getting C Strings</a></li>
<li><a href="#sec-3-9-8">3.9.8 Combining Strings</a></li>
<li><a href="#sec-3-9-9">3.9.9 Dividing Strings</a></li>
<li><a href="#sec-3-9-10">3.9.10 Finding Characters and Substrings</a></li>
<li><a href="#sec-3-9-11">3.9.11 Replacing Substrings</a></li>
<li><a href="#sec-3-9-12">3.9.12 Determining Line and Paragraph Ranges</a></li>
<li><a href="#sec-3-9-13">3.9.13 Determining Composed Character Sequences</a></li>
<li><a href="#sec-3-9-14">3.9.14 Converting String Contents Into a Property List</a></li>
<li><a href="#sec-3-9-15">3.9.15 Identifying and Comparing Strings</a></li>
<li><a href="#sec-3-9-16">3.9.16 Folding Strings</a></li>
<li><a href="#sec-3-9-17">3.9.17 Getting a Shared Prefix</a></li>
<li><a href="#sec-3-9-18">3.9.18 Changing Case</a></li>
<li><a href="#sec-3-9-19">3.9.19 Getting Strings with Mapping</a></li>
<li><a href="#sec-3-9-20">3.9.20 Getting Numeric Values</a></li>
<li><a href="#sec-3-9-21">3.9.21 Working with Encodings</a></li>
<li><a href="#sec-3-9-22">3.9.22 Working with Paths</a></li>
<li><a href="#sec-3-9-23">3.9.23 Working with URLs</a></li>
<li><a href="#sec-3-9-24">3.9.24 Linguistic Tagging and Analysis</a></li>
</ul>
</li>
<li><a href="#sec-3-10">3.10 Informal Protocol</a></li>
<li><a href="#sec-3-11">3.11 CoreGraphics 에 Path 의 HitTesting</a></li>
<li><a href="#sec-3-12">3.12 Qt의 "Fit" 또는 "ResizePolicy" 가 Quartz에서는 "Contents Gravity"</a></li>
<li><a href="#sec-3-13">3.13 UIImage 의 imageNamed: 메시지는 cached 된 이미지를 반환한다.</a></li>
<li><a href="#sec-3-14">3.14 CGContextRef(Graphics Context - "GD")를 얻는 방법</a></li>
<li><a href="#sec-3-15">3.15 어떤 클래스의 생성자 찾는 방법 - 그 클래스에 없는 생성자도 있네?!</a></li>
<li><a href="#sec-3-16">3.16 어떤 Delegate 는 문서에는 없어도 존재하네?!?!</a></li>
<li><a href="#sec-3-17">3.17 UIAlertView : 간단한 메시지 상자.</a></li>
<li><a href="#sec-3-18">3.18 유용한 UIControl 샘플 예제 : "UICatalog"</a></li>
<li><a href="#sec-3-19">3.19 #pragma - some-useful-information-for-xcode-navigation-bar</a></li>
</ul>
</li>
<li><a href="#sec-4">4 Apple 공식문서 코스워크 순서</a>
<ul>
<li><a href="#sec-4-1">4.1 우선 읽고 볼 문서</a></li>
<li><a href="#sec-4-2">4.2 결국 읽어야 할 문서</a></li>
<li><a href="#sec-4-3">4.3 필요하면 찾아볼 문서 (중요)&gt;</a></li>
<li><a href="#sec-4-4">4.4 생각나면 한번쯤 읽어 볼 문서</a></li>
<li><a href="#sec-4-5">4.5 필요하면 찾아 볼 문서 (덜 중요)</a></li>
<li><a href="#sec-4-6">4.6 가장 나중에 읽을 문서 (Mac OS X와 겹치는 것이 많음)</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> IOS.Nerd.Ranch.Guide 제2판</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> [receiver selector: argument]</h3>
<div class="outline-text-3" id="text-1-1">


<ul>
<li>receiver : 객체에 대한 pointer
</li>
<li>selector : method 를 호출하기 위한 이름
</li>
<li>argument : method에 사용되는 것.




<pre class="src src-objc">[arrayInstance replaceObjectsInRange:aRange
                withObjectsFromArray:anotherArray
                               range:anotherRange];
</pre>


<p>     
     receiver=arrayInstacne
     selector=replaceObjectsInRange, withObjectsFromArray, range
     argument=aRange, anotherArray, anotherRange
</p></li>
</ul>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> ObjC 에서는 함수 시그너쳐에 따른 오버로딩은 불가능하다.</h3>
<div class="outline-text-3" id="text-1-2">


<p>
   이를테면, C++ 에서는
</p>



<pre class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">add</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>);
<span class="org-type">void</span> <span class="org-function-name">add</span>(<span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span>);
</pre>


<p>
   같은 것이 가능하지만, ObjC 에서는 불가능하다. 대신
</p>



<pre class="src src-objc"><span class="org-keyword">@interface</span> <span class="org-type">MyCalc</span> : <span class="org-type">NSObject</span>
+(<span class="org-type">int</span>)<span class="org-function-name">add</span>:(<span class="org-type">int</span>)<span class="org-variable-name">a</span> <span class="org-function-name">withInt</span>:(<span class="org-type">int</span>)<span class="org-variable-name">b</span>;
+(<span class="org-type">double</span>)<span class="org-function-name">add</span>:(<span class="org-type">double</span>)<span class="org-variable-name">a</span> <span class="org-function-name">withDouble</span>:(<span class="org-type">double</span>)<span class="org-variable-name">b</span>;
<span class="org-keyword">@end</span>

<span class="org-keyword">@implementation</span> <span class="org-type">MyCalc</span>
+(<span class="org-type">int</span>)<span class="org-function-name">add</span>:(<span class="org-type">int</span>)<span class="org-variable-name">a</span> <span class="org-function-name">withInt</span>:(<span class="org-type">int</span>)<span class="org-variable-name">b</span>
{
    <span class="org-keyword">return</span> a+b;
}
+(<span class="org-type">double</span>)<span class="org-function-name">add</span>:(<span class="org-type">double</span>)<span class="org-variable-name">a</span> <span class="org-function-name">withDouble</span>:(<span class="org-type">double</span>)<span class="org-variable-name">b</span>
{
    <span class="org-keyword">return</span> a+b;
}
<span class="org-keyword">@end</span>

</pre>


<p>
   이런식으로 각각의 라벨을 하나로 합친 것(즉, 위의 경우,
   add:withInt:
   add:withDouble:
   &ndash;&gt; 이걸 selector 라고 하는 것 같다) 이름이 다른 경우에는 ok.
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> NSMutableArray/NSArray 에 추가되는 객체의 참조카운트변화</h3>
<div class="outline-text-3" id="text-1-3">


<p>
   ObjC 에서는 배열(NS*Array 클래스)이 값을 담는게 아니다. 어떤 객체의
   포인터를 담는다. 그런데, 포인터의 타입을 고정하지 않는다. 따라서,
   서로 다른 타입의 객체에 대한 포인터를 담을 수 있다. 이런 경우,
   참조되는 객체의 참조카운트가 +1 된다(retain). 배열이 파괴될 때는 각 배열
   항목들이 갖는 포인터의 참조카운트가 -1 된다(release).
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> ObjC 의 메소드이름은 라벨 이름을 모두 합친 것. Colon(:)의 갯수가 인자의 갯수</h3>
<div class="outline-text-3" id="text-1-4">


<p>
   셀렉터 하나당 인자 1개. 2개 이상은 사용을 못한다. 결국 2개 이상의
   인자를 받는 메소드는 여러개의 라벨로 이루어진 selector가 된다. 인자가 없는
   경우는 colon(:)이 없는 selector.
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> @property(애트리뷰트,애트리뷰트&hellip;)</h3>
<div class="outline-text-3" id="text-1-5">


<ul>
<li>atomicity : atomic 또는 nonatomic. 디폴트는 atomic인데, 이
     책에서는 항상 nonatomic을 사용한단다. 왜그런지는 이책의 범위를
     넘는다.

</li>
<li>writability : 티폴트는 readwrite. 종종 readonly

</li>
<li>memory management : 디폴트는 assign. 참조카운트를 다루는 객체에
     대해서 retain 혹은 copy 들 쓰는데, mutable객체에 대해서는 보통
     copy를 사용한다(retain을 쓸 경우, 공유되는 객체의 값이 바뀌면,
     함께 바뀌기 때문이다).
</li>
</ul>


</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> @property로 속성선언, @synthesize로 속성접근함수를 정의한다.</h3>
<div class="outline-text-3" id="text-1-6">


<ul>
<li>@property로 선언한 속성에 상응하는 @synthesize 가 있어도 되고
     없어도 된다. 없는 경우에는 사용자 정의 속성함수가 있어야 된다.

</li>
<li>@property로 선언한 속성값이 @interface {} 안에 선언되어 있지
     않아도 된다.

</li>
<li>@property로 선언한 속성값의 명칭이 @interface {} 안에 선언된 다른
     명칭의 멤버를 가르키도록 할 수 있다. 
     <code>@synthesize myVar = anotherVar</code> 와 같이 하면 된다.

</li>
<li>@synthesize 로 속성을 정의했더라도, 사용자 정의 속성함수를 정의할
     수 있다(사용자 정의 함수가 우선적으로 사용됨).

</li>
<li>@property 없이 @sythesize 만 사용하는 건 안되는 &hellip;
</li>
</ul>


</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> copy 하게 되면 모든 NSMutableXXX 는 immutable객체로 복제된다.</h3>
<div class="outline-text-3" id="text-1-7">


<p>
   NSMutableArray를 copy 하면 NSArray가 생긴다. 그대로 NSMutableArray로
   복제하려면, <b>mutableCopy</b> 를 해야 한다.
</p>
<p>
   *모든 클래스에 mutable 버젼이 있는 건 아니며, copy될 수 없는
    객체형도 있다는 점*을 유의하자.
</p>
</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> autorelease 는 AutoReleasePool(NSAutoRelease객체?!)가 drain될 때 release.</h3>
<div class="outline-text-3" id="text-1-8">


<p>
   release 는 즉시 &ndash;retainCount, autoRelease 는 나중에 &ndash;retainCount;
   ARC를 사용하는 경우에는 autorelease는 compiler가 해준다. 사용할
   필요가 없다.
</p>
</div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> ObjC 의 생성자는 -(void)init.</h3>
<div class="outline-text-3" id="text-1-9">


<p>
   맨 먼저 [super init]. 그런 다음 자기 자신에 대한 초기화. 하지만,
   보통은 designated initializer 를 두고 거기에서만 [super init] 한다.
   ARC 를 사용하는 경우, <code>self = [super init];</code> 이런식으로 self 값에
   super의 init 결과를 대입하여야 한다. 그리고, self 가 null 인지 확인
   한 후 접근해야 한다. 
</p>
</div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> designated initializer.</h3>
<div class="outline-text-3" id="text-1-10">


<p>
   initWithName:withSerialNumber:withBirth 와 같이 멤버같들 전체에
   대한 초기화 방식을 제공하는 편의함수를 두고 이걸 designated
   initializer라고 정해 둔다. 그리고 나머지 init.* 함수들이 이
   designated initializer 를 호출하는 식으로 구현되도록 한다.
   [super init] 은 반드시 이 desginated initializer를 어떤 기본값으로
   호출하도록 구현하는 식으로 한단다.
</p>
</div>

</div>

<div id="outline-container-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> ObjC 의 소멸자는 -(void)dealloc.</h3>
<div class="outline-text-3" id="text-1-11">


<p>
   자기 자신의 멤버들에 대해 release 하는 코드가 보통 들어간다. [super
   dealloc] 은 맨 마지막에!!!! &ndash;&gt; ARC를 사용하는 경우 이 호출은
   compiler error. 호출할 수 가 없다(그에 상응하는 코드를 comiler가 해준다?!)
</p>
</div>

</div>

<div id="outline-container-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> Target-Action vs Delegation</h3>
<div class="outline-text-3" id="text-1-12">


<p>
   Target-Action 은 꼭 Qt 의 signal slot 과 유사해 보인다. Delegation
   은 C++ 의 인터페이스와 유사해 보인다.
</p>
<p>
   Delegation 은 "Protocol" 이라 불리우는 정해진 일련의 메소드
   목록(ObjC 에서는 메시지 목록이 되겠다)을 통지하는 쪽에서
   호출하지만, Target-Action 은 연결된 1쌍의 호출("Target" 으로 하여금
   "Action"을 수행하도록 메시지 전달)함.
</p>
</div>

</div>

<div id="outline-container-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> NSObject 는 protocol로서, 또 class로서 존재한다.</h3>
<div class="outline-text-3" id="text-1-13">


<p>
   ObjC에서는 동일한 이름의 protocol 과 class 모두 존재할 수 있나보다.
   NSObject.h 에는 &hellip; @protocol NSObject 도 있고, @interface
   NSObject&lt;NSObject&gt; 도 있다(즉, NSObject 프로토콜을 confirm하는
   NSObject Class).
</p>
</div>

</div>

<div id="outline-container-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> protocol 의 디폴트는 required. delegate protocol은 대부분 optional</h3>
<div class="outline-text-3" id="text-1-14">


<p>
   @protocol 로 선언된 인터페이스중 delegate 의 역할을 하는 경우는
   보통 @optional 을 사용해서 선언된다. 그런 경우에 구현은
   CLLocationManager 의 예를 들면 다음과 같단다.
</p>
<p>
   아래의 코드는 실제 구현과는 다르지만 개념적인 구현이라 할 수
   있다.
</p>



<pre class="src src-objc">-(<span class="org-type">void</span>)<span class="org-function-name">finishFindingLocation</span>:(<span class="org-type">CLLocation</span>*)<span class="org-variable-name">newLocation</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">locationManager:didUpdateToLocation:fromLocation: &#51060;&#46976; selector &#47484; &#53685;&#54644;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#54644;&#45817; &#47700;&#49884;&#51648;&#47484; &#53945;&#51221; &#44061;&#52404;&#44032; &#48155;&#51012; &#49688; &#51080;&#45716;&#51648; &#54869;&#51064;&#54620;&#45796;.</span>
    <span class="org-type">SEL</span> <span class="org-variable-name">updateMethod</span> = <span class="org-keyword">@selector</span> (locationManager:didUpdateToLocation:fromLocation:);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#47564;&#51068; &#47700;&#49548;&#46300;&#44032; &#44396;&#54788;&#46104;&#50612; &#51080;&#45796;&#47732;, &#47700;&#49884;&#51648;&#47484; &#48372;&#45240;&#45796;.</span>
    <span class="org-keyword">if</span> ([[<span class="org-keyword">self</span> delegate] respondsToSelector:updateMethod]) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#47700;&#49884;&#51648; &#51204;&#49569;</span>
        [[<span class="org-keyword">self</span> delegate] locationManager:<span class="org-keyword">self</span>
                      didUpdateToLocation:newLocation
                            fromLocation:oldLocation];
    }
}
</pre>


</div>

</div>

<div id="outline-container-1-15" class="outline-3">
<h3 id="sec-1-15"><span class="section-number-3">1.15</span> delegate 속성은 (&hellip;,retain)이 아니라 (&hellip;, assign).</h3>
<div class="outline-text-3" id="text-1-15">


<p>
   블라블라 매니저의 delegate속성은 assign. retain으로 하는 경우
   상호retain할 가능성이 생긴다(블라블라 매니저를 생성/소유하는 놈이 보통
   delegate인 경우가 많기때문에.).
</p>
<p>
   책에서는
</p>



<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">CLLocationManager</span>
@property (<span class="org-type">nonatomic</span>, <span class="org-type">assign</span>) <span class="org-type">id</span> <span class="org-variable-name">delegate</span>;
</pre>


<p>
   라는 식으로 선언되었을 거라고 했지만, 찾아보니..
</p>



<pre class="src src-objc">@property(<span class="org-type">assign</span>, <span class="org-type">nonatomic</span>) <span class="org-type">id</span>&lt;<span class="org-type">CLLocationManagerDelegate</span>&gt; <span class="org-variable-name">delegate</span>;
</pre>


<p>
   라는 식으로 되어 있네&hellip;.
</p>
</div>

</div>

<div id="outline-container-1-16" class="outline-3">
<h3 id="sec-1-16"><span class="section-number-3">1.16</span> @sythesize window=_window 의 의미.</h3>
<div class="outline-text-3" id="text-1-16">


<p>
   <a href="http://stackoverflow.com/questions/6130529/ios-xcode-4-properties-access">StackOverflow</a> 에 있는 Q/A 에서 찾은 내용.
</p>
<p>
   Application Delegate class의 *.m 파일에서
</p>
<p>
   @synthesize window=_window
</p>
<p>
   와 같은 부분이 자동으로 들어간 채로 프로젝트가 생성되는데,
</p>
<ul>
<li>Q : 왜 @interface 에 _window 라는 변수가 선언되지 않았는가?
     A : @synthesize window=_window 하면 자동으로 _window 생성된다(?)

</li>
<li>Q : 왜 굳이 @synthesize window=_window 를 쓰나?
     A : ObjC 언어규약상 window 라는 속성의 내부변수(ivar 라고
     한다)는 원래의 속성이름과 동일한 이름의 변수명이 쓰인다(즉,
     "window"). 하지만, 그것 대신 "_window"를 ivar 로 사용하기
     위함이다.

</li>
<li>Q : 그럼 [self window] 와 _window 는 무슨 차이가 있는가?
     A : [self window] 는 getter속성함수로 접근한거고, _window 는
     ivar를 직접 접근한거다.

</li>
<li>Q : 왜 2가지 방법을 쓰게 되나?
     A : dealloc 과 같은 함수에서는 접근메소드를 호출하는 것이
     안전하지 않다고 생각되어지고 있다. 이경우 ivar 를 직접사용하는
     것이 더 선호된다고 한다. 
</li>
</ul>


</div>

</div>

<div id="outline-container-1-17" class="outline-3">
<h3 id="sec-1-17"><span class="section-number-3">1.17</span> XCode 4.2 이상에서는 Window Based Application 이 사라졌다.</h3>
<div class="outline-text-3" id="text-1-17">


<ul>
<li>Empty Application 을 만든다.

</li>
<li>main.m 함수를 다음과 같이 고친다.




<pre class="src src-objc"><span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>* <span class="org-variable-name">argv</span>[])
{
    @autoreleasepool {
        <span class="org-comment-delimiter">// </span><span class="org-comment">return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span>
        <span class="org-keyword">return</span> UIApplicationMain(argc, argv, <span class="org-constant">nil</span>, <span class="org-constant">nil</span>);
    }
}

</pre>


</li>
<li>File &gt; New 에서 Empty User Interface(*.xib) 를 생성하고, 이름을
     MainWindow 이런식으로 짓는다.

</li>
<li>project속성에서 target을 선택한 다음, summary 중 Main Interface를
     MainWindow 로 변경한다.

</li>
<li>AppDelegate 의 window 속성앞에 IBOutlet 을 입력한다.

</li>
<li>MainWindow.xib 파일을 열고 Interface Builder 에서 <a href="http://www.trappers.tk/site/2011/06/16/mainwindow-xib/">여기</a> 의 설명을
     참조하여 설정한다(File's Owner의 class를 UIApplication으로.
     AppDelegate용 Object를 추가. Window를 추가. delegate를
     AppDelegate로 연결. AppDelegate의 window변수를 ui상의 window에
     연결&hellip;)

</li>
<li>라벨같은거 하나를 window에 추가한다음, 실행하여 xib의 화면이 잘
     나오는지 확인.

</li>
<li><b>가급적이면, 여기 있는 설명을 무시하고, UIViewController 를      사용하는 Single View Application 을 사용하도록 한다</b>
</li>
</ul>


</div>

</div>

<div id="outline-container-1-18" class="outline-3">
<h3 id="sec-1-18"><span class="section-number-3">1.18</span> ARC사용시 Rule, the sad(책이 오래된 것만 있다 -_-)but the happy(일이 훨씬 간단한해진다).</h3>
<div class="outline-text-3" id="text-1-18">


<p>  
   ARC 를 사용하게 되면서 새로운 룰이 생겼다.
</p>
<p>
   To work, ARC imposes some new rules that are not present when using
   other compiler modes. The rules are intended to provide a fully
   reliable memory management model; in some cases, they simply
   enforce best practice, in some others they simplify your code or
   are obvious corollaries of your not having to deal with memory
   management. If you violate these rules, you get an immediate
   compile-time error, not a subtle bug that may become apparent at
   runtime.
</p>
<ul>
<li>You cannot explicitly invoke dealloc, or implement or invoke
     retain, release, retainCount, or autorelease. The prohibition
     extends to using @selector(retain), @selector(release), and so
     on.

</li>
<li>You may implement a dealloc method if you need to manage
     resources other than releasing instance variables. You do not
     have to (indeed you cannot) release instance variables, but you
     may need to invoke [systemClassInstance setDelegate:nil] on
     system classes and other code that isn’t compiled using ARC.

</li>
<li>Custom dealloc methods in ARC do not require a call to [super
     dealloc] (it actually results in a compiler error). The chaining
     to super is automated and enforced by the compiler.

</li>
<li>You can still use CFRetain, CFRelease, and other related
     functions with Core Foundation-style objects (see “Managing
     Toll-Free Bridging”).

</li>
<li>You cannot use NSAllocateObject or NSDeallocateObject.

</li>
<li>You create objects using alloc; the runtime takes care of
     deallocating objects.

</li>
<li>You cannot use object pointers in C structures.Rather than using
     a struct, you can create an Objective-C class to manage the data
     instead.

</li>
<li>There is no casual casting between id and void *. 

<p>     
     You must use special casts that tell the compiler about object
     lifetime. You need to do this to cast between Objective-C objects
     and Core Foundation types that you pass as function arguments.
     For more details, see “Managing Toll-Free Bridging.”
</p>
</li>
<li>You cannot use NSAutoreleasePool objects.

<p>
     ARC provides @autoreleasepool blocks instead. These have an
     advantage of being more efficient than NSAutoreleasePool.
</p>
</li>
<li>You cannot use memory zones. There is no need to use NSZone any
     more—they are ignored by the modern Objective-C runtime anyway.
</li>
</ul>


<p>
   To allow interoperation with manual retain-release code, ARC
   imposes a constraint on method naming:
</p>
<ul>
<li>You cannot give an accessor a name that begins with new. This in
     turn means that you can’t, for example, declare a property whose
     name begins with new unless you specify a different getter:
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> IOS.Nerd.Ranch.Guide 제3판</h2>
<div class="outline-text-2" id="text-2">

<p>  4장 위임(Delegation)부터 다시 시작 :(
</p>
</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 4장 위임</h3>
<div class="outline-text-3" id="text-2-1">


</div>

<div id="outline-container-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> 프로젝트를 구성하는 것.</h4>
<div class="outline-text-4" id="text-2-1-1">

<ul>
<li id="sec-2-1-1-1">project<br/>

<p>
     여러 파일들에 대한 목록을 가진 파일 + 여러가지 규칙
</p>
</li>
</ul>
<ul>
<li id="sec-2-1-1-2">files(project구성요소)<br/>

<p>
     소스코드 + 리소스 + 프레임웍 + 라이브러리
</p>
</li>
</ul>
<ul>
<li id="sec-2-1-1-3">target<br/>
     project내의 파일들을 사용해 product를 빌드/실행하기 위한 대상

</li>
</ul>
<ul>
<li id="sec-2-1-1-4">product<br/>

<p>
     target을 빌드하면 나오는 application 또는 library 또는 unit test
     bundle
</p>
</li>
</ul>
<ul>
<li id="sec-2-1-1-5">build phase<br/>

<p>
     target에는 build phase설정이 포함된다. 어떻게 빌드할 것인지에 대한
     설정.
</p>
<ul>
<li>Compile Source
</li>
<li>Link Binary With Libraries
</li>
<li>Copy Bundle Resource
</li>
</ul>


</li>
</ul>
<ul>
<li id="sec-2-1-1-6">framework<br/>

<p>
     target 에 추가할 수 있는 연관된 클래스들의 집합. Cocoa Touch
     같은거. 헤더/링크라이브러리 들을 하나의 단위로 쉽게 target 에
     추가할 수 있게 된다. 
</p>
<ul>
<li>UIKit Framework : iOS 의 UI 라이브러리
</li>
<li>Foundation Framework : NSString, NSArray &hellip;
</li>
<li>CoreGraphics Framework : 그래픽 라이브러리&hellip;.
</li>
<li>CoreLocation Framework : 위치기반 서비스
</li>
</ul>


</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 5장 MapKit 과 Text Input</h3>
<div class="outline-text-3" id="text-2-2">



</div>

<div id="outline-container-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> @protocol 에 대해 추가 학습</h4>
<div class="outline-text-4" id="text-2-2-1">


<ul>
<li>프로토콜은 데이터 멤버는 포함하지 못해도 속성을 포함할 수 있다.

</li>
<li>프로토콜이 어떤 속성을 필수항목으로 지정하게 되면, conforming
    class 는 그 속성값을 @synthesize 하는 방식으로 구현하면 된다.
    단, 상수값을 리턴하는 경우면, 단순히 getter() 함수를 만들고
    상수값을 리턴할 수 도 있다.

</li>
<li>프로토콜이 어떤 속성을 선택항목으로 지정하게 되면, confirming
    class 는 그 속성값을 아예 안써도 된다. @synthesize 하지 않아도
    된다.

</li>
<li>프로토콜이 readonly 로 지정한 속성을 그냥 동일하게
    @property/@synthesize 하게 되면, confirming class 의 메쏘드내에서
    <code>[self setPropertyValue:value]</code> 할 수 없다. 그런 경우에는
    <code>@property (..., readwrite) ...</code> 로 바꾸던지(어쨌든 readwrite 도
    read를 포함하니까), 아니면 confirming class 메쏘드 내에서는
    <code>propertyValue = value</code> 이런식으로 프로퍼티 직접접근을 해야 한다.

</li>
<li>프로토콜이란걸 "계약"으로 생각하면 될 것 같다. 그 계약사항을 지킬
    수 있기만 한다면, 어떻게 구현해도 상관이 없다..는 식으로 설명을
    들었다. 
</li>
</ul>


</div>

</div>

<div id="outline-container-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> UITextField 와 First Responder</h4>
<div class="outline-text-4" id="text-2-2-2">


<ul>
<li>모든 위젯은 UIResponder &gt; UIView &gt; UIControl 이런식으로 상속을
      받는다.

</li>
<li>UITextField 위젯은 UIControl 의 자식클래스

</li>
<li>모든 UIResponder 들은 First Responder 개념이 있단다. 화면에서
      보이는 위젯 들 중 어떤 이벤트를 우선적으로 맨 먼저 받는 놈이
      First Responder

</li>
<li>UITextField 위젯은 독특하게, First Responder가 되면(즉, 사용자가
      이넘을 탭핑하면&hellip;) 화면에 키보드가 표시된다.

</li>
<li>UITextField 의 resignFirstResponder 메시지는 자기 자신이 First
      Responder의 지위를 잃게 만든다 &ndash;&gt; 화면에 표시되던 키보드가
      사라진다.
</li>
</ul>


</div>

</div>

<div id="outline-container-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> ARC 가 있어 메모리 관리가 편해지긴 했지만&hellip;.</h4>
<div class="outline-text-4" id="text-2-2-3">


<ul>
<li>WhereAmI 예제에서 CLLocationManager 객체의 delegate멤버는
      strong도 weak 포인터도 아니다(설명에 따르면 _unsafe_unretained
      라는데 실제 헤더에 가보면 assign-구시대의 유물-으로 되어 있다).
      이건 ARC 가 없던 시절의 것과 동일하단다(하위 호환성). 따라서,
      delegate의 값을 nil 로 설정하지 않으면 절대 delegate가 가리키는
      객체의 retain count가 -1 되지 않으며, 결과적으로는 할당해제되지
      않는다. <b>반드시 dealloc을 재정의 하고, 거기서 [locationManager       setDelegate:nil] 을 해 주어야 한다</b>
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 6장 UIView 와 UIScrollView 상속받기.</h3>
<div class="outline-text-3" id="text-2-3">


<ul>
<li>상속관계 : UIWindow &lt; UIView &lt; UIResponder &lt; NSObject.
</li>
<li>UIWindow 위에 UIView들이 놓이며, UIWindow 역시 UIView로서 모든
     UIView의 최상위 View. Superview-Subview 개념으로
     계층관계존재(좌표계등).
</li>
</ul>



</div>

<div id="outline-container-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> UIView 에 동그라미와 텍스트 그리기</h4>
<div class="outline-text-4" id="text-2-3-1">


<ul>
<li><code>CGContextRef context = UIGraphicsGetCurrentContext();</code> 로 시작
</li>
<li>CGContext 로 시작하는 단어를 iOS 문서에서 찾으면 Draw2D 관련 함수목록을
     얻을 수 있음.
</li>
<li>CGContextAdd{Shape} 식으로 도형을 추가하고, CGContextStrokePath()
     로 선분을 그린다. 한번 그리고 나면 추가된 도형들은 리셋된다(또
     그리려면 다시 Add 해야 한다).
</li>
<li>NSString 은 자기 자신을 CGContext에 draw 할 수 있다.
</li>
<li>NSString 은 자기 자신이 draw될 때 크기가 얼마만한지 알 수 있다. 
</li>
<li>UIColor 는 자기 자신을 CGContext에 fill(브러시 색상), stroke(펜
     색상) 설정할 수 있다.
</li>
<li>하지만 모든 작업을 위와 같이 할 수는 없다. ex:
     CGContextSetShadowWithColor
</li>
</ul>


</div>

</div>

<div id="outline-container-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> UIView의 setNeedsDisplay 메시지(win32의 무효화개념).</h4>
<div class="outline-text-4" id="text-2-3-2">


<p>
    계층관계를 고려하여 CocoaTouch의 run loop 이 화면 갱신을
    최적화한다. run loop 이 한번 돌때마다 아래와 같은 대화가
    오간다. :)
</p>


<pre class="example">"음, 많은 코드들이 막 실행되었군. 혹시 어떤 view가 다시 그려져야할
필요가 있는지 확인해봐야지"
</pre>


<p>
    그려져야 할 필요가 있는 UIView 파생클래스의 객체는
    <code>-(void)drawRect:(CGRect)dirtyRect</code> 메시지를 받는다.
</p>
<p>
    그럼 각 UIView들은
</p>
<p>
    <code>CGContextRef context = UIGraphicsGetCurrentContext();</code>
</p>
<p>
    및
</p>
<p>
    <code>CGRect bounds = [self bounds];</code>
</p>
<p>
    로 코드를 시작한다(그리려는 컨텍스트와 자신의 전체
    사각형크기(사실은 dirtyRect 인자를 쓰는게 더 좋겠지만)가 필요하다.
</p>
</div>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 7장 View Controller</h3>
<div class="outline-text-3" id="text-2-4">


<p>
   여기서는 UIViewController 와 UIView 와의 관계, XIB의 File Owner의
   의미, view가 로딩되는 방법에 대해 배운다.
</p>

</div>

<div id="outline-container-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> UIWindow / UIViewController  생성</h4>
<div class="outline-text-4" id="text-2-4-1">


<p>
  UIResponder&lt;UIApplicationDelegate&gt; 파생클래스 XxxAppDelegate의
   didFinishLaunchingWithOptions 메소드에서
</p>
<ul>
<li>UIWindow 를 화면크기만하게 만든다 &ndash;&gt; self.window 가 된다.
</li>
<li>UIViewController 를 필요한 만큼 만든다
</li>
<li>[옵션] UITabBarController 를 만든다
</li>
<li>UIViewController 중 1개 -&gt; self.rootViewController 가 된다.
</li>
<li>self.window 에 makeKeyAndVisible 메시지 전송하여 띄운다.
</li>
<li>[옵션] 각 UIViewController 의 initWithNibName:bundle: 을
     오버라이딩하고  self.tabBarItem 의 image 와 title을 설정한다.
</li>
</ul>


</div>

</div>

<div id="outline-container-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> 각 UIViewController 들 view 를 생성하는 방법</h4>
<div class="outline-text-4" id="text-2-4-2">


<ul>
<li id="sec-2-4-2-1">manual 생성시<br/>

<ul>
<li>initWithNibName:bundle: 을 오버라이딩한다. 
</li>
<li>UIViewCOntroller 의 <code>-(void)loadView</code> 를 오버라이딩한다
</li>
<li><b>loadView 의 원래 구현은 XIB파일을 사용하는 것이므로 호출하면 안된다.</b>
</li>
<li>직접 view를 alloc / init 하여 만든다.
</li>
</ul>


</li>
</ul>
<ul>
<li id="sec-2-4-2-2">xib 사용시<br/>

<ul>
<li>initWithNibName:bundle: 을 오버라이딩한다.
</li>
<li>IBOutlet 으로 추가한 view 들에 대한 모든 outlet 은 __weak 로
      한다(<b>혹 뷰가 메모리에서 unload되는 현상이 생길때, 이게 strong       이면 절대 subview들이 제거되지 않는다</b>).
      사실 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW6">Apple 문서</a> 에 따르면, IBOutlet 은

<p>      
      <code>@property(weak,...) IBOutlet...</code>
</p>
<p>      
      이런식으로 저장되는게 좋다고 한다. 물론, 이 얘는
      UIViewController 의 view 속성과 같은 topLevel 속성이나, 사용자가
      생성/삭제를 반복하는 view에는 적용X (이것들은 strong이 바람직)
</p></li>
</ul>


</li>
</ul>
</div>

</div>

<div id="outline-container-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> IOS6.0 이후 부터는 메모리 여분이 부족해도 view 를 unload 하지 않는다.</h4>
<div class="outline-text-4" id="text-2-4-3">


<p>
   이전처럼 동작하게 하려면 <code>didReceiveMemoryWarning</code> 을
   오버라이딩해서 이전처럼 동작하는 부분을 구현해야 한단다.
</p>



<pre class="example">Memory Management

Memory is a critical resource in iOS, and view controllers provide
built-in support for reducing their memory footprint at critical
times. The UIViewController class provides some automatic handling
of low-memory conditions through its didReceiveMemoryWarning
method, which releases unneeded memory.

Prior to iOS 6, when a low-memory warning occurred, the
UIViewController class purged its views if it knew it could reload
or recreate them again later. If this happens, it also calls the
viewWillUnload and viewDidUnload methods to give your code a chance
to relinquish ownership of any objects that are associated with
your view hierarchy, including objects loaded from the nib file,
objects created in your viewDidLoad method, and objects created
lazily at runtime and added to the view hierarchy. On iOS 6, views
are never purged and these methods are never called. If your view
controller needs to perform specific tasks when memory is low, it
should override the didReceiveMemoryWarning method.
</pre>


</div>

</div>

<div id="outline-container-2-4-4" class="outline-4">
<h4 id="sec-2-4-4"><span class="section-number-4">2.4.4</span> view 는 화면표시/제거 되는 각 단계별로 통지 메시지가 있다.</h4>
<div class="outline-text-4" id="text-2-4-4">


<p>
   UIViewController 에 특정 메시지가 도착한다.
</p>
<ul>
<li>view 화면표시되기 직전 : viewWillAppear
</li>
<li>view 화면표시직후 : viewDidAppear
</li>
<li>view 화면제거되기 직전 : viewWillDisappear
</li>
<li>view 화면제거직후 : viewDidDisappear
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 8장 Notification 과 Rotation</h3>
<div class="outline-text-3" id="text-2-5">



</div>

<div id="outline-container-2-5-1" class="outline-4">
<h4 id="sec-2-5-1"><span class="section-number-4">2.5.1</span> Notification</h4>
<div class="outline-text-4" id="text-2-5-1">


<p>
    시간이 되면 알람이 표시되고 메시지가 푸시되는 아이폰에서의 시각적 
    통지와는 다른 개념임. 한 코코아 객체가 다른 객체에게 무언가를
    알려주기 위한 매커니즘. 코코아에서는 브로드캐스팅 모델이 사용된다.
    &ndash;&gt; UI의 target-action 이나 delegation과 같이 한
    곳에서 다른곳으로의 메시지 전달을 위한 다자인 패턴에 속한다. 
</p>
<ul>
<li>NSNotificationCenter객체로의 post 는 Win32의 post개념과는 달리
      *동기적*이다.
</li>
<li>NSNotificationQueue를 사용하면 비동기적으로 post할 수 있다.
</li>
</ul>





<pre class="example">anObject(NSObject*)
-- post --&gt;
defaultCenter(NSNotificationCenter*)
-- broadcast -&gt;
여러 NSObject* 객체

post내용(NSNotification*) = name(NSString*)
                         + poster(NSObject*)
                         + userInfo(NSDictionary*))
</pre>


</div>

</div>

<div id="outline-container-2-5-2" class="outline-4">
<h4 id="sec-2-5-2"><span class="section-number-4">2.5.2</span> UIDevice의 Notification</h4>
<div class="outline-text-4" id="text-2-5-2">


<p>
    모든 통지 가능한 클래스들은 각 클래스 문서의 "Notification"
    부분에서 자신의 통지가능한 목록을 찾아볼 수 있다.
</p>
<p>
    또 UIDevice 와 같이 몇몇 클래스들의 통지는 특정 속성의 값 및 특정
    함수의 호출여부에 따라 통지여부가 결정되기도 한다.
</p>
<p>
    예를들어 UIDevice의 아래의 통지를 가지고 있다.
</p>
<ul>
<li>UIDeviceOrientationDidChangeNotification
</li>
<li>UIDeviceBatteryStateDidChangeNotification
</li>
<li>UIDeviceBatteryLevelDidChangeNotification
</li>
<li>UIDeviceProximityStateDidChangeNotification
</li>
</ul>


<p>   
    이 중에서 예를 들어 UIDeviceOrientationDidChangeNotification
    통지는 beginGeneratingDeviceOrientationNotifications 함수가 호출된
    상태에서 통지가 이루어진다.
</p>
<p>
    *주:beginGeneratingDeviceOrientationNotifications 함수는 종종
     endGeneratingDeviceOrientationNotifications 함수와 쌍을 이루어
     호출이 이루어져야 한다.(Nested call도 가능하지만, 항상 쌍을
     이루어 호출이 되어야 한다).
</p>
</div>

</div>

<div id="outline-container-2-5-3" class="outline-4">
<h4 id="sec-2-5-3"><span class="section-number-4">2.5.3</span> @selector 구문</h4>
<div class="outline-text-4" id="text-2-5-3">


<p>
    @selector(colon을 포함한 메소드명) &ndash;&gt; 함수포인터 같은 역할을
    한다. 이름이 완벽히 맞아야 되며, 그렇지 않은 경우 crash 발생한다. 
</p>
<p>
    ex: <code>@selector(didOritientationChange:)</code>
</p>
</div>

</div>

<div id="outline-container-2-5-4" class="outline-4">
<h4 id="sec-2-5-4"><span class="section-number-4">2.5.4</span> Rotation 발생시 view 처리 : 결국 Resizing 처리(가로/세로가 바뀌므로)</h4>
<div class="outline-text-4" id="text-2-5-4">


<p>
    XCode 4.3 이후 부터는 xib 파일의 file inspector 에 autoresizing 이
    디폴트로 변경되었다. 섬세한(?) 처리를 위해 autoresizing 체크박스를
    끄면, size inspector 에서 4각형의 각 edge부분에 대한 strut 과
    가로/세로방향의 resize 여부를 따로 따로 조정이 가능하다.
</p>
<p>
    UIView의 autoresizingMask 속성 값은 bitwise flag로 다음의 설정값
    조합이 가능하다.
</p>



<pre class="src src-objc"><span class="org-keyword">enum</span> {
    <span class="org-variable-name">UIViewAutoresizingNone</span>                 = 0,
    <span class="org-variable-name">UIViewAutoresizingFlexibleLeftMargin</span>   = 1 &lt;&lt; 0,
    <span class="org-variable-name">UIViewAutoresizingFlexibleWidth</span>        = 1 &lt;&lt; 1,
    <span class="org-variable-name">UIViewAutoresizingFlexibleRightMargin</span>  = 1 &lt;&lt; 2,
    <span class="org-variable-name">UIViewAutoresizingFlexibleTopMargin</span>    = 1 &lt;&lt; 3,
    <span class="org-variable-name">UIViewAutoresizingFlexibleHeight</span>       = 1 &lt;&lt; 4,
    <span class="org-variable-name">UIViewAutoresizingFlexibleBottomMargin</span> = 1 &lt;&lt; 5
};
</pre>


<p>    
    실제로 해보면 autoresizing 보다 이런 방식의 조정이 훨씬 더 유연해
    보였던 것 같다.
</p>
</div>

</div>

<div id="outline-container-2-5-5" class="outline-4">
<h4 id="sec-2-5-5"><span class="section-number-4">2.5.5</span> UIViewController 의 willAnimateRotationToInterfaceOrientaion&nbsp;&nbsp;&nbsp;<span class="tag"><span class="duration">duration</span></span></h4>
<div class="outline-text-4" id="text-2-5-5">


<p>
    디바이스가 돌아가면, 이 함수가 호출되면서 view controller 가
    제어하는 view 내의 각 subview들의 움직임을 제어한다. 이걸
    오버라이딩 하면, 디바이스가 돌아간 방향에 따라 전혀 다른 view 를
    표시할 수 있다. (ex:계산기 어플)
</p>
</div>

</div>

<div id="outline-container-2-5-6" class="outline-4">
<h4 id="sec-2-5-6"><span class="section-number-4">2.5.6</span> Proximity : 휴대폰을 얼굴 가까이 갖다 댄 정도에 대한 센서</h4>
<div class="outline-text-4" id="text-2-5-6">

<p>    [[UIDevice currentDevice] setProximityMonitoringEnabled:YES]
    하면 
</p>
</div>
</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 9장 UIITableView 와 UITableViewController</h3>
<div class="outline-text-3" id="text-2-6">



</div>

<div id="outline-container-2-6-1" class="outline-4">
<h4 id="sec-2-6-1"><span class="section-number-4">2.6.1</span> Singleton 구현방법</h4>
<div class="outline-text-4" id="text-2-6-1">


<p>
    모든 alloc 함수(사실 alloc 과 allocWithZone 2개인데 alloc은
    allocWithZone을 호출하는 식으로 구현될 것이므로 실제로는
    allocWithZone함수 1개)를 재정의하여 singleton을 반환하도록 한다.
</p>
</div>

</div>

<div id="outline-container-2-6-2" class="outline-4">
<h4 id="sec-2-6-2"><span class="section-number-4">2.6.2</span> UITableViewController</h4>
<div class="outline-text-4" id="text-2-6-2">


<p>
    UIViewController 로 XIB에 UIView를 만들고 그 안에 UITableView 를
    넣는 식의 작업을 할 때는 쓸 수 없지만, IPhone에 많이 보는
    TableView + Header View 정도의 구성은 할 수 있는 게
    UITableViewController. UITableDataSource도 confirm 하지만, 꼭
    UITableViewController 에 data source를 구현할 필요는 없다. 별도의
    자료구조가 있다면, 그것 자체에 UITableDataSource 를 confirm 하도록
    해 도 되었다.
</p>
</div>
</div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> 10장 UITableView 편집</h3>
<div class="outline-text-3" id="text-2-7">



</div>

<div id="outline-container-2-7-1" class="outline-4">
<h4 id="sec-2-7-1"><span class="section-number-4">2.7.1</span> 노트</h4>
<div class="outline-text-4" id="text-2-7-1">


<ul>
<li>XIB파일은 각 UIViewController 가 자신이 가지고 있는 view 속성을
     top-level view로 하는 UI를 생성하는데 사용된다. view 속성의
     존재상태에 따라 실제 view의 생성/소멸이 결정되므로, strong ref.
     나머지 subview들에 대한 객체변수는 weak(이미 UIView자체에서
     superview-subview 관계로 strong 관계가 맺어져 있다).
</li>
<li>XIB 파일은 view controller가 생성될 때 불러들여져서 view객체들을
     생성하는 게 일반적이지만, XIB파일의 owner로서 임의 시점에
     호출되어 view생성을 시킬 수 도 있다. (여기서는 headerView를
     그렇게 만들었다).

<p>     
     만들때는 [[NSBundle mainBundle] loadNibNamed:@"View명칭"
     owner:self options:nil] 이런식으로 하면, xib파일의 view에 대한
     holder(대개 UIViewController의 view속성이지만, 여기서는
     headerView라는 strong속성)가 지정된 경우, 그 strong
     ref에 대한 view객체가 주욱 생성된다.
</p>
</li>
<li>UITableViewDelegate

<ul>
<li>(UIView*)tableView:viewForHeaderInSection:
</li>
<li>(CGFloat)tableView:heightForHeaderInSection: 
        -&gt; 각 섹션헤더 높이 질의
</li>
<li>(CGFloat)tableView:heightForRowAtIndexPath:  
        -&gt; 각 열의 높이를 질의

</li>
</ul>

</li>
<li>UITableView 의 setEditing:animated 를 호출하면 tableView의
     editing 상태를 제어할 수 있다(각 열의 왼쪽부분에 빨간
     동그라미에 - 표시가 생긴다. Lock표시다. Lock해제하면 항목을 지울
     수 있다).
</li>
</ul>


</div>

</div>

<div id="outline-container-2-7-2" class="outline-4">
<h4 id="sec-2-7-2"><span class="section-number-4">2.7.2</span> 편집모드시 기억사항</h4>
<div class="outline-text-4" id="text-2-7-2">


<p>
    UITableViewDataSource 프로토콜 구현 클래스에
    tableView:commitEditingStyle:forRowAtIndexPath 를 구현할 때, Data
    source가 관리하는 원본 자료구조에 대한 변경을 가한 후 tableView의
    아이템이 삭제되도록 해야 하더라.
</p>



<pre class="src src-objc">-(<span class="org-type">void</span>)   <span class="org-function-name">tableView</span>:(<span class="org-type">UITableView</span> *)<span class="org-variable-name">tableView</span> 
 <span class="org-function-name">commitEditingStyle</span>:(<span class="org-type">UITableViewCellEditingStyle</span>)<span class="org-variable-name">editingStyle</span>
  <span class="org-function-name">forRowAtIndexPath</span>:(<span class="org-type">NSIndexPath</span> *)<span class="org-variable-name">indexPath</span>
{
    NSLog(@<span class="org-string">"commitEditingStyle for row(%d) section(%d)"</span>, [indexPath row], [indexPath section]);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#49325;&#51228;&#46041;&#51089;&#51064; &#44221;&#50864;....</span>
    <span class="org-keyword">if</span> (editingStyle == UITableViewCellEditingStyleDelete) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#50896;&#48376; &#51088;&#47308;&#44396;&#51312; &#48320;&#44221;</span>
        [itemArray removeObjectAtIndex:[indexPath row]];
        <span class="org-comment-delimiter">// </span><span class="org-comment">table view &#50640;&#49436; &#54637;&#47785; &#49325;&#51228;</span>
        [tableView deleteRowsAtIndexPaths:[<span class="org-type">NSArray</span> arrayWithObjects:indexPath,<span class="org-constant">nil</span>] withRowAnimation:<span class="org-constant">YES</span>];
    }
}
</pre>


<p>
    항목 추가도 마찬가지. 다만, 이 장에서는 UITableView 의 초록색 +
    동그라미 버튼을 이용한 것이 아니라서 그런지
    tableView:commitEditingStyle:forRowAtIndexPath 를 통해서 추가되는
    게 아니고, 버튼을 누르면 자료구조에 1개추가 하고 난 다음
    UITableView 에는 insertRowsAtIndexPaths:withRowAnimation: 메시지를
    통해 따로 따로 갱신을 하였다. 
</p>
<p>
    항목이동은 단지 UITableViewDataSource 구현 클래스가
    tableView:moveRowAtIndexPath:toIndexPath 메소드를 구현하기만 하면
    UITableViewCell 에 자동으로 아디다스 3줄짜리 이동 핸들이
    Editing상태에서 표현되고, 그걸로 잡아끌면 이동이 가능해 진다.
</p>
</div>
</div>

</div>

<div id="outline-container-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> 11장 UINavigationController</h3>
<div class="outline-text-3" id="text-2-8">

</div>

</div>

<div id="outline-container-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> 12장 Camera</h3>
<div class="outline-text-3" id="text-2-9">



</div>

<div id="outline-container-2-9-1" class="outline-4">
<h4 id="sec-2-9-1"><span class="section-number-4">2.9.1</span> 인터페이스 빌더에서 target-action pair 을 Ctrl-Drag 하여 생성하기</h4>
<div class="outline-text-4" id="text-2-9-1">


<p>    
    이 장에서는 interface builder 와 assistant editing 을 사용해
    Ctrl-Drag 동작으로 UIView 의 target-action pair 를 쉽게 구성하는
    방법이 나온다.
</p>
<ul>
<li>Command-1 : Project Navigator
</li>
<li>xib 파일 클릭 : Main Edtior 에 파일이 열림
</li>
<li>xib 파일의 owner 파일(동일이름의 *.h 파일)을 Option-클릭 :
      Assistant Editor 에 파일이 열림
</li>
<li>특정 UIView 를 Ctrl-Drag 하여 Assistant Editor의 소스코드 특정
      라인으로 드래그하여 Action 생성
</li>
</ul>


</div>

</div>

<div id="outline-container-2-9-2" class="outline-4">
<h4 id="sec-2-9-2"><span class="section-number-4">2.9.2</span> UIImageView</h4>
<div class="outline-text-4" id="text-2-9-2">

<p>     UIImageView는 사진을 표시하는 view. 
</p>
</div>

</div>

<div id="outline-container-2-9-3" class="outline-4">
<h4 id="sec-2-9-3"><span class="section-number-4">2.9.3</span> UIToolbar</h4>
<div class="outline-text-4" id="text-2-9-3">

<p>    UINavigationBar 와 상당히 유사하지만, UIToobar는 버튼 2개가 아니라
    배열로 여럿을 가질 수 있음. 버튼은 UIBarButtonItem. IB 에서
    Identifier 를 Camera 를 선택하면, 아이콘 모양이 늘 보던 그 카메라
    모양이 뜨더라.
</p>
</div>

</div>

<div id="outline-container-2-9-4" class="outline-4">
<h4 id="sec-2-9-4"><span class="section-number-4">2.9.4</span> UIImagePickerController - UIImagePickerControllerDelegate</h4>
<div class="outline-text-4" id="text-2-9-4">

<p>    UIImagePickerController 은 카메라를 촬영하여 혹은 찍은 사진으로 부터 이미지를 가져올 수 있게
    하는 controller.
</p>
<ul>
<li>SourceType : Camera, PhotoLibrary, SavedPhotosAlbum 의 3가지(ex:
      UIImagePickerControllSourceTypeCamera)
</li>
<li>isSourceTypeAvailable 메소드로 Camera 지원여부 확인가능
</li>
</ul>


<p>
    UIImagePickerControllerDelegate 는 Controller 로 부터 통지를 받는다.
</p>
<ul>
<li><code>imagePickerController:didFinishPickingMediaWithInfo:</code> :
      이미지가 촬영되거나 선택되었을 때 호출됨. 

</li>
<li><b>delegate</b> 는 id&lt;UIImagePickerControllerDelgate&gt; 이기만 하면
      되는게 아니라 <b>id&lt;UINavigationControllerDelegate,       UIImagePickerControllerDelegate&gt;</b>  여야 하는 이유.

<p>      
      &ndash;&gt; UIImagePickerController 는 UINavigationController 의
      파생클래스이기 때문에, 그렇다는군. 실제로
      "UIImagePickerController.h" 파일을 열어보면 delegate의 형이
      다음과 같이 선언되어 있음.
</p>



<pre class="src src-objc">@property(<span class="org-type">nonatomic</span>,<span class="org-type">assign</span>) <span class="org-type">id</span> &lt;<span class="org-type">UINavigationControllerDelegate</span>, <span class="org-type">UIImagePickerControllerDelegate</span>&gt; <span class="org-variable-name">delegate</span>;
</pre>

</li>
</ul>


</div>

</div>

<div id="outline-container-2-9-5" class="outline-4">
<h4 id="sec-2-9-5"><span class="section-number-4">2.9.5</span> UIView 의 presentVieController:animated:completion 메소드</h4>
<div class="outline-text-4" id="text-2-9-5">


<p>
    (이 부분 설명은 XCode문서 "Presenting View Controllers from Other
    View Controllers" 를 보고 정리한것)
</p>
<p>
    하나의 view controller 는 다른 view controller 를 이어서 'present'
    즉 화면에 표시할 수 있다. 이는 마치 부모 윈도우가 자식 윈도우를
    팝업시키는 것하고 비슷하다.
</p>
<p>
    그 어떤 view controller 라도 한번에 하나의 view controller 를
    present 할 수 있다. 그럼 새로 presented 된 view controller 는
    사용자 입장에서는 맨 위에 놓인 view controller 가 된다. 
</p>
<p>
    또한 Presenting View 와 Presented View 가 서로에 대한 관계를 포인터로
    가지고 있고, modality 의 종류도 FullScreen, PageSheet, FormSheet
    의 몇가지가 있다. (IPad에서는 다 쓰이지만, IPhone 에서는 주로
    FullScreen 이 쓰인다).
</p>
<p>
    어떤 view controller 를 present 하려면 다음 순서로 한다.
</p>
<ol>
<li>어떤 view controller 'B' 에서 다음을 수행하게 된다.
</li>
<li>present 하려는 view controller 'A' (="presented view
       controller") 를 생성한다.
</li>
<li>'A' 의 modalTransitionStyle 속성을 설정한다.
</li>
<li>'A' 의 delegate 를 지정한다. 대개는 'B' 가 delegate가 된다.
</li>
<li>'B' 의 메소드에서 'B'의
       presentViewController:animated:completion: 메소드를 호출하되,
       생성되어 있는 'A' 객체를 넘겨준다.
</li>
</ol>


<p>       
   예는 다음과 같다.
</p>



<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">&#51060;&#48120;&#51648; &#49444;&#51221;&#54616;&#44592; &#48260;&#53948;&#51012; &#45572;&#47476;&#47732; &#54840;&#52636;&#46104;&#45716; action</span>
-(<span class="org-type">IBAction</span>) <span class="org-function-name">takePicture</span>:(<span class="org-type">id</span>)<span class="org-variable-name">sender</span>
{
    <span class="org-type">UIImagePickerController</span> *<span class="org-variable-name">imagePicker</span> = [[<span class="org-type">UIImagePickerController</span> alloc] init];
    [imagePicker setDelegate:<span class="org-keyword">self</span>];
    [<span class="org-keyword">self</span> presentViewController:imagePicker animated:<span class="org-constant">YES</span> completion:<span class="org-constant">nil</span>];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#45208;&#51473;&#50640; &#45796;&#47480; &#54632;&#49688;&#50640;&#49436;, &#50948;&#50640;&#49436; presented &#46108; view controller &#47484;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">dismiss &#49884;&#53416;&#45796;.</span>
-(<span class="org-type">void</span>)  <span class="org-function-name">imagePickerController</span>:(<span class="org-type">UIImagePickerController</span> *)<span class="org-variable-name">picker</span>
 <span class="org-function-name">didFinishPickingMediaWithInfo</span>:(<span class="org-type">NSDictionary</span> *)<span class="org-variable-name">info</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">.... &#44592;&#53440; &#51089;&#50629;</span>

    [<span class="org-keyword">self</span> dismissViewControllerAnimated:<span class="org-constant">YES</span> completion:<span class="org-constant">nil</span>];
}
</pre>


<p>       
   Qt 에서 표준대화상자를 구비하고 있는 것 과 마찬가지로, iOS 에서는
   표준 view controller 를 구비하고 있으며, 이걸 써서 표준이 되는 view
   를 화면에 표시할 수 있다.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Framework</th><th scope="col" class="left">View controllers</th><th scope="col" class="left">설명</th></tr>
</thead>
<tbody>
<tr><td class="left">Address Book UI</td><td class="left">ABNewPersonViewController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">ABPeoplePickerNavigationController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">ABPersonViewController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">ABUnknownPersonViewController</td><td class="left"></td></tr>
</tbody>
<tbody>
<tr><td class="left">Event Kit UI</td><td class="left">EKEventEditViewController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">EKEventViewController</td><td class="left"></td></tr>
</tbody>
<tbody>
<tr><td class="left">Game Kit</td><td class="left">GKAchievementViewController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">GKLeaderboardViewController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">GKMatchmakerViewController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">GKPeerPickerController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">GKTurnBasedMatchmakerViewController</td><td class="left"></td></tr>
</tbody>
<tbody>
<tr><td class="left">Message UI</td><td class="left">MFMailComposeViewController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">MFMessageComposeViewController</td><td class="left"></td></tr>
</tbody>
<tbody>
<tr><td class="left">Media Player</td><td class="left">MPMediaPickerController</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">MPMoviePlayerViewController</td><td class="left"></td></tr>
<tr><td class="left">UIKit</td><td class="left">UIImagePickerController(이장에서 쓴거)</td><td class="left">카메라</td></tr>
<tr><td class="left"></td><td class="left">UIVideoEditorController</td><td class="left">비디오</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2-9-6" class="outline-4">
<h4 id="sec-2-9-6"><span class="section-number-4">2.9.6</span> UIView 의 endEditing 메소드 &ndash;&gt; "키보드 화면에서 없애기".</h4>
<div class="outline-text-4" id="text-2-9-6">

<p>    IB 에서 제일 상위의 View 를 UIControl 로 변경한다음, 이 UIControl에
    대한 Touch up 이벤트 핸들러를 owner view controller 에 만든다.
    거기서 단순히 아래와 같이 <code>endEditing:YES</code> 만 호출하면 화면상의
    first responder 가 자기 자신으로 바뀌면서 키보드가 사라진다.
</p>



<pre class="src src-objc">- (<span class="org-type">IBAction</span>)<span class="org-function-name">backgroundTabbed</span>:(<span class="org-type">id</span>)<span class="org-variable-name">sender</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#49324;&#49892; sender &#44032; [self view]</span>
    [[<span class="org-keyword">self</span> view] endEditing:<span class="org-constant">YES</span>];
}
</pre>


</div>

</div>

<div id="outline-container-2-9-7" class="outline-4">
<h4 id="sec-2-9-7"><span class="section-number-4">2.9.7</span> NSDictionary</h4>
<div class="outline-text-4" id="text-2-9-7">


<p>
    다른 언어와 마찬가지로 여기 dictionary타입인 NSDictionary 역시
    key-value pair를 저장.
</p>



<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">"MyKey" &#46972;&#45716; &#47928;&#51088;&#50676; &#53412; &#44050;&#50640; &#45824;&#54620; &#44050;&#51004;&#47196; someObject &#44061;&#52404;&#47484; &#51648;&#51221;</span>
[someDictionary setObject:someObject forKey:@<span class="org-string">"MyKey"</span>];
<span class="org-comment-delimiter">// </span><span class="org-comment">"MyKey" &#46976; &#53412;&#50640; &#54644;&#45817;&#54616;&#45716; &#44050;(&#44061;&#52404;)&#51012; &#50619;&#51020;</span>
<span class="org-type">id</span> <span class="org-variable-name">myObject</span> = [someDictionary objectForKey:@<span class="org-string">"MyKey"</span>];
</pre>


</div>

</div>

<div id="outline-container-2-9-8" class="outline-4">
<h4 id="sec-2-9-8"><span class="section-number-4">2.9.8</span> CoreFoundation 과 Toll-free bridge. 그리고 메모리 관리(CFRelease)</h4>
<div class="outline-text-4" id="text-2-9-8">


<p>
    CoreFoundation 은 CF 로 시작하는 함수들과 CF*Ref 형식의 opaque
    pointer 로 구성되어 있는 C 형식의 객체지향 프레임웍. CF*Create()
    함수로 CF*Ref 객체를 만들고, 파괴할 때는 CF*Release() 로 한다.
</p>
<p>
    CF*Ref 형식의 객체는 그에 상응하는 ObjC 타입이 있으며, 그 둘
    간에는 메모리내에서의 레이아웃이 일치하도록 되어 있다. 따라서 이
    두가지 타입간에는 형변환이 가능하다. 이를 toll free bridge 라고
    한단다.
</p>
<p>
    ARC를 사용하는 ObjC 컴파일러에게 형변환된 객체에 대하여 retain
    처리를 하지 않도록 알려주기 위해 toll-free bridge 시 <b>__bridge</b>
    라는 지시어를 써준다. 
</p>



<pre class="src src-objc"><span class="org-type">CFUUIDRef</span> <span class="org-variable-name">uuid</span> = CFUUIDCreate(kCFAllocatorDefault);
<span class="org-type">CFStringRef</span> <span class="org-variable-name">uuidString</span> = CFUUIDCreateString(kCFAllocatorDefault, uuid);

<span class="org-comment-delimiter">// </span><span class="org-comment">Toll-free bride</span>
<span class="org-type">NSString</span> *<span class="org-variable-name">key</span> = (__bridge <span class="org-type">NSString</span> *)uuid;

<span class="org-comment-delimiter">// </span><span class="org-comment">key &#47484; &#49324;&#50857;</span>

<span class="org-type">CFRelease</span>(<span class="org-variable-name">uuid</span>);
<span class="org-type">CFRelease</span>(<span class="org-variable-name">uuidString</span>);
</pre>


</div>
</div>

</div>

<div id="outline-container-2-10" class="outline-3">
<h3 id="sec-2-10"><span class="section-number-3">2.10</span> 13장 UIPopoverController 와 Modal View Controller들</h3>
<div class="outline-text-3" id="text-2-10">

<p>   이 chapter 부터 iPad 에 대한 내용이 시작됨.
</p>
</div>

<div id="outline-container-2-10-1" class="outline-4">
<h4 id="sec-2-10-1"><span class="section-number-4">2.10.1</span> 유니버설 바이너리</h4>
<div class="outline-text-4" id="text-2-10-1">

<p>    프로젝트 설정에서 iPhone 으로 되어 있던 Device를 Universal 로
    바꾸고 Run/Stop버튼 옆의 Scheme에서 iPad 를 선택하면 됨.
</p>
</div>

</div>

<div id="outline-container-2-10-2" class="outline-4">
<h4 id="sec-2-10-2"><span class="section-number-4">2.10.2</span> 유니버설화(Universalizing)</h4>
<div class="outline-text-4" id="text-2-10-2">


<ul>
<li>기존 XIB 파일뒤에 ~ipad 이름을 붙인 상태로 하나 복제한다.
</li>
<li>UIViewController 가 초기화될 때 지정된 nibName 에 nil 을
      전달했다면, 생성될 때 기기 상태에 따라 서로 다른 xib 파일을 찾아
      로딩하고 객체생성을 하게된다.
</li>
</ul>


</div>

</div>

<div id="outline-container-2-10-3" class="outline-4">
<h4 id="sec-2-10-3"><span class="section-number-4">2.10.3</span> 기기 상태 코드로 확인하기 : UIDevice 의 userInterfaceIdiom 속성&ndash;</h4>
<div class="outline-text-4" id="text-2-10-3">

<p>    보통 UIViewControllerDelegate 의 viewDidLoad 함수에서 아래와 같이
    수행
</p>



<pre class="src src-objc">-(<span class="org-type">void</span>) <span class="org-function-name">viewDidLoad</span>
{
    [<span class="org-keyword">super</span> viewDidLoad];

    <span class="org-type">UIUserInterfaceIdiom</span> <span class="org-variable-name">idom</span> =
        [[<span class="org-type">UIDevice</span> currentDevice] userInterfaceIdiom];
    <span class="org-keyword">switch</span> (idiom)
    {
    <span class="org-keyword">case</span> UIUserInterfaceIdiomPhone:
        <span class="org-comment-delimiter">// </span><span class="org-comment">iphone&#51060;&#45348;.</span>
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> UIUserInterfaceIdiomPad:
        <span class="org-comment-delimiter">// </span><span class="org-comment">ipad &#44396;&#45208;!</span>
        <span class="org-keyword">break</span>;
    }
}
</pre>


</div>

</div>

<div id="outline-container-2-10-4" class="outline-4">
<h4 id="sec-2-10-4"><span class="section-number-4">2.10.4</span> 기기별로 다른 처리 하는 예</h4>
<div class="outline-text-4" id="text-2-10-4">


<ul>
<li>backgroundColor 색상 상수값 차이 : 희한하게도 UIView 의
      backgroundColor 상수값 중 groupTableViewBackgroundColor 와 같은
      색상은 IPhone 에만 있단다. 이런 색상은 UIViewController의
      viewDidLoad 같은 콜백함수에서 설정하게 되는데 이때도 기기별로
      다른 처리를 해야 할 것.

</li>
<li>UIViewController 의 (BOOL)shouldAutororateToInterfaceOrientaion:
      메소드 : 이 콜백함수에서 YES 를 반환하면 UI 가 자동으로
      돌아가는데, IPad 는 모든 방향에서 사용이 가능하도록 하는게
      일반적이지만, IPhone 은 그렇지 않다.
</li>
</ul>


</div>

</div>

<div id="outline-container-2-10-5" class="outline-4">
<h4 id="sec-2-10-5"><span class="section-number-4">2.10.5</span> UIPopoverController : IPad 전용 뷰 컨트롤러.</h4>
<div class="outline-text-4" id="text-2-10-5">


<ul>
<li>생성 방법 : Popover view 안에 넣을 다른 view ("content view")
      의 view controller 객체로 초기화함.

</li>
<li>1단계 : content view controller 생성 및 delegate지정
</li>
<li>2단계 : UIPopoverController 생성 및 delegate지정
</li>
<li>3단계 : UIPopoverController 의 presentPopoverFromXXXX 함수 호출.
      XXX 에는 2가지. 

<ol>
<li>UIToolbar의 UIBarButtonItem 이 눌렸을때 present
</li>
<li>CGRect 영역을 직접 지정하는 present.

</li>
</ol>

<p>      실제 예는 아래와 같다(UIToolbar 의 버튼을 눌렀을 때, 해당 버튼에
      대한 말풍선 형태로 popover view가 표시된다).
</p>



<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">UIToolbar &#51032; BarButtonItem &#51060; &#45580;&#47160;&#51012; &#46412;&#51032; &#54648;&#46308;&#47084;.</span>
-(<span class="org-type">IBAction</span>)<span class="org-function-name">showImagePicker</span>:(<span class="org-type">id</span>)<span class="org-variable-name">sender</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">content view controller &#49373;&#49457;(&#48143; delegate&#49444;&#51221;)</span>
    <span class="org-type">UIImagePickerController</span> *<span class="org-variable-name">imagePicker</span>
        = [[<span class="org-type">UIImagePickerController</span> alloc] init];
    [imagePicker setDelegate:<span class="org-keyword">self</span>];

    <span class="org-keyword">if</span> (usingPopOverView)  {
        <span class="org-comment-delimiter">// </span><span class="org-comment">popover view controller &#49373;&#49457;(&#48143; delegate&#49444;&#51221;)</span>
        <span class="org-type">UIPopoverController</span> *<span class="org-variable-name">imagePickerPopover</span>
            = [[<span class="org-type">UIPopoverController</span> alloc] initWithContentViewController:imagePicker];
        [iamgePickerPopover setDelegate:<span class="org-keyword">self</span>];

        <span class="org-comment-delimiter">// </span><span class="org-comment">popover view &#54364;&#49884;</span>
        [imagePickerPopover presentPopoverFromBarButtonItem:sender
                                   permittedArrowDirections:UIPopoverArrowDirectionAny
                                                   animated:<span class="org-constant">YES</span>];
    } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">full screen modal view</span>
        [<span class="org-keyword">self</span> presentViewController:imagePicker
                           animated:<span class="org-constant">YES</span>
                         completion:<span class="org-constant">nil</span>];
    }
}

-(<span class="org-type">void</span>)<span class="org-function-name">popoverControllerDidDismissPopover</span>:(<span class="org-type">UIPopoverController</span> *)<span class="org-variable-name">popoverController</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#49324;&#50857;&#51088;&#44032; pop over view &#47484; &#45803;&#51008; &#44221;&#50864;&#50640; &#50668;&#44592;&#47196; &#46308;&#50612;&#50740;.</span>

    <span class="org-keyword">self</span>.imagePickerPopover = <span class="org-constant">nil</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#47716;&#48260;&#48320;&#49688;&#51032; reference count&#47484; -1 &#54632;.</span>
}

</pre>

</li>
</ul>


</div>

</div>

<div id="outline-container-2-10-6" class="outline-4">
<h4 id="sec-2-10-6"><span class="section-number-4">2.10.6</span> View Controller 간의 관계 : Parent/Child 그리고 Presenting/Presenter</h4>
<div class="outline-text-4" id="text-2-10-6">

<ul>
<li id="sec-2-10-6-1">View Controller Container<br/>
    UIViewController 들 중 다른 UIViewController 를 담을 수 있는 view
    controller container 가 존재한다.

<ul>
<li>UINavigationController : Back 버튼이 나오는&hellip;
</li>
<li>UITabBarController : 전화어플에서 맨 밑의 즐겨찾기/최근통화/연락처&hellip;
</li>
<li>UISplitViewController : IPad 에서만 볼 수 있는 splitter view :(
</li>
</ul>


<p>   
   얘들은 모두 <i>viewControllers</i> 라는 NSArray 객체를 가지며, 이 속성에
   자신이 담고 있는 view controller 들을 관리(?)한다. 관리되는 놈들과
   관리하는 놈사이에는 Parent/Child 관계가 성립한다.
</p>
<p>
   UIViewController 는
</p>
<ul>
<li>(UIViewController*) <i>parentViewController</i> 속성 : 부모 view controller 포인터
</li>
</ul>


<p>      
   View controller container 는
</p>
<ul>
<li>(NSArray*) <i>viewControllers</i> 속성 : 자식 view controller 객체목록
</li>
</ul>



</li>
</ul>
<ul>
<li id="sec-2-10-6-2">View Controller Family<br/>
     어떤 UIViewController 에서도 자신의 부모쪽으로 존재할 가능성이
     있는 view controller container에 대한 포인터 속성이 존재한다.

<ul>
<li><i>navigationController</i> 속성
</li>
<li><i>tabBarController</i> 속성
</li>
<li><i>splitViewController</i> 속성
</li>
</ul>


<p>
     이 속성값은 자신의 <i>parentViewController</i> 의 연결고리를 주욱
     따라가다가 해당하는 type 의 view controller 를 만나면 그 놈의
     객체를 반환한다. 만일 그런게 없으면, nil반환.
</p>
<p>
     동일한 view controller container 를 이들 3개중 하나의 값으로
     반환받는 놈들을 묶으면 Family 가 된다.
</p>
</li>
</ul>
<ul>
<li id="sec-2-10-6-3">Presenting-Presenter 관계<br/>

<p>
     View controller 가 modally 하게 present 되면 presenting-presenter
     관계가 성립된다.
</p>
<p>
     <b>Modally 하게 Present 된다?</b> &ndash;&gt; 어떤 View Controller 의 <i>view</i> 가
     다른 View controller 의 <i>view</i> <b>위에</b> 추가되면 그걸 modally
     presented 되었다고 한단다.
</p>
<p>
     <b>그 어떤 View Controller 라도 다른 View Controller 를 modally      present 할 수 있다</b>
</p>
<p>
     그 결과 상호간에 pointer/back-pointer 가 이 2 view controller에
     존재하는데&hellip;
</p>
<ul>
<li><i>presentedVeiwController</i> 속성 : present하는 놈이 자신이
       present한 view controller 객체에 대한 포인터를 가진다.
</li>
<li><i>presentingViewController</i> 속성 : present 당하는 놈이 자신을
       present 한 view controller 객체에 대한 포인터를 가진다. 단,
       어떤 UIViewController 가 위 3종 부모 view controller 중
       하나라도 가지면 그놈이 presentingViewController가 된다. 
</li>
</ul>


<p>       
     Presenting-Presenter 관계는
     presnetViewController:animated:completion: 을 누가 호출했는지가
     아니라, view controller container 관계에 따라 최종 결정된다. 
</p>
<p>
     <b>주의</b> 여기 설명은 원래 책의 그림 13.8 을 보고 정확히 이해해야
      한다. 여기의 설명은 그림 없이 하려니 조금 잘못이해될 수 있는
      부분이 있다. 
</p>
</li>
</ul>
<ul>
<li id="sec-2-10-6-4">Family 간 관계(Presenting-Presenter관계에서)<br/>

<p>
     Presented view controller 는 자신의 presenter 와 반드시 동일한
     family 에 있어야 할 필요가 없음.
</p>
<p>
     각 UIViewController 가 자신의 <i>view</i> 가 어느 View Controller 의
     view 위에 올라가느냐에 따라 관계가 정해진다. 그리고, 거기에 따라
     화면상의 실제 표시도 달라진다.
</p>
<p>
     디폴트의 동작을 바꾸고, 중간에 자신만의 frame 을 가지는 view 를
     만들려면, <i>definesPresentationContext</i> 속성을 YES 로 하면 된다.
     (기본값은 NO 이다). 그러면, 최상위 계층의 3종 view controller
     container 가 아니라 이 YES로 설정된 view controller 가
     presenter가 된다.
</p>
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2-11" class="outline-3">
<h3 id="sec-2-11"><span class="section-number-3">2.11</span> 14장 Saving, Loading 및 Application States</h3>
<div class="outline-text-3" id="text-2-11">


</div>

<div id="outline-container-2-11-1" class="outline-4">
<h4 id="sec-2-11-1"><span class="section-number-4">2.11.1</span> 어플의 세션간 데이터 유지</h4>
<div class="outline-text-4" id="text-2-11-1">

<p>    파일 시스템에 객체를 Archiving함으로써 가능.
</p></div>

</div>

<div id="outline-container-2-11-2" class="outline-4">
<h4 id="sec-2-11-2"><span class="section-number-4">2.11.2</span> NSCoding protocol</h4>
<div class="outline-text-4" id="text-2-11-2">

<p>    어떤 객체를 파일시스템등에 저장하기 위한 프로토콜. 딱 2개의 필수
    메소드가 존재한다.
</p>


<pre class="src src-objc"><span class="org-keyword">@protocol</span> <span class="org-type">NSCoding</span>
-(<span class="org-type">void</span>)<span class="org-function-name">encodeWithCoder</span>:(<span class="org-type">NSCoder</span> *)<span class="org-variable-name">aCoder</span>;
-(<span class="org-type">id</span>)<span class="org-function-name">initWithCoder</span>:(<span class="org-type">NSCoder</span> *)<span class="org-variable-name">aDecoder</span>;
<span class="org-keyword">@end</span>
</pre>

<p>
    NSCoder 는 NSCoding을 confirm 하는 클래스의 객체들을
    저장/불러오기를 할 수 있는 놈이다.
    <code>encodeWithCoder:</code> 를 호출하면 aCoder 를 통해 각 멤버를
    key/value쌍으로 저장한다. 그럼 저장시에 각 멤버 클래스의
    <code>encodeWithCoder:</code> 가 호출된다&hellip;. 재귀적인 느낌으로 저장이
    진행된다.
    불러오기는 <code>initWithCoder:</code> 를 호출하여 aDecoder 를 통해 각 맴버를
    생성한다. 
</p>


<pre class="src src-objc"><span class="org-keyword">@interface</span> <span class="org-type">BNRItem</span> : <span class="org-type">NSObject</span>&lt;<span class="org-type">NSCoding</span>&gt;

-(<span class="org-type">id</span>)<span class="org-function-name">initWithCoder</span>:(<span class="org-type">NSCoder</span> *)<span class="org-variable-name">aDecoder</span>
{
    <span class="org-keyword">self</span> = [<span class="org-keyword">super</span> init];
    <span class="org-keyword">if</span> (<span class="org-keyword">self</span>) {
        [<span class="org-keyword">self</span> setItemName:[aDecoder decodeObjectForKey:@<span class="org-string">"itemName"</span>]];
        <span class="org-comment-delimiter">// </span><span class="org-comment">--&gt; NSString &#44061;&#52404;&#47484; alloc</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">--&gt; NSString &#51032; initWithCoder &#47484; &#54840;&#52636;&#54620;&#45796;.</span>
        [<span class="org-keyword">self</span> setValueInDollars:[aDecoder decodeIntForKey:@<span class="org-string">"valueInDollars"</span>]];
        <span class="org-comment-delimiter">// </span><span class="org-comment">--&gt; &#44061;&#52404;&#44032; &#50500;&#45772; &#44221;&#50864; decodeIntForKey, decodeBlaBlaTypeForKey &#47484; &#54840;&#52636;</span>
    }
    <span class="org-keyword">return</span> <span class="org-keyword">self</span>;
}

-(<span class="org-type">void</span>)<span class="org-function-name">encodeWithCoder</span>:(<span class="org-type">NSCoder</span> *)<span class="org-variable-name">aCoder</span>
{
    [aCoder encodeObject:itemName forKey:@<span class="org-string">"itemName"</span>];
    <span class="org-comment-delimiter">// </span><span class="org-comment">--&gt; NSString&#44061;&#52404; 'itemName'&#51060; "itemName" key&#51032; &#44050;&#51004;&#47196; &#51200;&#51109;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">--&gt; NSString &#51060; &#44396;&#54788;&#54616;&#45716; encodeWithCoder: &#44032; &#54840;&#52636;&#46108;&#45796;.</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>

    [aCoder encodeInt:valueInDollars forKey:@<span class="org-string">"valueInDollars"</span>];
    <span class="org-comment-delimiter">// </span><span class="org-comment">--&gt; &#44061;&#52404;&#44032; &#50500;&#45772;&#44221;&#50864; encodeInt, encodeBlaBlaType &#51012; &#54840;&#52636;</span>
}
<span class="org-keyword">@end</span>
</pre>


<p>
    XCode 문서를 보면 iOS 6.0 부터 NSSecureCoding 이 추가되었고,
    NSString, NSDate 같은 자료형들이 NSCoding &gt; NSSecureCoding &gt;
    NSString 이런 식으로 상속을 받는다. 그 이유는 <code>decodeObjectForKey:</code> 에
    있다. 이 메소드는 일단 해당 클래스를 어떤식으로든 만들어 id 형으로
    반환하는데 문제는 원래의 저장된 타입인지 어쩐지를 확인하는 식으로
    구현되는 경우가 많이 있었다(그 과정에서 object subst attack을
    당한단다). &ndash;&gt; <code>decodeObjectOfClass:forKey:</code> 메소드를 대신
    사용하도록 유도하고 있다.
</p>



<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">iOS 6.0 &#51060;&#51204; &#48169;&#49885;(NSCoding)</span>
<span class="org-type">id</span> <span class="org-variable-name">obj</span> = [aDecoder decodeObjectForKey:@<span class="org-string">"myKey"</span>];
<span class="org-keyword">if</span> (<span class="org-negation-char">!</span>[obj isKindOfClass:[<span class="org-type">MyClass</span> class]]) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">fail...</span>
}

<span class="org-comment-delimiter">// </span><span class="org-comment">iOS 6.0 &#51060;&#54980; &#48169;&#49885;(NSSecureCoding)</span>
<span class="org-type">id</span> <span class="org-variable-name">obj</span> = [aDecoder decodeObjectOfClass:[<span class="org-type">MyClass</span> class] forKey:@<span class="org-string">"myKey"</span>];
</pre>



</div>

</div>

<div id="outline-container-2-11-3" class="outline-4">
<h4 id="sec-2-11-3"><span class="section-number-4">2.11.3</span> Application Sandbox</h4>
<div class="outline-text-4" id="text-2-11-3">

<p>    iOS 는 모든 어플이 Application Sandbox 를 가진다. 이것은
    파일시스템상의 디렉토리로서 나머지 파일 시스템으로 부터 완전히
    격리된 공간이다. 단 1개의 어플만이 접근 가능하고 다른 어플들로
    부터는 접근이 불가능한 파일시스템인 셈이다.
    여기에는 다음과 같은 디렉토리가 있다.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">디렉토리 명</th><th scope="col" class="left">사용 용도</th><th scope="col" class="left">iTunes/iCloud저장여부</th></tr>
</thead>
<tbody>
<tr><td class="left">Library/Preferences/</td><td class="left">어플 설정이 저장된다.</td><td class="left">저장 됨</td></tr>
<tr><td class="left"></td><td class="left">NSUserDefaults 클래스로</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">자동처리된다(?)</td><td class="left"></td></tr>
</tbody>
<tbody>
<tr><td class="left">tmp/</td><td class="left">어플 실행시 임시파일</td><td class="left">저장 안됨</td></tr>
<tr><td class="left"></td><td class="left">NSTemporaryDirection</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">함수로 쉽게 얻음.</td><td class="left"></td></tr>
</tbody>
<tbody>
<tr><td class="left">Documents/</td><td class="left">어플 실행시 세션간</td><td class="left">저장 됨</td></tr>
<tr><td class="left"></td><td class="left">상태유지를 위한 파일</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">저장 공간</td><td class="left"></td></tr>
</tbody>
<tbody>
<tr><td class="left">Library/Caches</td><td class="left">Documents 와 유사한</td><td class="left">저장 안됨</td></tr>
<tr><td class="left"></td><td class="left">용도이지만, Cache따위만</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">저장(실제는 원격서버</td><td class="left"></td></tr>
<tr><td class="left"></td><td class="left">에 저장될 데이터 등)</td><td class="left"></td></tr>
</tbody>
</table>

</div>

</div>

<div id="outline-container-2-11-4" class="outline-4">
<h4 id="sec-2-11-4"><span class="section-number-4">2.11.4</span> 파일경로 생성방법</h4>
<div class="outline-text-4" id="text-2-11-4">

<p>    XCode 문서에서는 권장하는 방법은 아니나
    <code>NSSearchPathForDirectoriesInDomain()</code> 함수를 사용하여 특정
    영역관련된 디렉토리들의 목록을 얻어온 다음 선택해 사용하는 방법이
    있다. 이 함수의 첫번째 인자가 중요하다.
</p>



<pre class="src src-objc"><span class="org-keyword">enum</span> {
   <span class="org-variable-name">NSApplicationDirectory</span> = 1,
   <span class="org-variable-name">NSDemoApplicationDirectory</span>,
   <span class="org-variable-name">NSDeveloperApplicationDirectory</span>,
   <span class="org-variable-name">NSAdminApplicationDirectory</span>,
   <span class="org-variable-name">NSLibraryDirectory</span>,
   <span class="org-variable-name">NSDeveloperDirectory</span>,
   <span class="org-variable-name">NSUserDirectory</span>,
   <span class="org-variable-name">NSDocumentationDirectory</span>,
   <span class="org-variable-name">NSDocumentDirectory</span>,
   <span class="org-variable-name">NSCoreServiceDirectory</span>,
   <span class="org-variable-name">NSAutosavedInformationDirectory</span> = 11,
   <span class="org-variable-name">NSDesktopDirectory</span> = 12,
   <span class="org-variable-name">NSCachesDirectory</span> = 13,
   <span class="org-variable-name">NSApplicationSupportDirectory</span> = 14,
   <span class="org-variable-name">NSDownloadsDirectory</span> = 15,
   <span class="org-variable-name">NSInputMethodsDirectory</span> = 16,
   <span class="org-variable-name">NSMoviesDirectory</span> = 17,
   <span class="org-variable-name">NSMusicDirectory</span> = 18,
   <span class="org-variable-name">NSPicturesDirectory</span> = 19,
   <span class="org-variable-name">NSPrinterDescriptionDirectory</span> = 20,
   <span class="org-variable-name">NSSharedPublicDirectory</span> = 21,
   <span class="org-variable-name">NSPreferencePanesDirectory</span> = 22,
   <span class="org-variable-name">NSApplicationScriptsDirectory</span> = 23,
   <span class="org-variable-name">NSItemReplacementDirectory</span> = 99,
   <span class="org-variable-name">NSAllApplicationsDirectory</span> = 100,
   <span class="org-variable-name">NSAllLibrariesDirectory</span> = 101,
   <span class="org-variable-name">NSTrashDirectory</span> = 102
};
<span class="org-keyword">typedef</span> <span class="org-type">NSUInteger</span> <span class="org-type">NSSearchPathDirectory</span>;

-(<span class="org-type">NSString</span> *)<span class="org-function-name">itemArchivePath</span>
{
    <span class="org-type">NSArray</span> *<span class="org-variable-name">documentDirectories</span> =
        NSSearchPathForDirectoriesInDomain(
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#52395;&#48264;&#51704; &#51064;&#51088;&#44032; &#51473;&#50836;&#54632;.</span>
                NSDocumentDirectory,
                <span class="org-comment-delimiter">// </span><span class="org-comment">iOS &#50640;&#49436;&#45716; &#50500;&#47000; 2 &#51064;&#51088;&#45716;</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#44144;&#51032; &#48148;&#45068;&#51648; &#50506;&#51020;.</span>
                NSUserDomainMask,
                <span class="org-constant">YES</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">iOS &#50640;&#49436;&#45716; sandbox &#46104;&#50612; &#50500;&#47000;&#51032; &#44221;&#47196; &#47785;&#47197;&#51008; &#44144;&#51032; 1&#44060; &#47564; &#51080;&#45796;. &#51060;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#44221;&#47196;&#50640; &#50612;&#54540;&#51032; &#45936;&#51060;&#53552;&#54028;&#51068;&#51012; &#51200;&#51109;&#54620;&#45796;.</span>
    <span class="org-type">NSString</span> *<span class="org-variable-name">documentDirectory</span>  =
        [documentDirectories objectAtIndex:0];

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#46356;&#47113;&#53664;&#47532;&#47749;&#50640; "item.archive" &#46972;&#45716; &#54028;&#51068;&#47749;&#51012; &#48537;&#51064;&#45796;</span>
    <span class="org-keyword">return</span> [documentDirectory stringByAppendingPathComponent:@<span class="org-string">"item.archive"</span>];
}
</pre>


</div>
</div>

</div>

<div id="outline-container-2-12" class="outline-3">
<h3 id="sec-2-12"><span class="section-number-3">2.12</span> 19장 Touch</h3>
<div class="outline-text-3" id="text-2-12">


</div>

<div id="outline-container-2-12-1" class="outline-4">
<h4 id="sec-2-12-1"><span class="section-number-4">2.12.1</span> UIControl 에 대한 설명</h4>
<div class="outline-text-4" id="text-2-12-1">

<ul>
<li>UIButton, UISlider.. 등의 부모 클래스.
</li>
<li>UIResponder 의 자식 클래스(이벤트 처리가 가능)
</li>
<li>컨트롤 이벤트(control event) :- 상수값으로 정의 (ex:
      UIControlEventTouchUpInside)
</li>
<li>이벤트 발생시 액션(action)메시지를 등록된 타겟(target)으로
      전달함(즉, 타겟의 액션 메소드를 호출함)
</li>
<li>이벤트 처리 : 다음과 같이 <b>액션-타겟</b> 을 컨트롤 이벤트에
      추가한다.(컨트롤 이벤트는 bitmask 로 구성될 수 있는 구조이다.
      아래의 예는 2가지 컨트롤 이벤트 모두에 타겟-액션을 추가한다).




<pre class="src src-objc">[rButton addTarget:temperatureViewController
            action:<span class="org-keyword">@selector</span> (resetTemperature:)
  forControlEvents:UIControlEventTouchUpInsde | UIControlEventTouchUpOutside];
</pre>


</li>
<li>UIControl 의 액션처리의 예(실제 코드는 아님)




<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">&#49345;&#49464; &#44396;&#54788;&#51008; "&#51032;&#49324;&#53076;&#46300;"&#51648;&#47564;, &#54840;&#52636;&#54632;&#49688;&#45716; "&#49892;&#51316;&#54616;&#45716;" &#54632;&#49688;&#45796;!</span>
-(<span class="org-type">void</span>)<span class="org-function-name">touchesEnded</span>:(<span class="org-type">NSSet</span> *)<span class="org-variable-name">touches</span>
          <span class="org-function-name">withEvent</span>:(<span class="org-type">UIEvent</span> *)<span class="org-variable-name">event</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#54788;&#51116;&#51032; &#53552;&#52824;&#44061;&#52404;</span>
    <span class="org-type">UITouch</span> *<span class="org-variable-name">touch</span> = [touches anyObject];

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#54788;&#51116; &#48624; &#49345;&#51032; &#53552;&#52824; &#50948;&#52824;</span>
    <span class="org-type">CGPoint</span> <span class="org-variable-name">touchLocation</span> = [touch locationInView:<span class="org-keyword">self</span>];

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#48624; &#50689;&#50669; &#45236;&#50640; &#51080;&#45716;&#44032;?</span>
    <span class="org-keyword">if</span> (CGRectContainsPoint([<span class="org-keyword">self</span> bounds], touchLocation)) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">TouchUp Inside &#50529;&#49496;&#48156;&#49373;!</span>
        [<span class="org-keyword">self</span> sendActionsForControlEvents:UIControlEventTouchUpInsde];
    } <span class="org-keyword">else</span> {
        [<span class="org-keyword">self</span> sendActionsForControlEvents:UIControlEventTouchUpOutside];
    }
}
</pre>


<p>      
      여기서 sendActionsForControlEvents: 메소드가 호출되면, 해당
      타겟으로 메시지가 바로 전달되는 것이 아니다. UIApplication 객체를
      경유해서 전달된다. 만일 연결된 타겟이 없으면(nil 이면),
      UIApplication 은 UIWindow 내 First Responder 에게 액션 메시지를
      보낸다.
</p>
<p>      
      sendActionsForControlEvents: 메시지의 UIControl 기본 구현은,
      인자로 넘어온 UIControlEvents 상수값에 적합한 selector를
      액션으로 하여, 등록된 target에 UIEvent 객체와 함께 메시지를
      전달하는 sendAction:to:forEvent: 를 주욱 호출하는 식으로 구현된단다.
</p></li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2-13" class="outline-3">
<h3 id="sec-2-13"><span class="section-number-3">2.13</span> 20장 UIGestureRecognizer 와 UIMenuController</h3>
<div class="outline-text-3" id="text-2-13">


</div>

<div id="outline-container-2-13-1" class="outline-4">
<h4 id="sec-2-13-1"><span class="section-number-4">2.13.1</span> UIGestureRecognizer</h4>
<div class="outline-text-4" id="text-2-13-1">

<p>    내가 굳이 제스쳐 인식루틴을 만들 필요가 없다. 얘가 해준다. 보통은
    이 클래스의 서브클래스들을 사용하게 된다. 각각의 제스쳐 인식
    클래스들은 타겟-액션 쌍을 이용해 특정 제스쳐가 인식되면 액션
    메시지를 타겟에 전송한다. 모든 액션의 시그너쳐는 다음과 같다.
</p>



<pre class="src src-objc">- (<span class="org-type">void</span>)<span class="org-function-name">action</span>:(<span class="org-type">UIGestureRecognizer</span> *)<span class="org-variable-name">gestureRecognizer</span>;
</pre>


<p>
    <b>제스쳐 인식기가 있는 뷰는 touchesBegan:withEvent: 같은     통상의 UIResponder 메시지를 받지 않는다</b>
</p>
<p>
    터치 이벤트의 경로는 UIResponder -&gt; UIApplication -&gt; UIWindow -&gt;
    UIGestureRecognizer -&gt; 제스쳐 인식되면 ? UIView의 액션 호출 :
    touchesBegan:withEvent 호출
</p>
<p>
    <b>cancelsTouchesInView</b> 속성이 YES(디폴트값)이면 UIView 의
    touchBegan:withEvent: 같은 터치 이벤트가 호출되지 않는다. NO로
    설정하면 이벤트 핸들러가 호출된다. 
</p>
</div>

</div>

<div id="outline-container-2-13-2" class="outline-4">
<h4 id="sec-2-13-2"><span class="section-number-4">2.13.2</span> UITapGestureRecognizer</h4>
<div class="outline-text-4" id="text-2-13-2">

<p>    대충 이런식으로 생성/설정하는 느낌.
</p>



<pre class="src src-objc">-(<span class="org-type">id</span>) <span class="org-function-name">initWithFrame</span>:(<span class="org-type">CGRect</span>)<span class="org-variable-name">r</span>
{
    <span class="org-keyword">self</span> = [<span class="org-keyword">super</span> initWithFrame:r];
    <span class="org-keyword">if</span> (<span class="org-keyword">self</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">....</span>

        <span class="org-type">UITapGestureRecognizer</span> *<span class="org-variable-name">rec</span> =
            [[<span class="org-type">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="org-keyword">self</span>
                                                    action:<span class="org-keyword">@selector</span> (tap:)];
        [<span class="org-keyword">self</span> addGestureRecognizer:rec];
    }
    <span class="org-keyword">return</span> <span class="org-keyword">self</span>;
}
</pre>


</div>

</div>

<div id="outline-container-2-13-3" class="outline-4">
<h4 id="sec-2-13-3"><span class="section-number-4">2.13.3</span> UIMenuController : "편집"메뉴(Cut/Copy/Paste/Select/Delete&hellip;)다!</h4>
<div class="outline-text-4" id="text-2-13-3">

<ul>
<li>싱글턴으로 사용 : <code>[UIMenuController sharedMenuController]</code>
</li>
<li>메뉴를 present하는 뷰는 First Responder여야 한다
<ol>
<li>해당 뷰의 UIResponder 메소드 becomeFirstResponder 를 호출
</li>
<li>해당 뷰의 UIResponder 메소드 canBecomeFirstResponder 가
         YES를 반환하도록 오버라이드.
</li>
</ol>

</li>
<li>메뉴의 항목들(NSArray)을 UIMenuItem 객체로 setMenuItems: 호출.
      이 때 각 UIMenuItem 의 액션이 타겟에 구현되어 있지 않으면
      화면에 메뉴가 표시되지 않음!
</li>
<li>메뉴의 setMenuVisible:animated: 호출
</li>
<li>메뉴를 dismiss 하려면 setMenuVisible:animated 를 재활용.
</li>
</ul>


</div>

</div>

<div id="outline-container-2-13-4" class="outline-4">
<h4 id="sec-2-13-4"><span class="section-number-4">2.13.4</span> UILongPressGestureRecognizer</h4>
<div class="outline-text-4" id="text-2-13-4">

<ul>
<li>꾸~욱 0.5초(minimumPressDuration 속성값) 이상 누르고 있으면 액션을
      발생시킨다.
</li>
<li>Tap 은 단순한 제스쳐. 
</li>
<li>꾸~욱 누를 때, 3개의 이벤트가 발생
<ol>
<li>처음 누를 때 : UIGestureRecognizerStatePossible
</li>
<li>누른 상태로 충분한 시간이 지났을 때 : UIGestureRecognizerStateBegan
</li>
<li>떼었을 때 : UIGestureRecognizerStateEnded
</li>
</ol>

</li>
<li>2),3) 상태가 될 때 2번 액션이 발생 : 액션 메소드에서 gesture 의
      state 속성으로 어떤 상태인지 알 수 있음. 




<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">UIView &#54028;&#49373;&#53364;&#47000;&#49828;</span>
-(<span class="org-type">id</span>) <span class="org-function-name">initWithFrame</span>:(<span class="org-type">CGRect</span>)<span class="org-variable-name">r</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-type">UILongPressGestureRecognizer</span> *<span class="org-variable-name">gesture</span> =
        [[<span class="org-type">UILongPressGestureRecognizer</span> alloc]
            initWithTarget:<span class="org-keyword">self</span>
                    action:<span class="org-keyword">@selector</span> (longPress:)];
    [<span class="org-keyword">self</span> addGestureRecognizer:gesture];
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>

    <span class="org-keyword">return</span> <span class="org-keyword">self</span>;
}

-(<span class="org-type">void</span>) <span class="org-function-name">longPress</span>:(<span class="org-type">UIGestureRecognizer</span> *)<span class="org-variable-name">gesture</span>
{
    <span class="org-keyword">switch</span> (gesture.state)
    {
    <span class="org-keyword">case</span> UIGestureRecognizerStateBegan:
        <span class="org-comment-delimiter">// </span><span class="org-comment">do something</span>
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> UIGestureRecognizerStateEnded:
        <span class="org-comment-delimiter">// </span><span class="org-comment">do something </span>
        <span class="org-keyword">break</span>;
    }
}
</pre>

</li>
</ul>


</div>

</div>

<div id="outline-container-2-13-5" class="outline-4">
<h4 id="sec-2-13-5"><span class="section-number-4">2.13.5</span> UIPanGestureRecognizer</h4>
<div class="outline-text-4" id="text-2-13-5">

<p>    꾸욱 누른 상태에서 터치를 움직이는 동작(이걸 "panning" 이라 함)을
    감지.
    UIGestureRecognizer가 여러개 UIView 에 addGestureRecognizer: 된
    경우, 자신이 가로챈 터치(객체)를 상호 공유하지 않고, 그냥 "먹어"
    버린다. Long Press 를 감지하려고 하는 동안에 Pan 을 감지하려는
    상황에는 안좋은 특성이다. Pan 과 LongPress 간에 터치를 공유하도록
    하는 방법이 있다.
</p>
<p>
    UIGestureRecognizerDelegate 프로토콜의
    shouldRecognizeSimultaneouslyWithGenstureRecognizer 를
    오버라이드하는 것이다.
</p>
<p>
    이게 YES 를 반환하면, 터치를 서로 다른 제스쳐 인식기가 공유한다.
</p>



<pre class="src src-objc">-(<span class="org-type">BOOL</span>) <span class="org-function-name">gestureRecognizer</span>:(<span class="org-type">UIGestureRecognizer</span> *)<span class="org-variable-name">gestureRecognizer</span>
<span class="org-function-name">shouldRecognizeSimultaneouslyWithGenstureRecognizer</span>:(<span class="org-type">UIGestureRecognizer</span> *)<span class="org-variable-name">other</span>
{
    <span class="org-keyword">if</span> (gestureRecognizer == panGestureRecognizer) {
        <span class="org-keyword">return</span> <span class="org-constant">YES</span>;
    }
    <span class="org-keyword">return</span> <span class="org-constant">NO</span>;
}

</pre>


</div>
</div>

</div>

<div id="outline-container-2-14" class="outline-3">
<h3 id="sec-2-14"><span class="section-number-3">2.14</span> 22장 Core Animation Layer.</h3>
<div class="outline-text-3" id="text-2-14">


</div>

<div id="outline-container-2-14-1" class="outline-4">
<h4 id="sec-2-14-1"><span class="section-number-4">2.14.1</span> QuartzCore.framework</h4>
<div class="outline-text-4" id="text-2-14-1">

</div>

</div>

<div id="outline-container-2-14-2" class="outline-4">
<h4 id="sec-2-14-2"><span class="section-number-4">2.14.2</span> CALayer 는 UIKit 에서는 모든 View가 가진다.</h4>
<div class="outline-text-4" id="text-2-14-2">

<p>    암시적으로 CALayer 가 모든 View에 1개씩 정의되어 있다.
    &ndash;&gt; UIView의 layer 속성
</p></div>

</div>

<div id="outline-container-2-14-3" class="outline-4">
<h4 id="sec-2-14-3"><span class="section-number-4">2.14.3</span> CALayer의 주요 속성</h4>
<div class="outline-text-4" id="text-2-14-3">

<ul>
<li>sublayers(NSArray *) : 1개 부모 CALayer 당 여러개의 Sub Layer를
      가진다. : sublayers UIView에서도 subviews 속성이 있었다.
</li>
<li>contents(id) : "이미지"임. iOS에서는 CGImageRef 로 지정(단
      (_bridge id) 로 형변환해야 ARC가 제대로 처리함) Mac에서는 NSImage도
      가능.



<pre class="src src-objc"><span class="org-type">CALayer</span> *<span class="org-variable-name">boxLayer</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">....</span>
<span class="org-type">UIImage</span> *<span class="org-variable-name">image</span> = [[<span class="org-type">UIImage</span> imageNamed:@<span class="org-string">"Hypno"</span>] CGImage];
boxLayer.contents = (__bridge <span class="org-type">id</span>)image;
</pre>

</li>
<li>zPosition : 시점에 따른 크기 변화는 없는 Z축 높이 값. 시점변화는
      없는 직교 Z축.
</li>
</ul>

</div>

</div>

<div id="outline-container-2-14-4" class="outline-4">
<h4 id="sec-2-14-4"><span class="section-number-4">2.14.4</span> CALayer 는 암묵적으로 animation기능이 들어간다.</h4>
<div class="outline-text-4" id="text-2-14-4">

<p>    단순히 position 속성의 값만 바꾸어도 animation이 들어간다. 오.
    그런데, touchesMoved:withEvent: 같은 핸들러에서 position 갱신시
    동작이 오히려 animation되느라 굼뜬데. 이런경우 <b>CATransaction</b> 을
    쓸 수 있다.
</p>


<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">UIVIew &#54028;&#49373; &#53364;&#47000;&#49828; &#47700;&#49548;&#46300;</span>
-(<span class="org-type">void</span>)<span class="org-function-name">touchesMoved</span>:(<span class="org-type">NSSet</span> *)<span class="org-variable-name">touches</span>
          <span class="org-function-name">withEvent</span>:(<span class="org-type">UIEvent</span> *)<span class="org-variable-name">event</span>
{
    [<span class="org-type">CATransaction</span> begin];
    [<span class="org-type">CATransaction</span> setDisableActions:<span class="org-constant">YES</span>];

    aLayer.position = [[touches anyObject] locationInView:<span class="org-keyword">self</span>];

    [<span class="org-type">CATransaction</span> commit];
}
</pre>

</div>

</div>

<div id="outline-container-2-14-5" class="outline-4">
<h4 id="sec-2-14-5"><span class="section-number-4">2.14.5</span> CALayerDelegate 의 drawLayer:inContext: 메시지</h4>
<div class="outline-text-4" id="text-2-14-5">

<p>    UIView의 암묵적 CALayer의 delegate는 UIView 자신이다.
    CALayerDelegate(informal protocol임) 메소드 drawLayer:inContext:
    가 UIView에서 구현되어 호출되면, CALayer 의 drawInContext: 를
    호출하는 기본 구현이 실행된다.
</p>
<p>
    호출시, 사각형 영역은 <code>CGContextGetClipBoundingBox(ctx)</code> 를
    호출하여 얻을 수 있고, <code>CGContextDrawImage(ctx, boundBox,     [layerImage CGImage])</code> 를 사용하여 UIImage 를 그릴 수 있다.
</p>
</div>
</div>

</div>

<div id="outline-container-2-15" class="outline-3">
<h3 id="sec-2-15"><span class="section-number-3">2.15</span> 23장 CAAnimation 을 사용한 애니메이션</h3>
<div class="outline-text-3" id="text-2-15">


</div>

<div id="outline-container-2-15-1" class="outline-4">
<h4 id="sec-2-15-1"><span class="section-number-4">2.15.1</span> Layer를 View에 더하고, Animation을 Layer에 더하다</h4>
<div class="outline-text-4" id="text-2-15-1">

<p>    CAAnimation 객체를 Layer 에 추가해서 애니메이션을 제어할 수 있다.
    Qt 의 property animation 개념으로.. opacity, position, transform,
    bounds, contents 를 포함하여 여러가지를 애니메이션한다.
</p></div>

</div>

<div id="outline-container-2-15-2" class="outline-4">
<h4 id="sec-2-15-2"><span class="section-number-4">2.15.2</span> Animation 객체의 종류</h4>
<div class="outline-text-4" id="text-2-15-2">

<p>    <img src="img/LearnObjC_20130318_203606_.png"  alt="img/LearnObjC_20130318_203606_.png" />
</p>
<ul>
<li>CAAnimation : duration/timingFunction/delegate 속성 속성
<ul>
<li>CAAnimationGroup : animations
</li>
<li>CAPropertyAnimation : keyPath 속성(NSString)
<ul>
<li>CABasicAnimation : fromValue/toValue 속성(id형임! NSNumber,
          CGPoint..등등 다양한 타입에 대응!!)
</li>
<li>CAKeyframeAnimation : values/keyTimes/timingFunctions 속성
</li>
</ul>

</li>
<li>CATransition : filter 속성
</li>
</ul>

</li>
</ul>

</div>

</div>

<div id="outline-container-2-15-3" class="outline-4">
<h4 id="sec-2-15-3"><span class="section-number-4">2.15.3</span> CALayer 의 애니메이션가능 속성</h4>
<div class="outline-text-4" id="text-2-15-3">

<ul>
<li>CAPropertyAnimation 의 keyPath 는 속성에 대한 이름 NSString.
      (<b>Key-Value Coding</b>) : Qt 의 QSettings 와 유사.
</li>
<li>CALayer의 주요 애니메이션 방법 : 속성 애니매이션 by
      CABasicAnimation and CAKeyframeAnimation
</li>
<li>CALayer 에 addAnimation:forKey: 를 호출하면서 CAAnimation
      객체를 넘겨주면, <b>복제본이 생성</b> 된다. 따라서 원본에 대해
      변경을 가하더라도 OK.
</li>
<li><b>애니메이션이 끝나면 애니메이션 객체는 소멸된다.</b> 
      아래와 같이 해보니 확인이 되더라.



<pre class="src src-objc"><span class="org-type">interface</span> <span class="org-function-name">MyAnimation</span> : CABasicAnimation
<span class="org-keyword">@end</span>

<span class="org-keyword">@implementation</span> <span class="org-type">MyAnimation</span>
+(<span class="org-type">id</span>)<span class="org-function-name">animationWithKeyPath</span>:(<span class="org-type">NSString</span> *)<span class="org-variable-name">keyPath</span>
{
    <span class="org-type">MyAnimation</span> *<span class="org-variable-name">instance</span> = [[<span class="org-type">MyAnimation</span> alloc] init];
    instance.keyPath = keyPath;
    <span class="org-keyword">return</span> instance;
}
-(<span class="org-type">id</span>)<span class="org-function-name">init</span>
{
    <span class="org-keyword">self</span> = [<span class="org-keyword">super</span> init];
    NSLog(@<span class="org-string">"MyAnimation ctor"</span>);
    <span class="org-keyword">return</span> <span class="org-keyword">self</span>;
}
-(<span class="org-type">void</span>)<span class="org-function-name">dealloc</span>
{
    NSLog(@<span class="org-string">"MyAnimation dtor"</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">[super dealloc];</span>
}
<span class="org-keyword">@end</span>      
</pre>

</li>
</ul>


</div>

</div>

<div id="outline-container-2-15-4" class="outline-4">
<h4 id="sec-2-15-4"><span class="section-number-4">2.15.4</span> KeyPath 찾는 방법</h4>
<div class="outline-text-4" id="text-2-15-4">

<ul>
<li>XCode 문서의 "Core Animation Programming Guide &gt; Appendix 를
      참조하면 된다. 2가지 중요한 부분
<ol>
<li>"Animatable Properties"
         bounds, position, &hellip; 이런 일반적인&hellip;
</li>
<li>"Key Path Support for Structures"
         transform.rotation.x, &hellip;이런 의사 3D 변환에 대해 
</li>
</ol>

</li>
</ul>

</div>

</div>

<div id="outline-container-2-15-5" class="outline-4">
<h4 id="sec-2-15-5"><span class="section-number-4">2.15.5</span> CABasicAnimation</h4>
<div class="outline-text-4" id="text-2-15-5">

<ul>
<li>duration/keyPath/fromValue/toValue 를 이용한 가장 기본적인
      애니메이션 제공.
</li>
<li><b>생성자는 부모클래스 CAPropertyAnimation 의       +animationWithKeyPath: 를 사용한다</b>
</li>
</ul>





<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">&#50528;&#45768;&#47700;&#51060;&#49496; &#44061;&#52404; &#49373;&#49457;</span>
<span class="org-type">CAAnimation</span> *<span class="org-variable-name">fader</span> = [<span class="org-type">CABasicAnimation</span> animationWithKeyPath:@<span class="org-string">"opacity"</span>];
<span class="org-type">CAAnimation</span> *<span class="org-variable-name">mover</span> = [<span class="org-type">CABasicAnimation</span> animationWithKeyPath:@<span class="org-string">"position"</span>];
<span class="org-comment-delimiter">// </span><span class="org-comment">&#47751;&#52488; &#46041;&#50504; &#50528;&#45768;&#47700;&#51060;&#49496;?</span>
[fader setDuration:2.0];
[mover setDuration:1.0];
<span class="org-comment-delimiter">// </span><span class="org-comment">&#52488;&#44592;&#44050; &#49444;&#51221;</span>
[fader setFromValue:[<span class="org-type">NSNumber</span> numberWithFloat:1.0]];
[mover setFromValue:[<span class="org-type">NSValue</span> valueWithCGPoint:CGPointMake(0.0, 100.0)]];
<span class="org-comment-delimiter">// </span><span class="org-comment">&#47560;&#51648;&#47561;&#44050; &#49444;&#51221;</span>
[fader setToValue:[<span class="org-type">NSNumber</span> numberWithFloat:0.0]];
[mover setToValue:[<span class="org-type">NSValue</span> valueWithCGPoint:CGPointMake(100.0, 100.0)]];
<span class="org-comment-delimiter">// </span><span class="org-comment">&#50528;&#45768;&#47700;&#51060;&#49496; &#49884;&#51089;?! &#50668;&#44592; &#51060;&#47492; "BigFade" &#45716; &#49884;&#49828;&#53596;&#51008; &#47924;&#49884;&#54632;. &#54616;&#51648;&#47564;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#45208;&#51473;&#50640; &#51060; &#50528;&#45768;&#47700;&#51060;&#49496;&#51012; &#51473;&#45800;&#54616;&#44144;&#45208; &#54624;&#46412; &#51060; &#51060;&#47492;&#51004;&#47196; &#52280;&#51312;&#44032;&#45733;</span>
[myLayer addAnimation:fader forKey:@<span class="org-string">"BigFade"</span>];
[myLayer addAnimation:mover forKey:@<span class="org-string">"BigMove"</span>];
</pre>

</div>

</div>

<div id="outline-container-2-15-6" class="outline-4">
<h4 id="sec-2-15-6"><span class="section-number-4">2.15.6</span> CAKeyframeAnimation</h4>
<div class="outline-text-4" id="text-2-15-6">

<p>    Key Frame 별로 속성값의 변화를 지정할 수 있단다. 일단 더 많은
    제어가 가능하지만, 맛보기로.
</p>


<pre class="src src-objc"><span class="org-type">CAKeyframeAnimation</span> *<span class="org-variable-name">mover</span> = [<span class="org-type">CAKeyframeAnimation</span> animationWithKeyPath:@<span class="org-string">"position"</span>];
<span class="org-type">NSArray</span> *<span class="org-variable-name">values</span> = [[<span class="org-type">NSMutableArray</span> alloc] init];
[values addObject:[<span class="org-type">NSValue</span> valueWithCGPoint:CGPointMake(0.0, 100.)]];
[values addObject:[<span class="org-type">NSValue</span> valueWithCGPoint:CGPointMake(100., 100.)]];
[mover setValues:values];
[mover setDuration:1.0];
</pre>

</div>

</div>

<div id="outline-container-2-15-7" class="outline-4">
<h4 id="sec-2-15-7"><span class="section-number-4">2.15.7</span> CAAnimationGroup</h4>
<div class="outline-text-4" id="text-2-15-7">

<p>    여러 애니메이션을 묶어서 동시에 &hellip; 원래는 addAnimation:forKey:
    하면 하나 하나 따로 진행되던가?
</p>


<pre class="src src-objc"><span class="org-type">CABasicAnimation</span> *<span class="org-variable-name">mover</span> = [<span class="org-type">CABasicAnimation</span> animationWithKeyPath:@<span class="org-string">"position"</span>];
[mover setDuration:1.0];
[mover setFromValue:[<span class="org-type">NSValue</span> valueWithCGPoint:CGPointMake(0, 100)]];
[mover setToValue:[<span class="org-type">NSValue</span> valueWithCGPoint:CGPointMake(100, 100)]];

<span class="org-type">CABasicAnimation</span> *<span class="org-variable-name">fader</span> = [<span class="org-type">CABasicAnimation</span> animationWithKeyPath:@<span class="org-string">"opacity"</span>];
[fader setDuration:2.0];
[mover setFromValue:[<span class="org-type">NSNumber</span> numberWithFloat:1.0]];
[mover setToValue:[<span class="org-type">NSNumber</span> numberWithFloat:0.0]];

<span class="org-type">CAAnimationGroup</span> *<span class="org-variable-name">group</span> = [<span class="org-type">CAAnimationGroup</span> animation];
[group setAnimations:[<span class="org-type">NSArray</span> arrayWithObjects:fader, mover, <span class="org-constant">nil</span>]];
</pre>

</div>

</div>

<div id="outline-container-2-15-8" class="outline-4">
<h4 id="sec-2-15-8"><span class="section-number-4">2.15.8</span> CATransition</h4>
<div class="outline-text-4" id="text-2-15-8">

<ul>
<li>Mac OSX 에서는 CoreImageFilters 를 사용해 꽤 강력하지만, IOS
      에서는 fading 과 sliding 정도에만 쓰인다는데&hellip;
</li>
<li>UINavigationController 에서, view 를 스크린상에 pushing 할 때
      사용된단다.
</li>
</ul>


</div>

</div>

<div id="outline-container-2-15-9" class="outline-4">
<h4 id="sec-2-15-9"><span class="section-number-4">2.15.9</span> Timing Function</h4>
<div class="outline-text-4" id="text-2-15-9">

<ul>
<li>속성 애니메이션시 시간에 따른 f(t) 함수를 지정할 수 있다.
</li>
<li>CAMediaTimingFunction 객체를 만들어서 지정하면 됨.
</li>
<li>+functionWithName: 클래스 메소드를 쓰면 미리 지정된 몇가지 편이
      객체를 쓸 수 있음(아래는 모두 NSString *const 타입.
<ol>
<li>kCAMediaTimingFunctionLinear : 선형변화
</li>
<li>kCAMediaTimingFunctionEaseIn : 초기에 느리게
</li>
<li>kCAMediaTimingFunctionEaseOut : 말기에 느리게
</li>
<li>kCAMediaTimingFunctionEaseInEaseOut : 초기와 말기에 느리게
</li>
<li>kCAMediaTimingFunctionDefault : 기본값이라는데?
</li>
</ol>

</li>
</ul>




<pre class="src src-objc">[spin setDuration:1.0];
<span class="org-comment-delimiter">// </span><span class="org-comment">timing function &#49444;&#51221;</span>
<span class="org-type">CAMediaTimingFunction</span> *<span class="org-variable-name">timing</span> = [<span class="org-type">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
[spin setTimingFunction:timing];
<span class="org-comment-delimiter">// </span><span class="org-comment">Layer&#50640; &#49444;&#51221;</span>
[myLayer addAnimation:spin]
</pre>

</div>

</div>

<div id="outline-container-2-15-10" class="outline-4">
<h4 id="sec-2-15-10"><span class="section-number-4">2.15.10</span> Animation Completion</h4>
<div class="outline-text-4" id="text-2-15-10">

<p>    CAAnimation 모듈(CAAnimation.h) 은 CAAnimation 이라는 NSObject의
    extension 을 가지고 있다(즉, informal protocol이다).
</p>



<pre class="src src-objc"><span class="org-comment-delimiter">/* </span><span class="org-comment">Delegate methods for CAAnimation. */</span>
<span class="org-keyword">@interface</span> <span class="org-type">NSObject</span> (<span class="org-type">CAAnimationDelegate</span>)
<span class="org-comment-delimiter">// </span><span class="org-comment">&#50528;&#45768;&#47700;&#51060;&#49496; &#49884;&#51089;&#49884; &#54840;&#52636;&#46120;</span>
- (<span class="org-type">void</span>)<span class="org-function-name">animationDidStart</span>:(<span class="org-type">CAAnimation</span> *)<span class="org-variable-name">anim</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">&#50528;&#45768;&#47700;&#51060;&#49496; &#51333;&#47308;&#49884; &#54840;&#52636;&#46120;(&#44053;&#51228;&#51333;&#47308;&#46104;&#47732; flag&#45716; NO)</span>
- (<span class="org-type">void</span>)<span class="org-function-name">animationDidStop</span>:(<span class="org-type">CAAnimation</span> *)<span class="org-variable-name">anim</span> <span class="org-function-name">finished</span>:(<span class="org-type">BOOL</span>)<span class="org-variable-name">flag</span>;
<span class="org-keyword">@end</span>
</pre>


</div>

</div>

<div id="outline-container-2-15-11" class="outline-4">
<h4 id="sec-2-15-11"><span class="section-number-4">2.15.11</span> CALayer의 Presentation Layer(그리고 Model Layer)</h4>
<div class="outline-text-4" id="text-2-15-11">

<ul>
<li>CALayer 는 2가지 요소로 구성
<ol>
<li>화면에 띄울 내용
</li>
<li>화면에 띄울 내용을 어떻게 스크린에 합성할 것이다.
</li>
</ol>

</li>
<li>위에서 2)를 제어하는게 애니메이션 CAAnimation의 역할.
<ol>
<li>opacity
</li>
<li>transform(rotation, scale&hellip;)
</li>
<li>position
</li>
</ol>

<p>      등등 이 있는데, 이 속성은 2가지 버젼이 존재.
</p></li>
<li>Presentation 버젼 -&gt; 이걸로 표시되는걸 Apple에서 Presentation
      Layer라 명명함
</li>
<li>Model 버젼 -&gt; 이걸로 표시되는 걸 Apple에서는 Model Layer라
      명명함.
</li>
<li><b>중요기억사항</b>
<ul>
<li>CALayer 객체에 position 속성을 요청하면 ? <b>presentation layer</b>
        의 값이 넘어옴(애니메이션 중에는 model layer의 position과
        다를 수 있음. ex: 게임에서 객체의 위치)
</li>
<li><b>애니메이션 종료후 position이 갑자기 확 튄 상태로 종료?</b> &ndash;&gt;
        model layer 의 값이 presentation layer의 애니메이션 종료값과
        다른 문제.
</li>
<li><b>애니메이션이 전혀 되지 않는 문제</b> &ndash;&gt; model layer의 값과
        애니메이션 종료 position 값이 똑같음(다르게 해주어야
        애니메이션이 이루어짐)
</li>
</ul>

</li>
</ul>



</div>
</div>

</div>

<div id="outline-container-2-16" class="outline-3">
<h3 id="sec-2-16"><span class="section-number-3">2.16</span> 24장 UIStoryboard</h3>
<div class="outline-text-3" id="text-2-16">


</div>

<div id="outline-container-2-16-1" class="outline-4">
<h4 id="sec-2-16-1"><span class="section-number-4">2.16.1</span> 기본준비</h4>
<div class="outline-text-4" id="text-2-16-1">

<ul>
<li>Empty Project 생성
</li>
<li>File &gt; New 에서 story board 생성(iphone용 선택)
</li>
<li>storyboard 파일 에디팅
</li>
<li>UINavigationController 를 끌어다 놓으면 내비뷰컨 과
       테이블뷰컨이 생성된다.
</li>
<li>스토리보드 편집시, 배경 더블클릭 또는 편집창 우측 하단의 버튼으로
     zoom in/out 할 수 있다. <b>하지만 zoom out 된 상태에서는 뷰컨만      선택되고 뷰는 선택되지 안으므로 주의!</b>
</li>
</ul>

</div>

</div>

<div id="outline-container-2-16-2" class="outline-4">
<h4 id="sec-2-16-2"><span class="section-number-4">2.16.2</span> Segue(세그웨이:곡/영화등에서 부드러운 장면전환)s</h4>
<div class="outline-text-4" id="text-2-16-2">

<ul>
<li>UIStoryboardSegue 클래스 : 보통의 iOS 어플들이 다수의 뷰컨들간
      전환으로 구성된다는 점에 착안, 스토리보드는 코드를 전혀! 작성하지
      않고도 뷰컨들을 구성하고 이들간 장면전환을 할 수 있는 <i>Segues</i>
      라는 걸 이 클래스를 통해 제공한다.
</li>
<li>UIStoryboardSegue 의 구성
<ol>
<li>style
</li>
<li>action item
</li>
<li>identifier : 액션등에 의해 특정 장면전환이 이루어져야 할 때 특정
         세그웨이에 대한 참조가 필요한 데, 그 때 이 id를 사용해
         참조가능.
</li>
</ol>

</li>
</ul>

</div>

</div>

<div id="outline-container-2-16-3" class="outline-4">
<h4 id="sec-2-16-3"><span class="section-number-4">2.16.3</span> 한번써보기.</h4>
<div class="outline-text-4" id="text-2-16-3">

</div>

</div>

<div id="outline-container-2-16-4" class="outline-4">
<h4 id="sec-2-16-4"><span class="section-number-4">2.16.4</span> 스토리보드를 써야 할까?</h4>
<div class="outline-text-4" id="text-2-16-4">

<p>    아니란다. :(
</p><ul>
<li>장점
<ol>
<li>어플의 프로그램 흐름을 고객이나 동료에게 보이기 쉽다
</li>
<li>소스코드 작성양이 몇가지 경우에는 거의 필요없다.
</li>
<li>테이블뷰컨이 Static Content 라면 쉽게 만들 수 있다.
</li>
<li>스토리보드는 시각적으로 예쁘게 보인다.
</li>
</ol>

</li>
<li>단점
<ol>
<li>팀으로 함께 작업하기 힘들다. 모든 팀원들이 1개의 스토리 보드
         파일을 가지고 작업해야 하기 때문.
</li>
<li>그러다 보니, 버젼관리가 힘들어 질 수 있겠다.
</li>
<li>코드로 alloc/init 하고
         presentViewController:animated:completion: .. 처럼 쉽게 할
         것을 드래그 하고, 클래스 지정하고, 따로 만들고, 번잡하게 되기
         쉽상이다.
</li>
<li>쉬운것은 더 쉽게 되지만, 어려운 건 더 어렵게 된다. 조금 만
         더 손을 보려고 해도 오히려 더 힘들어지기 쉽상이다.
</li>
<li>스토리보드는 뷰컨을 항상 새로 만든다. 혹시라도 메모리에
         남겨두고 싶을때 문제가 된단다.
</li>
</ol>

</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2-17" class="outline-3">
<h3 id="sec-2-17"><span class="section-number-3">2.17</span> 25장 웹 서비스와 UIWebView</h3>
<div class="outline-text-3" id="text-2-17">


</div>

<div id="outline-container-2-17-1" class="outline-4">
<h4 id="sec-2-17-1"><span class="section-number-4">2.17.1</span> 목표 어플 "NerdFeed" 의 기능</h4>
<div class="outline-text-4" id="text-2-17-1">

<ul>
<li>Big Ner Ranch Forum 의 RSS 피드를 읽어오는 프로그램을 만든다.
</li>
<li>2가지 주요 작업
<ol>
<li>웹서비스에 접속하여 데이터를 긁어와서 모델 객체들을 생성
</li>
<li>UIWebView 클래스를 사용해 웹 컨텐츠를 화면에 표시
</li>
</ol>

</li>
<li>클래스 다이어그램
     <img src="img/LearnObjC_20130320_001555_.png"  alt="img/LearnObjC_20130320_001555_.png" />
</li>
</ul>

</div>

</div>

<div id="outline-container-2-17-2" class="outline-4">
<h4 id="sec-2-17-2"><span class="section-number-4">2.17.2</span> 웹 서비스</h4>
<div class="outline-text-4" id="text-2-17-2">

<ul>
<li>웹브라우저 : HTTP 프로토콜을 사용해 웹 서버와 통신.
</li>
<li>HTTP 의 가장 간단한 모델 : URL 을 지정하여 서버에 요청을 전송 /
      요청한 페이지(대개는 HTLM과 이미지)를 응답 / 브라우저가
      서식화하여 화면에 표시
</li>
<li>HTTP 의 일반적인 모델 : 폼 데이터와 같은 추가적인 파라메터를
      포함한 요청을 서버에 전송 / 추가 파라메터에 따라 사용자화 되고
      동적인 웹페이지를 만들어 응답
</li>
<li>서버에서 이러한 일을 처리하는 서비스를 웹 서비스라함.
</li>
<li>HTTP 프로토콜은 전송되는 데이터의 종류를 가리지 않음. 대개는 XML
      이나 JSON 포맷임. 클라이언트는 이 데이터를 잘 파싱하면 됨.
</li>
</ul>


</div>

</div>

<div id="outline-container-2-17-3" class="outline-4">
<h4 id="sec-2-17-3"><span class="section-number-4">2.17.3</span> NerdFeed 만들기</h4>
<div class="outline-text-4" id="text-2-17-3">

<ol>
<li>Empty Application
</li>
<li>UITableViewController 의 서브클래스 ListViewController 생성
</li>
<li>UINaviationController 생성(rootViewController 는 listViewController)
</li>
<li>UIWindow 의 rootViewController navigationController 지정
</li>
</ol>


</div>

</div>

<div id="outline-container-2-17-4" class="outline-4">
<h4 id="sec-2-17-4"><span class="section-number-4">2.17.4</span> URL 구성하여 서버에 페이지 요청하기</h4>
<div class="outline-text-4" id="text-2-17-4">

<ul>
<li>URL 의 구성방법 자체가 웹 서비스의 API 라 할 수 있음.
</li>
<li>BigNerdRanch Forum의 RSS 피드는 다음과 같은 서식의 URL로 요청



<pre class="example">http://forums.bignerdranch.com/smartfeed.php?limit=1_DAY&amp;sort_by=standard&amp;feed_type=RSS2.0&amp;feed_style=COMPACT
</pre>

</li>
<li>baseURL : forums.bignerdranch.com
</li>
<li>serviceName : smartfeed
</li>
<li>일반적으로 baseURL 과 serviceName 으로 다음과 같은 URL이 구성



<pre class="example">http://baseURL.com/serviceName?argumentX=valueX&amp;argumentY=valueY
</pre>

</li>
<li>URL에 문자열이 들어가는 경우 "URL안전한(URL Safe)" 문자열이
      되어야 한다. 



<pre class="src src-objc"><span class="org-type">NSString</span> *<span class="org-variable-name">search</span> = @<span class="org-string">"Play some \"Abba\" Songs"</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">&#51320;&#46972; &#44596; &#47700;&#49884;&#51648;&#47749; "&#53945;&#51221; &#51064;&#53076;&#46377;&#51012; &#49324;&#50857;&#54644; &#54140;&#49468;&#53944; &#51060;&#49828;&#52992;&#51060;&#54532;&#46108; &#47928;&#51088;&#50676;&#51012;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#54140;&#49468;&#53944;&#44592;&#54840;&#47196; &#47564;&#46304; &#47928;&#51088;&#50676;&#51012; &#48152;&#54872;&#54616;&#46972;"</span>
<span class="org-type">NSString</span> *<span class="org-variable-name">escapedSearch</span> =
    [search stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
<span class="org-comment-delimiter">// </span><span class="org-comment">&#44208;&#44284;&#44050;&#51008; "Play%20some%20%22Abba%22%20Songs" &#47196; &#45208;&#50740;</span>
</pre>

</li>
<li>NSURLConnection 객체는 초기화 함수에 NSURLRequest 객체를 만들어
      넘기면 작업을 주욱 하고 스스로 파기 된다. 
      그 LifeTime 동안 NSURLConnectionDelegate 객체에 다음 메시지를 전송
<ol>
<li>서버 접속 : 실패시 -connection:didFailWitError 
</li>
<li>URL에 해당하는 페이지 요청
</li>
<li>서버의 응답을 주욱 수신 : -connection:didReceiveData: 
</li>
<li>위 3)단계가 여러번에 걸쳐서 호출됨. 일반적으로 클라이언트는
         받은 데이터를 내부적으로 누적해서 가지고 있음.
</li>
<li>접속 완료 : -connectionDidFinishLoading: 전송
</li>
<li>NSURLConnection 객체 스스로 파괴.
</li>
</ol>

</li>
</ul>


</div>

</div>

<div id="outline-container-2-17-5" class="outline-4">
<h4 id="sec-2-17-5"><span class="section-number-4">2.17.5</span> 페이지 XML 데이터 파싱 - NSXMLParser</h4>
<div class="outline-text-4" id="text-2-17-5">

<ul>
<li>NSXMLParser : "Event Driven XML Parser"
</li>
<li>NSXMLParserDelegate : Event Handler
</li>
<li>"&lt;title&gt;Big Nerd Ranch&lt;/title&gt;" 수신시 Event Handling
<ol>
<li>Element 시작 발견했음! : &lt;title&gt;



<pre class="src src-objc">- (<span class="org-type">void</span>) <span class="org-function-name">parser</span>:(<span class="org-type">NSXMLParser</span> *)<span class="org-variable-name">parser</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">xml parser &#44061;&#52404;</span>
<span class="org-function-name">didStartElement</span>:(<span class="org-type">NSString</span> *)<span class="org-variable-name">elementName</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Element&#51060;&#47492;</span>
   <span class="org-function-name">namespaceURI</span>:(<span class="org-type">NSString</span> *)<span class="org-variable-name">nameUri</span>
  <span class="org-function-name">qualifiedName</span>:(<span class="org-type">NSString</span> *)<span class="org-variable-name">qualifiedName</span>
     <span class="org-function-name">attributes</span>:(<span class="org-type">NSDictionary</span> *)<span class="org-variable-name">attributeDict</span>
</pre>

</li>
<li>문자열 발견했음! : Big Nerd Ranch
         <b>주의할 점</b> 문자열이 여러번에 걸쳐서 나뉘어져 올 수 있다.
         따라서, delegate 는 string 으로 넘어온 문자열을 기존 값에
         계속 합치는 로직따위가 필요하다.



<pre class="src src-objc">- (<span class="org-type">void</span>)<span class="org-function-name">parser</span>:(<span class="org-type">NSXMLParser</span> *)<span class="org-variable-name">parser</span> <span class="org-comment-delimiter">// </span><span class="org-comment">xml parser &#44061;&#52404;</span>
<span class="org-function-name">foundCharacters</span>:(<span class="org-type">NSString</span> *)<span class="org-variable-name">string</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#52286;&#51008; &#47928;&#51088;&#50676;</span>
</pre>

</li>
<li>Element 끝 발견했음! : &lt;/title&gt;



<pre class="src src-objc">-(<span class="org-type">void</span>) <span class="org-function-name">parser</span>:(<span class="org-type">NSXMLParser</span> *)<span class="org-variable-name">parser</span>
 <span class="org-function-name">didEndElement</span>:(<span class="org-type">NSString</span> *)<span class="org-variable-name">element</span> <span class="org-comment-delimiter">// </span><span class="org-comment">&#52286;&#51008; element&#51060;&#47492;</span>
  <span class="org-function-name">namespaceURI</span>:(<span class="org-type">NSString</span> *)<span class="org-variable-name">uri</span>
 <span class="org-function-name">qualifiedName</span>:(<span class="org-type">NSString</span> *)<span class="org-variable-name">qualifiedName</span>;
</pre>

</li>
</ol>

</li>
</ul>


</div>

</div>

<div id="outline-container-2-17-6" class="outline-4">
<h4 id="sec-2-17-6"><span class="section-number-4">2.17.6</span> NSXMLParser 의 delegate 를 동적으로 변경</h4>
<div class="outline-text-4" id="text-2-17-6">

<p>    내부적으로 "현재 처리하고 있는 데이터 요소"에 대해서 상태관리를
    따로 할 필요없이, 각 "데이터 요소" 로 하여금 처리를 대리하도록
    적절한 시점에 NSXMLParser 의 delegate 를 변경해 주면 코딩이 깔끔.
</p>
<p>
    <img src="img/LearnObjC_20130320_231209_.png"  alt="img/LearnObjC_20130320_231209_.png" />
    <img src="img/LearnObjC_20130320_231315_.png"  alt="img/LearnObjC_20130320_231315_.png" />
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 학습메모</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 변수이름 shadowing 문제 : 속성값방식으로 접근하기 vs 멤버변수로 접근하기</h3>
<div class="outline-text-3" id="text-3-1">


<p>
   사실
</p>



<pre class="src src-objc">-(<span class="org-type">void</span>)<span class="org-function-name">setCircleColor</span>:(<span class="org-type">UIColor</span>*)<span class="org-variable-name">color</span>
{
    circleColor = color;
    [<span class="org-keyword">self</span> setNeedsDisplay];     <span class="org-comment-delimiter">// </span><span class="org-comment">&#54868;&#47732;&#44081;&#49888;</span>
}
</pre>


<p>
   이런식으로 하면 된다. 그런데, 문제는 이름이 너무 단순한 경우
</p>



<pre class="src src-objc">-(<span class="org-type">void</span>)<span class="org-function-name">setX</span>:(<span class="org-type">UIColor</span>*)<span class="org-variable-name">x</span>
{
    x = x
    [<span class="org-keyword">self</span> setNeedsDisplay];     <span class="org-comment-delimiter">// </span><span class="org-comment">&#54868;&#47732;&#44081;&#49888;</span>
}
</pre>


<p>
   이런식의 shadowing문제가 있다. 이런경우
</p>
<ul>
<li><code>self.x = x;</code> 이런식으로 하면 속성값 방식으로
     접근한다. setter함수에서 이런짓을 하면 무한 재귀호출이 일어난다.
</li>
<li><code>self-&gt;x = x;</code> 이런식은 단순히 변수값 자체에
     접근하는 것. setter함수에서 사용할 수 있는 형식.
</li>
</ul>


<p>
   <a href="http://blog.ablepear.com/2010/04/objective-c-tuesdays-instance-variables.html">여기</a> 에 기술된 내용을 읽어보는게 도움이 된다. 
</p>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> ARC : property attribute 와 variable qualifier</h3>
<div class="outline-text-3" id="text-3-2">


</div>

<div id="outline-container-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> property attributes</h4>
<div class="outline-text-4" id="text-3-2-1">

<ul>
<li>strong(디폴트)
</li>
<li>weak
</li>
</ul>

</div>

</div>

<div id="outline-container-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> variable qualifier</h4>
<div class="outline-text-4" id="text-3-2-2">

<ul>
<li>__strong
</li>
<li>__weak
</li>
<li>__unsafe_unretained : 가리키는 넘이 할당해제되면 dangling되는&hellip;
</li>
<li>__autoreleasing : 객체가 (id*), 즉 pass-by-ref 로 넘어가고
    리턴시에 autorelease 되는&hellip;
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> ARC : factory class method정의시 "이름"에 따라 컴파일러가 달리 처리한다!!!</h3>
<div class="outline-text-3" id="text-3-3">


<p>
   결국 ARC 는 컴파일러가 retained 상태로 반환되는 객체를 처리하는
   부분과도 연관이 깊게 된다.
</p>
<p>
   <a href="http://stackoverflow.com/a/12149763/884268">StackOverflow</a> 및 <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#retained-return-values">Clang공식문서</a> 에 따르면, retained 상태로 객체를
   생성/반환하는 메소드들을 컴파일러가 인식하여 자동으로 release
   처리를 해주도록 하는 것 같다. 
</p>
<p>   
    <code>__attribute((ns_returns_retained))</code> 을 사용하면, 완벽(?)한 scoped
    객체가 만들어지는 것 같다. 이 어트리뷰트는 아래와 같은
    <code>NS_RETURNS_RETAINED</code> 매크로를 사용할 수 도 있겠다. 
</p>



<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">NSObCRuntime.h &#51473;&#50640;&#49436;...</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Marks methods and functions which return an object that needs to be</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">released by the caller but whose names are not consistent with</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Cocoa naming rules. The recommended fix to this is to rename the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">methods or functions, but this macro can be used to let the clang</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">static analyzer know of any exceptions that cannot be fixed. This</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">macro is ONLY to be used in exceptional circumstances, not to</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">annotate functions which conform to the Cocoa naming rules.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">--&gt; &#50500;&#47000;&#51032; NS_RETURNS_RETAINED &#47588;&#53356;&#47196;&#47484; ARC &#51648;&#50896;&#54872;&#44221;&#50640;&#49436; &#52980;&#54028;&#51068;&#54616;&#47732;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">retained&#46108; &#49345;&#53468;&#47196; &#48152;&#54872;&#46108; &#44061;&#52404;&#51032; release&#47484; &#52980;&#54028;&#51068;&#47084;&#44032; &#51088;&#46041;&#51004;&#47196;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">&#54644;&#51456;&#45796;. &#54616;&#51648;&#47564;, &#51060; &#47588;&#53356;&#47196;&#47484; &#49324;&#50857;&#54616;&#45716; &#44163; &#48372;&#45796;&#45716; "&#54632;&#49688;&#51032; &#51060;&#47492;"&#51012;</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">&#48148;&#44984;&#50612; &#51221;&#51201; &#48516;&#49437;&#44592;&#44032; &#51064;&#49885;&#54616;&#46020;&#47197; &#54616;&#45716; &#44163;&#51060;&#45796;. </span>
<span class="org-preprocessor">#if</span> __has_feature(attribute_ns_returns_retained)
<span class="org-preprocessor">#define</span> <span class="org-variable-name">NS_RETURNS_RETAINED</span> __attribute__((ns_returns_retained))
<span class="org-preprocessor">#else</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">NS_RETURNS_RETAINED</span>
<span class="org-preprocessor">#endif</span>

</pre>


<ul>
<li>위의 사항보다 더 중요한 것은 *함수의 이름*이다. :( *alloc, copy,
      init, mutableCopy, copy, 그리고 new 로 시작하는 족속(families)
      들은 자동으로 NS_RETURNS_RETAINED 속성이 붙는다*.

</li>
<li>이런 이유때문에 new 라는 이름으로 시작되는 프로퍼티명은 사용이
      불가하다. getter 속성을 사용해 속성의 getter를 바꾸어야 한다.
      아래 예 참조.




<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">Won't work:</span>
@property <span class="org-type">NSString</span> *<span class="org-variable-name">newTitle</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Works:</span>
@property (getter=theNewTitle) <span class="org-type">NSString</span> *<span class="org-variable-name">newTitle</span>;
</pre>

</li>
</ul>


</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 무명 class extension</h3>
<div class="outline-text-3" id="text-3-4">

<p>   unnamed class extension(*.m파일에 "@interface ClassName() ~ @end" 형식)
   pimpl idiom 같다. header에 드러나는 정보를 은닉하게 한다. 
</p>
</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> ObjC 에서 singleton 구현</h3>
<div class="outline-text-3" id="text-3-5">

<p>   클래스 메소드로 접근함수를 구현하고, 할당자 allocWithZone 을
   오버라이딩한다. alloc 을 오버라이딩 하지 않는 이유는 어차피 alloc
   은 내부적으로 allocWithZone 을 호출하기 때문이다. 한편 ARC를
   사용하게 되기 시작하면서 zone 을 사용한 할당개념은 사용되지 않는
   다는 얘기를 읽은 기억이 난다.
</p>



<pre class="src src-objc"><span class="org-keyword">@implementation</span> <span class="org-type">MyClass</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#54624;&#45817;&#51088; &#50724;&#48260;&#46972;&#51060;&#46377;&#51008; alloc, allocWithZone &#47784;&#46160; &#54644;&#50556; &#54616;&#51648;&#47564;, alloc &#46020;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#44208;&#44397; allocWithZone &#51012; &#54840;&#52636;&#54616;&#48064;&#47196; &#44536;&#45285; allocWithZone &#54616;&#45208;&#47564;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#50724;&#48260;&#46972;&#51060;&#46377; &#54616;&#47732; &#46108;&#45796;.</span>
-(<span class="org-type">id</span>) <span class="org-function-name">allocWithZone</span>:(<span class="org-type">NSZone</span> *)<span class="org-variable-name">zone</span>
{
    <span class="org-keyword">return</span> [<span class="org-keyword">self</span> theInstance];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Singleton &#51217;&#44540;&#54632;&#49688;</span>
-(<span class="org-type">id</span>) <span class="org-function-name">theInstance</span>
{
    <span class="org-keyword">static</span> <span class="org-type">MyClass</span> *<span class="org-variable-name">inst</span> = <span class="org-constant">nil</span>;
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>inst) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#50896;&#47000;&#45716; &#48512;&#47784;&#51032; alloc &#51012; &#54840;&#52636;&#54616;&#44592; &#49789;&#51648;&#47564;, &#44208;&#44397; alloc &#46020;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">allocWithZone &#51012; &#54840;&#52636;&#54616;&#48064;&#47196;, &#50500;&#50696; &#52376;&#51020;&#48512;&#53552; allocWithZone &#51012;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#54840;&#52636;&#54616;&#47732; &#45908; shortcut&#51060;&#45796;.</span>
        inst = [[<span class="org-keyword">super</span> allocWithZone:NULL] init];
    }
    <span class="org-keyword">return</span> inst;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#49892;&#51228; &#44061;&#52404; &#49373;&#49457;&#51088;</span>
-(<span class="org-type">id</span>) <span class="org-function-name">init</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">XCode 4.2 &#48512;&#53552; &#51060;&#47088;&#49885;&#51004;&#47196; &#48512;&#47784;&#51032; &#49373;&#49457;&#51088;&#47484; &#54840;&#52636;&#54620; &#44208;&#44284;&#47484; self&#50640;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#45824;&#51077;&#54616;&#46020;&#47197; &#54632;. &#44144;&#51032; idiom</span>
    <span class="org-keyword">self</span> = [<span class="org-keyword">super</span> init];
    <span class="org-keyword">if</span> (<span class="org-keyword">self</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#49892;&#51228; &#52488;&#44592;&#54868; &#47336;&#54004;&#51060; &#50668;&#44592;&#50640; &#50740;.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#47716;&#48260; &#44061;&#52404;&#46308;&#50640; &#45824;&#54620; &#54624;&#45817;/&#52488;&#44592;&#54868; &#47336;&#54004;&#51060; &#48372;&#53685; &#50668;&#44592;&#50640;...</span>
    }
    <span class="org-keyword">return</span> <span class="org-keyword">self</span>;
}

<span class="org-keyword">@end</span>

</pre>


</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Target-Action 은 누가 구현하고 있는가.</h3>
<div class="outline-text-3" id="text-3-6">

<p>   UIControl. 마침표! (참고로 NSObject &gt; UIResponder &gt; UIView &gt;
   UIControl 순으로 클래스상속이 이루어졌다).
</p></div>

</div>

<div id="outline-container-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> </h3>
<div class="outline-text-3" id="text-3-7">


</div>

</div>

<div id="outline-container-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> NSString 이 파일경로 문자열의 parse/manipulate 을 한다.</h3>
<div class="outline-text-3" id="text-3-8">




<pre class="example">+ pathWithComponents:
– pathComponents
– completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:
– fileSystemRepresentation
– getFileSystemRepresentation:maxLength:
– isAbsolutePath
– lastPathComponent
– pathExtension
– stringByAbbreviatingWithTildeInPath
– stringByAppendingPathComponent:
– stringByAppendingPathExtension:
– stringByDeletingLastPathComponent
– stringByDeletingPathExtension
– stringByExpandingTildeInPath
– stringByResolvingSymlinksInPath
– stringByStandardizingPath
– stringsByAppendingPaths:
</pre>

</div>

</div>

<div id="outline-container-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> NSString 이 하는 일의 종류</h3>
<div class="outline-text-3" id="text-3-9">


</div>

<div id="outline-container-3-9-1" class="outline-4">
<h4 id="sec-3-9-1"><span class="section-number-4">3.9.1</span> Creating and Initializing Strings</h4>
<div class="outline-text-4" id="text-3-9-1">




<pre class="example">+ string
– init
– initWithBytes:length:encoding:
– initWithBytesNoCopy:length:encoding:freeWhenDone:
– initWithCharacters:length:
– initWithCharactersNoCopy:length:freeWhenDone:
– initWithString:
– initWithCString:encoding:
– initWithUTF8String:
– initWithFormat:
– initWithFormat:arguments:
– initWithFormat:locale:
– initWithFormat:locale:arguments:
– initWithData:encoding:
+ stringWithFormat:
+ localizedStringWithFormat:
+ stringWithCharacters:length:
+ stringWithString:
+ stringWithCString:encoding:
+ stringWithUTF8String:
+ stringWithCString: Deprecated in iOS 2.0
+ stringWithCString:length: Deprecated in iOS 2.0
– initWithCString: Deprecated in iOS 2.0
– initWithCString:length: Deprecated in iOS 2.0
– initWithCStringNoCopy:length:freeWhenDone: Deprecated in iOS 2.0
</pre>


</div>

</div>

<div id="outline-container-3-9-2" class="outline-4">
<h4 id="sec-3-9-2"><span class="section-number-4">3.9.2</span> Creating and Initializing a String from a File</h4>
<div class="outline-text-4" id="text-3-9-2">




<pre class="example">+ stringWithContentsOfFile:encoding:error:
– initWithContentsOfFile:encoding:error:
+ stringWithContentsOfFile:usedEncoding:error:
– initWithContentsOfFile:usedEncoding:error:
+ stringWithContentsOfFile: Deprecated in iOS 2.0
– initWithContentsOfFile: Deprecated in iOS 2.0
</pre>


</div>

</div>

<div id="outline-container-3-9-3" class="outline-4">
<h4 id="sec-3-9-3"><span class="section-number-4">3.9.3</span> Creating and Initializing a String from an URL</h4>
<div class="outline-text-4" id="text-3-9-3">




<pre class="example">+ stringWithContentsOfURL:encoding:error:
– initWithContentsOfURL:encoding:error:
+ stringWithContentsOfURL:usedEncoding:error:
– initWithContentsOfURL:usedEncoding:error:
+ stringWithContentsOfURL: Deprecated in iOS 2.0
– initWithContentsOfURL: Deprecated in iOS 2.0
</pre>


</div>

</div>

<div id="outline-container-3-9-4" class="outline-4">
<h4 id="sec-3-9-4"><span class="section-number-4">3.9.4</span> Writing to a File or URL</h4>
<div class="outline-text-4" id="text-3-9-4">




<pre class="example">– writeToFile:atomically:encoding:error:
– writeToURL:atomically:encoding:error:
– writeToFile:atomically: Deprecated in iOS 2.0
– writeToURL:atomically: Deprecated in iOS 2.0
</pre>


</div>

</div>

<div id="outline-container-3-9-5" class="outline-4">
<h4 id="sec-3-9-5"><span class="section-number-4">3.9.5</span> Getting a String’s Length</h4>
<div class="outline-text-4" id="text-3-9-5">




<pre class="example">– length
– lengthOfBytesUsingEncoding:
– maximumLengthOfBytesUsingEncoding:
</pre>


</div>

</div>

<div id="outline-container-3-9-6" class="outline-4">
<h4 id="sec-3-9-6"><span class="section-number-4">3.9.6</span> Getting Characters and Bytes</h4>
<div class="outline-text-4" id="text-3-9-6">




<pre class="example">– characterAtIndex:
– getCharacters:range:
– getBytes:maxLength:usedLength:encoding:options:range:remainingRange:
– getCharacters: Deprecated in iOS 4.0
</pre>


</div>

</div>

<div id="outline-container-3-9-7" class="outline-4">
<h4 id="sec-3-9-7"><span class="section-number-4">3.9.7</span> Getting C Strings</h4>
<div class="outline-text-4" id="text-3-9-7">




<pre class="example">– cStringUsingEncoding:
– getCString:maxLength:encoding:
– UTF8String
– cString Deprecated in iOS 2.0
– cStringLength Deprecated in iOS 2.0
– getCString: Deprecated in iOS 2.0
– getCString:maxLength: Deprecated in iOS 2.0
– getCString:maxLength:range:remainingRange: Deprecated in iOS 2.0
– lossyCString Deprecated in iOS 2.0
</pre>


</div>

</div>

<div id="outline-container-3-9-8" class="outline-4">
<h4 id="sec-3-9-8"><span class="section-number-4">3.9.8</span> Combining Strings</h4>
<div class="outline-text-4" id="text-3-9-8">




<pre class="example">– stringByAppendingFormat:
– stringByAppendingString:
– stringByPaddingToLength:withString:startingAtIndex:
</pre>


</div>

</div>

<div id="outline-container-3-9-9" class="outline-4">
<h4 id="sec-3-9-9"><span class="section-number-4">3.9.9</span> Dividing Strings</h4>
<div class="outline-text-4" id="text-3-9-9">




<pre class="example">– componentsSeparatedByString:
– componentsSeparatedByCharactersInSet:
– stringByTrimmingCharactersInSet:
– substringFromIndex:
– substringWithRange:
– substringToIndex:
</pre>


</div>

</div>

<div id="outline-container-3-9-10" class="outline-4">
<h4 id="sec-3-9-10"><span class="section-number-4">3.9.10</span> Finding Characters and Substrings</h4>
<div class="outline-text-4" id="text-3-9-10">




<pre class="example">– rangeOfCharacterFromSet:
– rangeOfCharacterFromSet:options:
– rangeOfCharacterFromSet:options:range:
– rangeOfString:
– rangeOfString:options:
– rangeOfString:options:range:
– rangeOfString:options:range:locale:
– enumerateLinesUsingBlock:
– enumerateSubstringsInRange:options:usingBlock:
</pre>


</div>

</div>

<div id="outline-container-3-9-11" class="outline-4">
<h4 id="sec-3-9-11"><span class="section-number-4">3.9.11</span> Replacing Substrings</h4>
<div class="outline-text-4" id="text-3-9-11">




<pre class="example">– stringByReplacingOccurrencesOfString:withString:
– stringByReplacingOccurrencesOfString:withString:options:range:
– stringByReplacingCharactersInRange:withString:
</pre>


</div>

</div>

<div id="outline-container-3-9-12" class="outline-4">
<h4 id="sec-3-9-12"><span class="section-number-4">3.9.12</span> Determining Line and Paragraph Ranges</h4>
<div class="outline-text-4" id="text-3-9-12">




<pre class="example">– getLineStart:end:contentsEnd:forRange:
– lineRangeForRange:
– getParagraphStart:end:contentsEnd:forRange:
– paragraphRangeForRange:
</pre>


</div>

</div>

<div id="outline-container-3-9-13" class="outline-4">
<h4 id="sec-3-9-13"><span class="section-number-4">3.9.13</span> Determining Composed Character Sequences</h4>
<div class="outline-text-4" id="text-3-9-13">




<pre class="example">– rangeOfComposedCharacterSequenceAtIndex:
– rangeOfComposedCharacterSequencesForRange:
</pre>


</div>

</div>

<div id="outline-container-3-9-14" class="outline-4">
<h4 id="sec-3-9-14"><span class="section-number-4">3.9.14</span> Converting String Contents Into a Property List</h4>
<div class="outline-text-4" id="text-3-9-14">




<pre class="example">– propertyList
– propertyListFromStringsFileFormat
</pre>


</div>

</div>

<div id="outline-container-3-9-15" class="outline-4">
<h4 id="sec-3-9-15"><span class="section-number-4">3.9.15</span> Identifying and Comparing Strings</h4>
<div class="outline-text-4" id="text-3-9-15">




<pre class="example">– caseInsensitiveCompare:
– localizedCaseInsensitiveCompare:
– compare:
– localizedCompare:
– compare:options:
– compare:options:range:
– compare:options:range:locale:
– localizedStandardCompare:
– hasPrefix:
– hasSuffix:
– isEqualToString:
– hash
</pre>


</div>

</div>

<div id="outline-container-3-9-16" class="outline-4">
<h4 id="sec-3-9-16"><span class="section-number-4">3.9.16</span> Folding Strings</h4>
<div class="outline-text-4" id="text-3-9-16">




<pre class="example">– stringByFoldingWithOptions:locale:
</pre>


</div>

</div>

<div id="outline-container-3-9-17" class="outline-4">
<h4 id="sec-3-9-17"><span class="section-number-4">3.9.17</span> Getting a Shared Prefix</h4>
<div class="outline-text-4" id="text-3-9-17">




<pre class="example">– commonPrefixWithString:options:
</pre>


</div>

</div>

<div id="outline-container-3-9-18" class="outline-4">
<h4 id="sec-3-9-18"><span class="section-number-4">3.9.18</span> Changing Case</h4>
<div class="outline-text-4" id="text-3-9-18">




<pre class="example">– capitalizedString
– capitalizedStringWithLocale:
– lowercaseString
– lowercaseStringWithLocale:
– uppercaseString
– uppercaseStringWithLocale:
</pre>


</div>

</div>

<div id="outline-container-3-9-19" class="outline-4">
<h4 id="sec-3-9-19"><span class="section-number-4">3.9.19</span> Getting Strings with Mapping</h4>
<div class="outline-text-4" id="text-3-9-19">




<pre class="example">– decomposedStringWithCanonicalMapping
– decomposedStringWithCompatibilityMapping
– precomposedStringWithCanonicalMapping
– precomposedStringWithCompatibilityMapping
</pre>


</div>

</div>

<div id="outline-container-3-9-20" class="outline-4">
<h4 id="sec-3-9-20"><span class="section-number-4">3.9.20</span> Getting Numeric Values</h4>
<div class="outline-text-4" id="text-3-9-20">




<pre class="example">– doubleValue
– floatValue
– intValue
– integerValue
– longLongValue
– boolValue
</pre>


</div>

</div>

<div id="outline-container-3-9-21" class="outline-4">
<h4 id="sec-3-9-21"><span class="section-number-4">3.9.21</span> Working with Encodings</h4>
<div class="outline-text-4" id="text-3-9-21">




<pre class="example">+ availableStringEncodings
+ defaultCStringEncoding
+ localizedNameOfStringEncoding:
– canBeConvertedToEncoding:
– dataUsingEncoding:
– dataUsingEncoding:allowLossyConversion:
– description
– fastestEncoding
– smallestEncoding
</pre>


</div>

</div>

<div id="outline-container-3-9-22" class="outline-4">
<h4 id="sec-3-9-22"><span class="section-number-4">3.9.22</span> Working with Paths</h4>
<div class="outline-text-4" id="text-3-9-22">




<pre class="example">+ pathWithComponents:
– pathComponents
– completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:
– fileSystemRepresentation
– getFileSystemRepresentation:maxLength:
– isAbsolutePath
– lastPathComponent
– pathExtension
– stringByAbbreviatingWithTildeInPath
– stringByAppendingPathComponent:
– stringByAppendingPathExtension:
– stringByDeletingLastPathComponent
– stringByDeletingPathExtension
– stringByExpandingTildeInPath
– stringByResolvingSymlinksInPath
– stringByStandardizingPath
– stringsByAppendingPaths:
</pre>


</div>

</div>

<div id="outline-container-3-9-23" class="outline-4">
<h4 id="sec-3-9-23"><span class="section-number-4">3.9.23</span> Working with URLs</h4>
<div class="outline-text-4" id="text-3-9-23">




<pre class="example">– stringByAddingPercentEscapesUsingEncoding:
– stringByReplacingPercentEscapesUsingEncoding:
</pre>


</div>

</div>

<div id="outline-container-3-9-24" class="outline-4">
<h4 id="sec-3-9-24"><span class="section-number-4">3.9.24</span> Linguistic Tagging and Analysis</h4>
<div class="outline-text-4" id="text-3-9-24">




<pre class="example">– enumerateLinguisticTagsInRange:scheme:options:orthography:usingBlock:
– linguisticTagsInRange:scheme:options:orthography:tokenRanges:   
</pre>


</div>
</div>

</div>

<div id="outline-container-3-10" class="outline-3">
<h3 id="sec-3-10"><span class="section-number-3">3.10</span> Informal Protocol</h3>
<div class="outline-text-3" id="text-3-10">

<p>   <del>@protocol 의 메소드 중 @optional 로 지정된 메소드로 구성된  프로토콜을 말한단다</del> <a href="http://stackoverflow.com/questions/2010058/informal-protocol-in-objective-c">여기</a> 참조. 잘못이해함. 사실은 ObjC 2.0 에서
 도입된 @protocol 키워드를 사용하지 않고 구현한 이전 방식의 protocol 을
 말함. 이전의 protocol 역할을 하던 NSObject의 class extension 을 말함.
</p></div>

</div>

<div id="outline-container-3-11" class="outline-3">
<h3 id="sec-3-11"><span class="section-number-3">3.11</span> CoreGraphics 에 Path 의 HitTesting</h3>
<div class="outline-text-3" id="text-3-11">

<p>   우선 iOS5 에서 추가된 CGPathCreateCopyByStrokingPath 함수를 써서
   HitTesting을 위한 스트로크 패스를 만들 수 있음이 힌트. <a href="http://oleb.net/blog/2012/02/cgpath-hit-testing/">여기</a> 를
   보면 예제가 있음.
</p>
<p>
   한편. 이전 iOS에는 이 함수가 없는데 그건 <a href="http://stackoverflow.com/questions/7776931/cgpathcreatecopybystrokingpath-equivalent-on-ios4">여기</a> 를 보면 이전버젼을
   위한 CGPathCreateCopyByStrokingPath_For_All_iOS() 함수가 있다. 
</p>
</div>

</div>

<div id="outline-container-3-12" class="outline-3">
<h3 id="sec-3-12"><span class="section-number-3">3.12</span> Qt의 "Fit" 또는 "ResizePolicy" 가 Quartz에서는 "Contents Gravity"</h3>
<div class="outline-text-3" id="text-3-12">

<p>   희한하게 이렇게 용어가 틀리냐&hellip;
   topLeft, top, &hellip;, center, &hellip;, resizeAspect, resizeAspectFill&hellip;.
</p></div>

</div>

<div id="outline-container-3-13" class="outline-3">
<h3 id="sec-3-13"><span class="section-number-3">3.13</span> UIImage 의 imageNamed: 메시지는 cached 된 이미지를 반환한다.</h3>
<div class="outline-text-3" id="text-3-13">

<p>   맨 처음만 디스크에서 읽어오고, 그 다음 부터는 캐시된 이미지
   객체를 반환한다.
</p></div>

</div>

<div id="outline-container-3-14" class="outline-3">
<h3 id="sec-3-14"><span class="section-number-3">3.14</span> CGContextRef(Graphics Context - "GD")를 얻는 방법</h3>
<div class="outline-text-3" id="text-3-14">

<ul>
<li>UIGraphicsGetCurrentContext() : drawXXX 메소드에서는 이미 GD 가
     존재한다. 그런 경우에는 기존의 context 만 얻어오면 된다.
</li>
<li>UIGraphicsBeginImageContextWithOptions() 또는
     UIGraphicsBeginImageContext() 을 사용해서 비트맵 기반의 GD 를
     만든다. 



<pre class="src src-objc"><span class="org-comment-delimiter">// </span><span class="org-comment">&#48708;&#53944;&#47605; GD&#49373;&#49457;</span>
UIGraphicsBeginImageContextWithOptions(
        size, <span class="org-comment-delimiter">// </span><span class="org-comment">CGSize size</span>
        <span class="org-constant">NO</span>,   <span class="org-comment-delimiter">// </span><span class="org-comment">BOOL opaque</span>
        1.0   <span class="org-comment-delimiter">// </span><span class="org-comment">CGFloat scale</span>
    );

<span class="org-comment-delimiter">// </span><span class="org-comment">&#50668;&#44592;&#49436; Drawing&#51089;&#50629; &#49688;&#54665;</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#44536;&#47140;&#51652; &#44208;&#44284;&#47932;&#51012; &#51060;&#48120;&#51648;&#47196; &#50619;&#51020;.</span>
<span class="org-type">UIImage</span> *<span class="org-variable-name">result</span> = UIGraphicsGetImageFromCurrentImageContext();

<span class="org-comment-delimiter">// </span><span class="org-comment">&#48708;&#53944;&#47605;GD &#51228;&#44144;</span>
UIGraphicsEndImageContext();
</pre>

</li>
</ul>


</div>

</div>

<div id="outline-container-3-15" class="outline-3">
<h3 id="sec-3-15"><span class="section-number-3">3.15</span> 어떤 클래스의 생성자 찾는 방법 - 그 클래스에 없는 생성자도 있네?!</h3>
<div class="outline-text-3" id="text-3-15">

<p>   CABasicAnimation 클래스의 경우, 문서에 보면, 다음과 같이 나와 있다.
</p>


<pre class="example">CABasicAnimation provides basic, single-keyframe animation
capabilities for a layer property. You create an instance of
CABasicAnimation using the inherited animationWithKeyPath: method,
specifying the key path of the property to be animated in the
render tree.
</pre>

<p>
   즉, +animationWithKeyPath: 클래스 메시지인데, 이건 사실, 부모
   클래스인 CAPropertyAnimation 에 있는 메시지 이다. :( 근데. 이걸
   써서 만들라네&hellip;.헐..이상한 Objc
</p>
</div>

</div>

<div id="outline-container-3-16" class="outline-3">
<h3 id="sec-3-16"><span class="section-number-3">3.16</span> 어떤 Delegate 는 문서에는 없어도 존재하네?!?!</h3>
<div class="outline-text-3" id="text-3-16">

<p>   CAAnimation 의 경우 <code>-(id)delegate</code> 인스턴스 변수가 존재하고,
   거기에는 뭔가 Delegate에 상응하는 타입이 있을 걸로 생각했는데&hellip;
   CAAnimationDelegate 라는 항목이 XCODE 문서에 없다.
</p>
<p>
   그래서 QuartzCore.framework/Headers/CAAnimation.h 를
   열어보았더니.. 거기에 informal protocol 이 정의되어 있었다.
</p>



<pre class="src src-objc"><span class="org-comment-delimiter">/* </span><span class="org-comment">Delegate methods for CAAnimation. */</span>

<span class="org-keyword">@interface</span> <span class="org-type">NSObject</span> (<span class="org-type">CAAnimationDelegate</span>)

<span class="org-comment-delimiter">/* </span><span class="org-comment">Called when the animation begins its active duration. */</span>

- (<span class="org-type">void</span>)<span class="org-function-name">animationDidStart</span>:(<span class="org-type">CAAnimation</span> *)<span class="org-variable-name">anim</span>;

<span class="org-comment-delimiter">/* </span><span class="org-comment">Called when the animation either completes its active duration or</span>
<span class="org-comment"> * is removed from the object it is attached to (i.e. the layer). 'flag'</span>
<span class="org-comment"> * is true if the animation reached the end of its active duration</span>
<span class="org-comment"> * without being removed. */</span>

- (<span class="org-type">void</span>)<span class="org-function-name">animationDidStop</span>:(<span class="org-type">CAAnimation</span> *)<span class="org-variable-name">anim</span> <span class="org-function-name">finished</span>:(<span class="org-type">BOOL</span>)<span class="org-variable-name">flag</span>;

<span class="org-keyword">@end</span>
</pre>


<p>
   그런데, 다시 위의 함수를 XCODE 문서에서 찾아보니&hellip;
</p>
<p>
   세상에나.. CAAnimation Class Reference의 Delegate Methods라는
   항목에 설명이 되어 있었다. 이런식으로 구성되어 있군.
</p>
</div>

</div>

<div id="outline-container-3-17" class="outline-3">
<h3 id="sec-3-17"><span class="section-number-3">3.17</span> UIAlertView : 간단한 메시지 상자.</h3>
<div class="outline-text-3" id="text-3-17">

<p>   아래와 같이 하여 화면에 띄운다. 버튼을 2개 이상 만들때는
   otherButtonTitles 에 nil 로 끝나는 문자열 배열을 넣어준다.
   일단 표시한 다음 사용자가 버튼을 누르면 delgate 로(
</p>


<pre class="src src-objc">-(<span class="org-type">void</span>)<span class="org-function-name">testAlertView</span>
{
    <span class="org-type">UIAlertView</span> *<span class="org-variable-name">av</span> = [[<span class="org-type">UIAlertView</span> alloc] initWithTitle:@<span class="org-string">"&#47700;&#49884;&#51648; &#49345;&#51088; &#53440;&#51060;&#53952;"</span>
                                                 message:@<span class="org-string">"&#47700;&#49884;&#51648; &#49345;&#51088;&#50640; &#54364;&#49884;&#46104;&#45716; &#47928;&#51088;&#50676;"</span>
                                           <span class="org-comment-delimiter">// </span><span class="org-comment">&#45236; &#49828;&#49828;&#47196;&#50640;&#44172; &#53685;&#51648;&#50836;&#52397;</span>
                                                delegate:<span class="org-keyword">self</span>
                                           <span class="org-comment-delimiter">// </span><span class="org-comment">&#52395;&#48264;&#51704; &#48260;&#53948;&#51060; "cancel" &#48260;&#53948;&#51076;. &#54616;&#51648;&#47564;,</span>
                                           <span class="org-comment-delimiter">// </span><span class="org-comment">&#44845; "&#52712;&#49548;"&#51032; &#44592;&#45733;&#51068; &#54596;&#50836;&#45716; &#50630;&#51020;.</span>
                                       cancelButtonTitle:@<span class="org-string">"&#54869;&#51064;"</span>
                                       otherButtonTitles:<span class="org-keyword">self</span>];
    [av show];
}

<span class="org-preprocessor">#pragma</span> mark -
<span class="org-preprocessor">#pragma</span> mark - UIAlertView delegate

-(<span class="org-type">void</span>)<span class="org-function-name">alertView</span>:(<span class="org-type">UIAlertView</span> *)<span class="org-variable-name">alertView</span> <span class="org-function-name">willDismissWithButtonIndex</span>:(<span class="org-type">NSInteger</span> *)<span class="org-variable-name">buttonIndex</span>
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">buttonIndex &#44032; 0 &#51060;&#47732; cancelButton(&#44032;&#51109; &#48152;&#51677;&#51060;&#45716; &#46356;&#54260;&#53944; &#48260;&#53948;)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">AlertView&#51032; &#48260;&#53948;&#51060; &#45580;&#47532;&#47732; &#45803;&#55176;&#47732;&#49436; delegate&#50640; &#51060; &#47700;&#49884;&#51648;&#47484; &#51204;&#49569;&#54632;.</span>
}

</pre>

<p>
   iOS 4.0 이후에는 어플이 백그라운드로 빠져도 화면에 그대로 alert
   view 가 있기 때문에, 강제로 닫기 위해서는 
   dismissWithClickedButtonIndex:animated: 메시지를 날려서 닫아 둔다.
</p></div>

</div>

<div id="outline-container-3-18" class="outline-3">
<h3 id="sec-3-18"><span class="section-number-3">3.18</span> 유용한 UIControl 샘플 예제 : "UICatalog"</h3>
<div class="outline-text-3" id="text-3-18">

<p>   여러가지 UIControl 들의 실 사용예가 있다. 한번 주욱 만들어 보는
   연습을 하면 더 감이 올 것 같다.
</p></div>

</div>

<div id="outline-container-3-19" class="outline-3">
<h3 id="sec-3-19"><span class="section-number-3">3.19</span> #pragma - some-useful-information-for-xcode-navigation-bar</h3>
<div class="outline-text-3" id="text-3-19">

<p>   코드 중간 중간에
</p>


<pre class="src src-objc"><span class="org-preprocessor">#pragma</span> mark - Table view data source
- (<span class="org-type">NSInteger</span>)<span class="org-function-name">numberOfSectionsInTableView</span>:(<span class="org-type">UITableView</span> *)<span class="org-variable-name">tableView</span>
{
<span class="org-comment-delimiter">// </span><span class="org-comment">#warning Potentially incomplete method implementation.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return the number of sections.</span>
    <span class="org-keyword">return</span> 0;
}
</pre>

<p>
   이렇게 하면 XCODE 네비게이션 에서 알아보기 쉽게 함수들을 구분지어
   표기해 준다.(한번 보면 암)
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Apple 공식문서 코스워크 순서</h2>
<div class="outline-text-2" id="text-4">

<p>  <a href="http://pole2win.tistory.com/91">Pole to win 블로그에서 얻은 신공</a>
</p>
</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 우선 읽고 볼 문서</h3>
<div class="outline-text-3" id="text-4-1">

<ul>
<li>The Objective-C Programming Guide
</li>
<li>Memory Management Programming Guide
</li>
<li>iOS Application Programming Guide
</li>
<li>iOS Development Guide
</li>
<li>Cocoa Fundamentals Guide
</li>
<li>Resource Programming Guide
</li>
<li>View Programming Guide for iOS
</li>
<li>View Controller Programming Guide for iOS
</li>
<li>Event-Handling Guide for iOS
</li>
<li>Key-Value Coding Programming Guide
</li>
<li>Key-Value Observing Programming Guide
</li>
<li>Xcode Project Management Guide
</li>
</ul>


</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 결국 읽어야 할 문서</h3>
<div class="outline-text-3" id="text-4-2">

<ul>
<li>Table View Programming Guide for iOS
</li>
<li>Scroll View Programming Guide
</li>
<li>Information Property List Key Reference
</li>
<li>Drawing and Printing Guide for iOS / Core Graphics Framework Reference
</li>
<li>Core Animation Programming Guide / Core Animation Cookbook
</li>
<li>NSInvocation Class Reference
</li>
<li>SDK Compatibility Guide
</li>
<li>Settings Application Schema Reference
</li>
<li>Concurrency Programming Guide
</li>
<li>Interface Builder User Guide
</li>
<li>Instruments User Guide, Shark User Guide
</li>
<li>Secure Coding Guide
</li>
<li>Internationalization Programming Topics
</li>
<li>Cocoa Performance Guidelines
</li>
<li>Error Handling Programming Guide, Exception Programming Topics
</li>
<li>Property List Programming Guide / User Defaults Programming Topics
</li>
</ul>


</div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> 필요하면 찾아볼 문서 (중요)&gt;</h3>
<div class="outline-text-3" id="text-4-3">

<ul>
<li>Core Data Programming Guide
</li>
<li>CFNetwork Programming Guide / CFNetwork Framework Reference
</li>
<li>Device Features Programming Guide
</li>
<li>Location Awareness Programming Guide
</li>
<li>Text, Web, and Editing Programming Guide for iOS
</li>
<li>Camera Programming Topics for iOS
</li>
<li>Keychain Services Programming Guide
</li>
<li>Event Kit Programming Guide (calendar) / Address Book Programming Guide for iOS
</li>
<li>OpenGL ES Programming Guide for iOS
</li>
<li>Quartz 2D Programming Guide
</li>
<li>Core Audio / Audio Queue Services Programming Guide / Audio Session Programming Guide
</li>
<li>Undo Architecture
</li>
<li>File-system performance guidelines
</li>
</ul>


</div>

</div>

<div id="outline-container-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 생각나면 한번쯤 읽어 볼 문서</h3>
<div class="outline-text-3" id="text-4-4">

<ul>
<li>iOS Human Interface Guidelines
</li>
<li>Apple Human Interface Guidelines
</li>
<li>Design Patterns: Elements of Reusable Object-Oriented Software
</li>
<li>Bundle Programming Guide
</li>
<li>Coding guideline for Cocoa (naming guideline)
</li>
</ul>


</div>

</div>

<div id="outline-container-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> 필요하면 찾아 볼 문서 (덜 중요)</h3>
<div class="outline-text-3" id="text-4-5">

<ul>
<li>System Messaging Programming Topics in iOS
</li>
<li>Core Telephony Framework Reference
</li>
<li>Stream Programming Guide
</li>
<li>URL Loading System Programming Guide / Apple URL Scheme References
</li>
<li>Multimedia Programming Guide
</li>
<li>Archives and Serializations Programming Guide
</li>
<li>External Accessory Programming Guide
</li>
<li>Timer Programming Topics
</li>
</ul>


</div>

</div>

<div id="outline-container-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> 가장 나중에 읽을 문서 (Mac OS X와 겹치는 것이 많음)</h3>
<div class="outline-text-3" id="text-4-6">

<ul>
<li>Cocoa Event-Handling Guide / How Cocoa Applications Handle Apple Events
</li>
<li>Foundation Framework Reference
</li>
<li>Cocoa Drawing Guide (View hierarchy)
</li>
<li>Threading Programming Guide
</li>
<li>Objective-C Runtime Programming Guide
</li>
<li>Window Programming Guide
</li>
<li>Model Object Implementation Guide
</li>
<li>Code Loading Programming Topics
</li>
<li>Preferences Utilities Reference (CF)
</li>
<li>Distributed Objects Programming Topics
</li>
<li>Cocoa Scripting Guide
</li>
<li>Document-Based Applications Overview
</li>
</ul>

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-03-21T20:32+0900</p>
<p class="author">Author: Joonhwan</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
