#+TITLE:LearnDotNet

* .NetBookZero
** 1장 ~ 11장
*** static readonly/const 그리고, c++에서의 local static 변수

   	정적 상수 멤버(static readonly)는 런타임에,
   	그냥 상수 변수(const)는 컴파일시에 설정된다.

   	#+begin_src csharp
      class MyClass
      {
          // strDelimter는 런타임에 세팅된다.
          static readonly strDelimiter = ",";
          // strDelimter2 는 컴파일 타임에 세팅된다.
          const strDelimiter2 = ",";
      }
   	#+end_src

   	위 두 가지는 실제로는 큰차이가 없다. 하지만 c++에서

   	#+begin_src c++
      class MyClass
      {
      public:
          void MyFunc()
          {
              static int callCounter = 0;
              ++callCounter;
          }
      };
   	#+end_src

   	하던 식으로 사용하던 *로컬정적변수는 C# 에서는 사용 불가*.

*** void Do(ref int i) 와 void Do(out int i) 의 차이점

   - out 을 쓰면 인자를 넘겨줄때도 Do(out myValue) 이런식으로 해야
     한다.
   - ref로 넘겨줄 때는 *반드시 초기화가 되어 있어야 한다*.
   - out으로 넘겨줄 때는 *초기화 되어 있지 않아도 된다*.
	 
*** void Do(ref {ValueType} var) 와 void Do({RefType} var) 

   - ValueType은 ref 로 명시해야만 pass-by-ref.
   - RefType은 원래 pass-by-ref. 단, 원래의 참조값 자체에 대한 참조를
     위해서는 ref 를 해야 함. 아래 예 참조
	 
	 #+begin_src csharp
       class MyClass
       {
           public static void AllocArray(int [] myArray)
           {
               myArray = new int [] { 1000, 2000, 3000 };
           }
           public static void AllocArrayRef(ref int [] myArray)
           {
               myArray = new int [] { 1000, 2000, 3000 };
           }
       }
	 #+end_src
	 
	 위 경우, AllocArray()로 넘겨진 myArray의 원래 참조는 바뀌지
     않는다. AllocArrayRef()의 경우에는 호출측의 myArray가 바뀐다.
     *C++에서의 Double Pointer개념*.

*** Unified type system : 모든 것은 object 의 파생 클래스다.

   	int 나 double 같은 primitive type 까지 포함해서....

*** .net 에서 라이브러리에 해당하는 "어셈블리"가  *.dll.

   	csc /target:library acme.cs    이런식으로 생성한다.
   	한편 /target:module 하면 생기는 건 모듈. 이건 나중에 어셈블리에
   	합칠 수 있다. 어셈블리=동적라이브러리, 모듈=정적라이브러리 라고
   	정리해 두자.

*** C# 에서는 "클래스 정적 const 배열을 만들 수가 없다."

   	static readonly int [] myArray = { 0 , 1, 2 ,3 };

   	이렇게 선언했다고 하더라도, 결국

   	#myArray[0] = 19# 이런식으로 변경하는게 가능하기 때문이다.

   	이걸 막으려면, 외부에서 접근하는 방식을 막아야 한다. 

*** 로컬에서 생성한 상수배열의 성능
   	상수배열은 new {Type} 하지 않고, 특정 함수내에 그냥 정의하는 것.

   	int [] myNumbers = { 0, 1, 2, 3, 4};

   	정적으로 선언/정의한 상수배열은 아래와 같이..

   	static [readonly] int [] myNumbers = { 0, 1, 2, 3, 4 }

   	정적 버젼이 단 1번만 초기화 되므로(아마 런타임시에), 훨씬 빠르지만,
   	상수배열을 로컬에 선언한다고 해서 그게 그리 큰 문제가 되지 는
   	않는다(최적화가 어느정도 이루어 진다?!)

** 12장. 예외처리
*** 어떤 예외를 catch 할 건가.
   이를 테면, Console.ReadLine() 은 IOException,
   ArgumentOutOfRangeException, OutOfMemoryException 의 3가지 예외를
   뿜을 수 있는데,.... 극도로 부정적인 사람은 모든 ReadLine 호출시
   마다, try/catch 로 감싸고, 이 세가지 예외처리를 넣을 수 도 있겠다.
   하지만, 이 경우, 다른 2가지 예외와는 달리 OutOfMemoryException
   정도는 언제든지 발생할 수 있다는 생각 정도는 하고 코딩을 하는게
   유용할 거다.

*** Double.TryParse 와 Double.Parse
   전자는 리턴값으로 오류발생을, 후자는 예외를 throw 하여 오류처리를
   해야 한다. 이런식으로 .net 에는 동일한 동작을 예외throw 유무가 있는
   버젼도 있다.

** 13장. Class ,Struct, 그리고 Object

   - struct는 value type, class 는 reference type. *struct는 자신으로
     부터 다른 타입을 파생시킬 수 없다*.

   - struct MyData {...} 는 ~MyData myData;~ 하면, 모든 멤버가
     uninit'ed 상태로 stack에 생성. 접근하는 코드가 보이면 컴파일
     오류. ~MyData myData = new MyData();~ 하면 *마찬가지로 stack에
     생성(new했어도)*. 하지만 이 경우, 모든 멤버가 zero로 초기화.

   - class MyData {...} 는 ~MyData myData;~ 하면, stack에 초기화 되지
     않은 reference 가 생김. 모든 멤버에 대한 접근 코드는 컴파일 오류.
     반드시 ~myData = new MyData();~ 한 다음 접근해야 컴파일 오류안남.
     new 하는 순간 모든 멤버가 0 으로 초기화된 상태로 heap에 생성. 한편
     ~MyData myData = null~ 로 null 초기화 하면, 컴파일 오류는 발생하지
     않으나(경고만 뜸), 프로그램 실행시 멤버 접근 코드는 exception을
     발생시킴.

   - 함수인자로 넘길때, struct건 class건 'ref' 를 인자type 앞에
     명시하지 않으면 무조건 pass-by-value. 하지만, reference type은
     reference value(즉, 주소값)이 value이므로 마치 reference가
     넘어가는 것 같은 느낌을 받게 될 뿐이다. reference가 가리키는
     주소의 내용은 바꿀 수 있지만, reference값 자체는 바꿀 수 없다.
     그럴려면, 'ref'를 명시해야 한다.

   - ~struct MyData {...}~ 인 경우, ~MyData [] myDataArray = new
     MyData[27]~ 은 27개의 sizeof(MyData) 영역이 Heap 에 할당되고,
     stack에는 그 heap영역을 가리키는 sizeof(pointer)크기 만큼이
     할당된다. 그리고, 그 heap 영역의 모든 값이 zero out된다(멤버의
     값이 0 이 된다).

   - ~class MyData {...}~ 인 경우, 위와 동일하게 배열을 할당하면,
     stack에는 동일한 sizeof(pointer) 크기 만큼이 할당되지만, heap에는
     27개의 sizeof(pointer) 공간이 할당되며, 각각의 pointer값은 null 
	 이 된다. 이를 제대로 할당하기 위해서는 27개의 모든 요소에 대해서
     ~myDataArray[i] = new MyData()~ 이런 식으로 new 해 주어야 하고,

** 14장. 인스턴스 메쏘드
** 15장. 생성자

   1. 생성자에는 2가지 종류가 있다. *Instance Constructor(인스턴스
      생성자)* 와 *Class Constructor(클래스 생성자)*. 아무말 없이
      사용하면 인스턴스 생성자라고 알아두면 될 듯. 아래 5~6 항목 참조

   2. struct의 소멸자는 /parameterless/ 할 수가 없다(/value type/
      자체가 배열등으로 만들어질 때 초기화시 속도를 빨리하게끔 하기
      위해 만든 제약사항이란다. 잘 이해는 안가지만). 17장에 나온
      힌트인데, *모든 값을 zero로 만드는 struct의 parameterless
      생성자로 인 zero가 아닌 값으로 초기화하는 방법은 속성을 개조하여
      원래값에 오프셋을 주도록 하는 방법이 있겠다*

   4. class 의 생성자는 /parameterless/ 할 수 있다.

   5. 생성자를 명시적으로 만들지 않으면, struct의 경우 모든 인자를
      /zero out/ 하는 생성자를 컴파일러가 만들어준다.

   6. class 의 /non parameterless/ 생성자를 1개라도 만들면, 컴파일러
      자동으로 생성해 주던 기본 /parameterless/ 생성자는 만들어지지
      않더라. (언어사양 $10.4.4 "If a class contains no instance
      constructor declarations, a default instance constructor is
      automatically provided." --> 이 말의 의미는 인스턴스 생성자가
      1개라도 있으면, 디폴트로 만들어지던 생성자는 자동으로 제공되지
      않는다가 된다.)

   7. struct 의 경우, class 와는 달리 /non-parametereless/ 생성자를
      만들었는지 여부와 상관없이 컴파일러가 항상 디폴트 parameterless
      생성자를 제공해 준다. 오히려 사용자가 정의한 /parameterless/
      생성자를 만들 수가 아예 없다.

   8. 인스턴스 생성자에서 인스턴스 메쏘드를 호출하는 경우에는 극도로
      주의를 해야 한다. 특정 필드의 값이 아직 정상적으로 설정되지
      않았을 수 있기 때문이다. 이런 이유때문에 인스턴스 생성자에서는
      가급적 클래스 메쏘드(정적 메쏘드)를 사용하도록 유도(?)하는 것
      같다. 이렇게 해서 *여러 생성자가 동일한 루틴을 공유하도록 하는
      것이 가능하다*

   9. 위 7번에서 정적 메쏘드를 사용하는 방법 말고 루틴공유 방법으로
      /Constructor Initializer/ 가 있다.

	  #+begin_src csharp
        public class Date
        {
            public Date(int year, int month, int day)
            {
                this.year = year;
                this.month = month;
                this.day = day;
            }
            public Date(int year)
                : this (year, 1, 1) // constructor initializer
            {
            }
        }
	  #+end_src

** 16장. 등가 개념(Concept of Equality)

   - struct 는 디폴트로 값비교를 bitwise equality을 하지만, RefType인
     class 는 레퍼런스가 같은지 비교한단다. (C에서 포인터 등가 비교를 생각).

   - =public virtual bool Equals(object obj)= 이런식으로 등가비교
     연산자를 재정의 할 수 있다. 하지만, 이 경우 GetHashCode() 를
     구현해야 한다.

   - operator=() 연산자는 public static 으로 클래스 메쏘드가 되어야 한단다.

   - 등가비교는 항상 조심해야 할 것 같은 느낌이다.

** 17장. 필드와 프로퍼티
*** 접근가능자가 5개 = public + private + (protected + internal + internal protected)

   - 멤버변수를 정의할 때, public 을 타입 앞에 붙이지 않으면 디폴트가
     private 이다.

*** readonly : 이건 오직 field에만 쓸 수 있다.

   - 어떤 멤버변수의 값을 외부에서 기록하지 못하게 하기 위해 c++
     에서는 해당 멤버를 protected/private으로 놓고, getter()를
     사용하였지만, C# 에서는 단순히 =public readonly int year;= 
	 이런 식으로 하면 된다.

   - struct가 아닌 class의 경우, readonly 변수의 초기값을 
	 =public readonly int year = 1=; 이런식으로 할 수 있다. 또는
     생성자를 통해서 단 1번만 설정하게 할 수 있다. 이렇게 하면
     immutable 객체가 된다.

*** const : C++ 과는 달리 필드에만 쓸 수 있다(?)

	어떤 멤버를 const 로 선언하면 동시에 초기값을 설정하여야 하며,
	본질적으로 모든 const 멤버는 클래스 범위에서 접근해야
	한다(Math.PI)

*** 프로퍼티를 정의할 때 사용하는 set/get 은 키워드가 아니다.

	단지 프로퍼티 정의시에만 독특한 의미로 사용된다. 다른 곳에서
	변수명으로 써도 된다.

*** 프로퍼티 이름이 MyProp이면 Set_MyProp/Get_MyProp 은 사용불가

   컴파일러가 내부적으로 생성한 getter/setter 함수명과 충돌하기 때문에
   사용할 수가 없다.

*** 프로퍼티 = private 변수선언 + get/set함수의 특별한 정의   

   *private으로 선언한 변수의 이름이 프로퍼티 이름과 동일하면 안된다*.

   #+begin_src csharp
     class Person
     {
         string name;
         public string Name {
             get {
                 return name;
             }
             set {
                 name = value;
             }
         }
     }
   #+end_src
  
*** 프로퍼티는 반드시 값을 그대로 리턴할 필요가 없다.
	set과 get간의 관계만 명확하면 된다. ex: get()할때 -1 해서
	반환한다면, set할 때 +1 해서 저장해 두면 된다.. 이런식.

*** 프로퍼티를 배열처럼 선언할 수 있다.

	#+begin_src csharp
      class DateClass {
          static string[] strMonths = new string[] {
              "January", "Feburary", "March", "April"
          };
          public static string[] MonthName {
              get {
                  return strMonths;
              }
          }
      }
      
      class ArrayProp {
          static void Main() {
              Console.WriteLine("DateClass.Month[2] = {0}", DateClass.MonthName[2]);
              foreach (string monthName in DateClass.MonthName) {
                  Console.WriteLine("{0}", monthName);
              }
          }
      }
	#+end_src

	위 결과는

	#+begin_example
          DateClass.Month[2] = March
          January
          Feburary
          March
          April
	#+end_example

*** Indexer!!!

	- =public int this[int i];= 이런 멤버함수는 객체의 속성을 배열인덱스
	  처럼 접근할 수 있다.
	- =public int this[string str];= 이렇게 하면, dictionary 처럼
      접근이 가능하다.
	- 모든 indexer 는 속성과 마찬가지로 get/set 두 구간으로 나눌 수
      있다.
	- MSDN 문서에는 indexer 에 대해 이름 붙일때 "Items" 를 일반적으로
      쓰지만, String 클래스의 Indexer와 같이 "Chars" 라는 이름을
      사용하기도 한다. 실제로 C#은 내부적으로 "set_Item" 과 "get_Item"
      이라는 이름으로 된 접근함수를 만들어낸다(이 2개의 이름으로 된
      멤버는 만들 수 없다).
	
** 18장. 상속

   - 우선 C# 에는 protected/private 상속이 없다. 
	 =public Foo : private Bar { }= 이런식으로 할 수가 없다.

   - 파생클래스는 부모클래스의 생성자를 그대로 쓸 수 없다(C++과
     동일).인자 있는 생성자를 상속클래스에 따로 정의를 다시 해야
     한다(또 그렇게 하면 기본 /parameterless contstructor/ 는
     만들어지지 않는다.

   - 파생클래스에서 부모클래스의 생성자를 호출하려면 *base* 키워드를
     사용한다(15장에서 언급한 /constructor initializer/ 의 한 종류가
     된다. 그때는 this 를 썼지만 여기서는 base를 썼을 뿐). 생성자
     호출순서는 C++과 같이 부모클래스->자식클래스 이다.
	 
	 #+begin_src csharp
       class ExtendedDate: Date
       {
           public ExtendedDate()
           {
           }
           public ExtendedDate(int year, int month, int day)
               : base(year, month, day)
           {
           }
       }
	 #+end_src

   - 멤버 변수/메소드 에 대한 public/protected/private 은 C++과 비슷해
     보인다.

** 19장. 가상화(Virtuality)
*** up/down cast문제와 C++의 dynamic_cast같은 'as' 연산자

   C++에서의 down casting 및 up casting 개념이 C# 에도 있다. up
   casting은 문제 없다.

   #+begin_src csharp
   ExtendedDate exDate = new ExtendedDate();
   object obj = exDate;
   #+end_src

   근데, down casting은 역시나 문제가 있다. 명시적 형변환이 필요.
   c++에서의 dynamic_cast<> 같은 개념이 필요할 수 있다(즉, 실제로 그
   객체가 그 형인지 알려면...

   #+begin_src csharp
     // 안전하지 않은 방식(obj 가 실제로 ExtendedDate 가 아니면
     // InvalidCastException이 발생한다)
     ExtendedDate exDate = (ExtendedDate)obj;
     // 안전(?)한 방식
     ExtendedDate exDate = obj as ExtendedDate;
     if (exDate)
     {
         // obj 가 ExtendedDate 였다.
     }
     else
     {
         // obj 가 ExtendedDate 가 아니였다.
     }
   #+end_src

*** Object의 GetType() 또는 typeof() 연산자로 얻은 Type 객체.

   어떤 객체의 타입에 대한 정말 많은 정보를 얻을 수 있다. 이를 테면.

   #+begin_src csharp
     object obj = new Date;
     Type objType = obj.GetType(); // 또는 typeof(Date)
     Console.WriteLine("obj type name : {0}", objType);
     foreach (MemberInfo mi in objType.GetMembers())
     {
         Console.WriteLine("member : {0}", mi);
     }
   #+end_src

   그리고, Type 객체는 형이 정의되면 생기는 형 별로 딱 1개 생기는
   전역객체를 가리키는 레퍼런스(포인터)이다. 따라서, 등가비교를 하는
   것이 가능하다.

   #+begin_src csharp
   obj.GetType() == typeof(ExtendedDate)
   #+end_src

*** 'is' 연산자

	인스턴스 메소드인 GetType() 이나 C# 연산자인 typeof() 를 사용하지
	않고 어떤 객체가 특정형인지 알 수 있게 해주는 것이 'is' 연산자.
	GetType() 은 인스턴스 메소드 이므로 객체가 null인 경우 예외가
	발생하지만, is 연산자는 그런일이 없다. 그냥 false 로 평가된다. 

	#+begin_src csharp
      if (obj is Date)
      {
          Console.WriteLine("object is Date type!");
      }
	#+end_src

*** 오버라이드 가능한 멤버 = virtual 메소드 , virtual 속성

	부모 클래스에서

	public virtual string ToString();

	하고, 자식 클래스에서

	public override string ToString();

	하는 식.

*** 부모클래스의 메소드를 명시적으로 hiding하는 'new' 키워드(생성할때의 new와 다른것)

	부모가

	public void NonVirtualMethod();

	했는데, 자식이

	public void NonVirtualMethod();

	하면 컴파일러가 경고를 띄운다. 무심코 부모클래스의 기능 하나가
	hiding되기 때문이다. 이런 경우 의도한 바라면,
	자식 클래스에서

	public new void NonVirtualMethod();

	하면 경고가 사라지며, 명시적으로 부모 클래스의 메소드를 막는다.

	NonVirtualMethod() 는 부모클래스형으로 호출하는 경우와
	자식클래스형으로 호출하는 경우가 구분된다. (virtual 함수는 그렇지
	않다. 항상 실제 형의 루틴이 호출된다. C++과 동일하다. --> "다형성")

*** abstract class , abstract method

	abstract class Musician {}

	으로 정의한 클래스의 객체는 못만듬.

	public abstract  decimal CalculatePay();

	함수는 반드시 override 되어야 하는 메소드.

*** struct 형 객체를 object 형으로 형변환 : boxing / unboxing

	- *struct 는 스택에 생성되는 값 객체이므로, 서로 다른 형 끼리는
      대입하지 못한다*.

	- *struct 형* 을 선언하면 스택에 해당형의 크기만큼이 할당된다. 근데,
      struct 역시 object로 부터 파생된 형이므로, *object에 대입이
      가능* 하다.

	- object형으로 대입될 때 힙에 struct형을 담을 수 있는 공간이
      확보되어 거기에 해당 struct의 모든 멤버의 값이 복사된다. 이를
      *Boxing* 이라고 한다. --> 퍼포먼스에 영향을 줄 수 있음.

	- object가 가리키는 struct의 내용을 역참조할때는 *Unboxing* 을
      하게 된다. 이 경우도 복사가 일어난다. --> 퍼포먼스!!!

	- 가급적 boxing/unboxing이 일어나지 않도록 구체적인 struct형을
      주고 받는 식으로 메소드들을 오버라이딩 하는 게 바람직.(ex: WriteLine)
	
** 20장. 연산자 재정의(Operator Overloading)

   먼저 말해 두지만, struct는 값을 위한 타입이고 파생클래스를 만들 수
   없다. 자신이 가지는 연산자도 당연, 파생될 수가 없고, 이것은 말이
   된다. 사실 class의 오퍼레이터도 자신의 파생클래스에는 문제가 될
   소지가 있다(파생클래스에서 Add 같은 연산자가 리턴하는 값의 타입은
   파생클래스가 될까? Add연산자를 매번 새로 정의하지 않으면
   부모클래스의 객체가 반환될 거다!!!)

   숫자들로 구성된 데이터를 다루고, 그것에 대한 연산자를 오버로딩하는
   것은 struct 형을 통해서 하는 것이 바람직하다.(바로 위에 문장에
   의하면,  struct가 파생될 수 없는 점이 이 경우에는 강점이 된다).

*** 계산을 위한 연산자 재정의
   
   - 연산자 재정의는 무조건 static 으로 해야 한다. 또한 빼기 연산자를
객체에 대해 수행하지 못하는 프로그래밍 언어를 위해 명시적인 Add,
Subtract, Multiply, Divide 같은 이름을 사용한 함수를 만들어야 할 필요도
있게 된다. 결국 아래와 같은 식으로 구현.

   #+begin_src csharp
     public static int operator - (Date lhs, Date rhs)
     {
         return Subtract(lhs, rhs);
     }
     public static int Subtract(Date lhs, Date rhs)
     {
         int daysDifference = lhs.value - rhs.value;
         return daysDifference;
     }
     public static Date operator + (Date lhs, int days)
     {
         return Add (lhs, rhs);
     }
     public static Date Add (Date lhs, int days)
     {
         Date v = new Date;
         v.value = lhs.value + days;
         return v;
     }
   #+end_src

   - 연산자 재정의 시 2개 인자의 순서도 중요하다(연산잔 교환법칙이
     성립되지 않는 경우를 고려).

*** 등가 연산자 재정의

   - 등가 연산자(Equals 또는 operator ==) 의 구현시, Object 루트
     클래스는 Object형 2개를 인자로 받는 static 메소드이므로, struct와
     같이 ValueType 형의 객체는 boxing/unboxing이 발생한다. 명시적인
     형을 받는 Equals 를 구현해 놓는게 좋다.

   - 등가연산자 구현시 Equals 및 GetHashCode 메소드를 override해야
     한다. GetHasCode는 32비트 정수형을 반환하는데, 값에 따라 2의 32승
     가짓수를 넘어서는 값의 종류가 있다면 유일성은 포기해야 한다.

   - 타입변환 연산자도 재정의가 된다. 다만, 사이드 이펙트로 변환되는
     것을 막기 위해 explicit 키워드를 사용해 주는게 좋다. 
	 
	 public static explicit operator int (SuperDate sd);
	 
	 위의 역 변환도 가능하게 할 수 있다. 
	 
	 public static explicit operator SuperDate(int value);
	 
*** partial 키워드	 

	partial class SuperDate : ExtendedDate {}

	처럼 하면, SuperDate 의 구현을 2개 이상의 파일에서 할 수 있단다.

	partial은 

**** 책에 나온 Date class 보다는 CommonEraDay 정수값 1개를 가지는 Date struct

	펫졸드 아저씨는 설명을 위해서 Date를 class로 만들었지만, 실제로
	본인도 이것 보다는 값 형식인 struct를 사용하고 내부의 값은
	심플하게 정수형 1개로 표현할 수 있는 Date struct가 훨씬 낫단다.

** 21장. 인터페이스(Interfaces)

   - interface 는 메소드의 구현이 전혀 없다(C++ 순수가상클래스와
     비슷).
   - class 는 다른 class 1개로 부터만 상속받을 수 있으나, interface를
     상속받는 경우는 여러개 상속이 가능하다.
   
	 ex : class SuperDate : ExtendedDate, IComparable

   - IComparable 을 사용하되 partial 키워드를 사용해 원본 클래스
     소스코드를 전혀 손대지 않고, 구현이 가능했다.

   #+begin_src csharp
     partial class Person : IComparable
     {
         public int CompareTo(Object obj)
         {
             // 여기에 구현을 넣는다.
         }
     }
   #+end_src

   *interface 에 선언된 메소드를 정의할 때는 override 키워드를 쓰면
   안된다.* C++을 생각하면 당연히 virtual일거라 생각했는데, 아니네..

   *Array.Sort()* 클래스 정적 메소드는 keyList와 valueList 두개를 모두
    받는 버젼이 있더라. (key가 정렬되는 순서대로 valueList도 함께
    정렬되더라. 굳이 자료구조를 구성해서 정렬할 필요가 없어 조으네).

** 22장. 상호운용성(Interoperability)

   P/Invoke 를 통해 Win32 DLL을 호출하는 방법에 대해 설명.

** 23장. Date와 Time

   일단 스킵

** 24장 Event와 Delegate

   - A 에 무슨일 이 생길때 그 사실을 B에 알려주는 방법 : Polling &
     Event 의 2가지방법. Event가 더 좋다는 얘기...
   - =public delegate void EventHandler(Object sender, EventArgs e);=
     이런식으로 EventHandler 라는 이름의 delegate를 정의했다...함은
     void(Object,EventArags) 시그너쳐를 가지는 함수포인터같은 개념을
     정의했다는 의미

   - 이벤트를 정의하려면...
	 
	 #+begin_src csharp
       public event EventHandler InformationAlert;
	 #+end_src

     EventHandler 라는 시그너쳐를 가지는 InformationAlert 라는
     이벤트를 클래스 정의에 추가함.

   - Event처리기의 등록과 호출
	 
	 #+begin_src csharp
       // B 쪽 생성자 등에서 핸들러와 이벤트를 연계할때 2가지 방법이 모두 가능
       // .NET 2.0 이하에서 
       a.InformationAlert += new EventHandler(MyInformationAlertHandler);
       // 또는 .NET 2.0 이상에서 가능구문을 사용.
       a.InformationAlert += MyInformationAlertHandler;
       
       // B 클래스의 메소드
       void MyInformationAlertHandler(object sender, EventArgs e)
       {
           // 여기서 실제 이벤트 처리루틴
       }
       
       // A 클래스에서는
       {
           // 이벤트를 날려야 되는 순간이 되었다!! (fire or raise Event!)
       
           if (InformationAlert != null)
           {
               // 이벤트 헨들러가 등록된게 있다. 통지 하자.
               InformationAlert(this, new EventArgs(...));
           }
       }
	 #+end_src
	 
	 등록 시의 구문이 += 연산자를 써서 여러개의 핸들러를 등록시킬 수
     있기 때문에, InformationAlert.Length 같은 식으로 확인해야 할 것
     같은데, null 로 확인하는 점이 헛갈린다.
	 
	 등록 해제 하려면 -= 연산자를 써서 할 수 있다.
	 
	 #+begin_src csharp
	 a.InformationAlert -= new EventHandler(MyInformationAlertHandler);
	 #+end_src
	 
	 .NET 2.0의 깔끔한 핸들러 등록 구문을 써서 예제 하나. 이벤트
     핸들러 메소드를 마치 변수 다루듯이 한 점을 유심히!
	 
	 아래 코드는 
	 
	 1. 객체의 멤버함수를 핸들러로 등록("객체.메소드" 구문
	 2. 익명 메소드를 핸들러로 등록("delegate" 구문) - Full/Short version!
	 3. 정적 메소드를 핸들러로 등록("public static 함수")
	 
	 의 3가지 종류에 대한 핸들러 등록을 하고 있다. 등록 순서대로
     이벤트 발생시 호출이 일어난다. 
	 
	 *익명메소드를 사용하기는 우아하지만, 로컬변수와 관련하여서는 좀
     tricky 할 수 있다.*

	 #+begin_src csharp
       using System;
       using System.Timers;
       class TimerHandlingClass {
           public void OnElapsed(Object sender, ElapsedEventArgs e) {
               Console.WriteLine("object handled event(data={0}) handled event!", data);
           }
           public int data;
       }
       class TimerEventTest {
           static void Main() {
               TimerHandlingClass thc = new TimerHandlingClass();
               thc.data = 18; // 객체가 그 객체가 맞는지 확인.
               Timer timer = new Timer();
               timer.Interval = 500;
       
               // 객체의 멤버함수
               timer.Elapsed += thc.OnElapsed;
               // 익명 메소드(anonymous method) - full version
               timer.Elapsed += delegate (Object sender, ElapsedEventArgs e) {
                   Console.WriteLine("Lambda delegator handled event!!!");
               };
               // 익명 메소드 - short version
               timer.Elapsed += delegate {
                   Console.WriteLine("Simple Lambda delegator handled event!!!");
               };
               // 정적함수
               timer.Elapsed += TesterHandler;
       
               timer.Start();
               Console.ReadLine();
           }
           public static void TesterHandler(Object sender, ElapsedEventArgs e) {
               Console.WriteLine("TesterHandler handled event!!!");
           }
       }
	 #+end_src

** 25장. 파일과 스트림

   - System.IO 네임스페이스관련 내용. XML파일 IO는 System.XML 을 쓰라.
***  Stream(추상클래스)

BufferedStream, FileStream, MemoryStream, NetworkStream 의 4가지
종류파생클래스가 있다. Stream자체는 다음의 메소드를 가짐

   - CanRead, ReadByte(1바이트읽음), Read(여러바이트읽음)
   - CanWrite, WriteByte(1바이트기록), Write(여러바이트쓰기)
   - CanSeek, Length, Position, Seek(SeekOrigin enum을 사용:Begin/Current/End)
   - CanTimeout, ReadTimeout, WriteTimeout

비동기 동작을 위한 메소드도 존재	 

   - BeginRead
   - EndRead
   - BeginWrite
   - EndWrite

*** FileStream

대다수의 파일 관련 동작은 이걸 쓰면 된다. 하지만, C/C++ 처럼 바이너리
버퍼를 특정 struct 형으로 바꿀 수 있는 언어들과는 달리, C# 은 그런일을
할 수 없으므로, 순수(!)하게 바이너리를 읽는 작업 이외에 이 클래스를
사용하게 되는 일은 드물다(*Text File I/O* 혹은 *Binary File I/O* 를
쎄게 된다)

  - 생성자 : 시그너쳐의 종류가 많음. 일반적으로 2개의 인자(FileName과
    FileMode)와 2개의 선택인자(FileAccess=디폴트는
    FileAccess.ReadWrite, FileShare=디폴트는 FileShare.None 이라지만,
    MSDN을 보면 어떤 생성자는 FileShare.Read가 디폴트인 경우도 있음)

  - 생성자를 사용해 초기화하기 때문에 동작실패시 예외가 던져지는
    식으로 처리 --> *항상 try/catch 블럭에 감싸서 호출할 것!*

  - FileMode가 FileMode.Append 인데, 선택인자에 Read가 들어가면
    FileStream의 생성은 무조건 실패. 다음과 같이 함.
	
	=new FileStream(fileName, FileMode.Append, FileAccess.Write)=
	
  - ReadByte는 1 바이트를 읽기는 하지만 int 형으로 형변환된 값을
    반환한다. 0xFF 를 읽으면 0x000000FF 즉 255 가 반환된다. 읽기
    실패(파일의 끝을 지나치는 경우)에는 -1 이 반환된다.	

*** Text File I/O = TextReader(/abstract/) + TextWriter(/abstract/)

	- TextReader = *StreamReader* + StringReader
	- TextWriter = *StreamWriter* + StringWriter
   
   StreamReader/Writer 는 Encoding을 인자로 받기 때문에 Encoding 에
   관한 얘기가 주욱 나온다.

   - UTF8 이 중요할 것 같은데, BOM을 쓰지 않는 경우라면,
     Encoding.Default 를 쓰라는 얘기가 있다.(또는 UTFEncoding(true))
   - 윈도우즈 안시 캐릭터 셋을 쓰려면
     *Encoding.GetEncoding({코드페이지})* 를 쓰란다.
   - MSDN 을 찾아보니 *Encoding.GetEncoding()* 클래스 매소드는 문자열을
     받는 버젼도 있다. 아래와 같은 방식으로 사용
	 
	 #+begin_src csharp
       public class SamplesEncoding
       {
           public static void Main()
           {
               // Get a UTF-32 encoding by codepage.
               Encoding e1 = Encoding.GetEncoding( 65005 );
       
               // Get a UTF-32 encoding by name.
               Encoding e2 = Encoding.GetEncoding( "utf-32" );
       
               // Check their equality.
               Console.WriteLine( "e1 equals e2? {0}", e1.Equals( e2 ) );
           }
       }
       // "e1 euqlas e2? True" 라고 찍힌다.
	 #+end_src
	 
	 또 *Encoding.GetEncodings()* 클래스 매소드는 사용가능한 모든
     EncodingInfo 객체들의 목록을 반환한다.

*** StreamWriter

   - BaseStream 속성 : 자신의 기반이 되는(또는 생성시 사용된) Stream
   - Encoding 속성 : 설정된 인코딩
   - AutoFlush 속성 : 버퍼링사용 여부
   - NewLine 속성 : =\r\n= ?
	 
   - Write 메소드
   - WriteLine 메소드
   - Flush 메소드
   - Close 메소드

   - StreamWriter() 생성자중 *bool detect* 인자를 true 로 하면, 처음
     몇바이트를 가지고 인코딩을 디텍팅해낸다!!!! 거기다가 Encoding을
     명시적으로 알려주면, 혹 디텍팅을 못한 경우에 지정된 Encoding을
     알려준다.

*** StreamReader

	- BaseStream 속성
	- CurrentEncoding 속성 : *읽기를 시작하면서 바뀔 수 있다*
	- Peek 메소드 : 읽기위치를 옮기지 않고 1바이트 얻음. --> -1 에러
	- Read 메소드 : 읽기위치가 옮겨지고    1바이트 얻음. --> -1 에러
	- *ReadLine* 메소드 : 파일끝에 가면 null 객체 반환.
	- *ReadToEnd* 메소드 : 전체 파일 읽기.
   
*** Binary File I/O = BinaryReader + BinaryWriter

	- 모두 Object 에서 바로 상속(cf. StreamReader/Writer는 Object >
      MarshalByRefObject > StreamReader/Writer).
	- 생성자에서 Stream 을 받고, 나중에 BaseStream 속성으로 다시 얻을
      수 있음.

*** BinaryWriter

	- Write 메소드 : bool, byte, byte[], char, char[], string, short,
      int, float, ... 18개 형에 대한 오버로딩이 존재!!! --> 타입에
      대한 정보는 기록하지 않고, 단순히 데이터값만 기록한다.
	  배열의 경우, *배열의 길이정보 역시 기록하지 않는다*.
	  문자열의 경우, *7비트 인코딩된 정수값으로 길이가 기록된다?*

	- Seek 메소드
	- Flush 메소드
	- Close 메소드 : underlying Stream을 Close 한다.
   
*** BinaryReader

	- ReadBoolean, ReadByte, ReadBytes, ReadSByte, ... 이런식으로 값을
      반환하는 읽기 메소드가 존재한다.-> EOF 에 다다르면, EndOfStream
      예외가 발생한다(반환값 자체가 데이터이므로 반환값으로 호출
      성공여부를 알 수 없겠다) --> Reader의 경우 오퍼레이션을
      try/catch 로 감싸야 한다.
	- PeekChar 메소드 : 다음에 오는 1 바이트를 읽고 위치 변경 X
	- Read 메소드     : 다음에 오는 1 바이트를 읽고 위치 변경 O

* Apress Pro C#
** 3장. Core C# 1편
*** checked 키워드

	checked 키워드를 =check(연산식)= 혹은 =checked { 구문들; }=
	이런식으로 사용하여 오버플로우 등 연산오류 발생시 예외가 던져지게
	할 수 있다.
	
	#+begin_src csharp
      try
      {
          // 계산이 유효하지 않게 되면 예외가 던져진다.
          checked
          {
              int sum = 1000000;
              byte byteSum = (byte)sum;
          }
      } catch (OverflowException e)
      {
          Console.WriteLine(e.Message);
      }
	#+end_src

	만일 컴파일러 옵션 =/checked= 를 사용하면 전체 프로젝트에
	checked를 사용하는 효과를 보게 된다.

*** var 지시어(?. C# keyword 가 아님!)
	
	암시적으로 형을 유추할 수 있는 경우에 원래의 형 대신 쓰게 된다.
	C++11 의 auto 와 유사.

	LINQ 구문과 같이 리턴되는 값의 형이 복잡한 경우에 쓰면 코드가
	깔끔하다.

	var 는 초기값을 설정하는 경우(즉, *타입을 유추할 수 있는 경우*)
	로컬 변수선언 시에만 쓸 수 있다. 다음과 같은 경우에는 사용 불가

	- 필드 X
	- 리턴값 X
	- 초기값 설정을 하지 않는 로컬변수 선언시 X
	- null값으로 설정하는 변수 X
   
   var 형은 겉보기로는 Variant 같은 형과 비슷하지만, 전혀 다르다.
   유추하는 것만 자유롭지, 일단 유추되면 그 형의 타입으로 고정된다.
   (즉, 타입세이프하게 된다)

   LINQ 사용시 유용한 예

   #+begin_src csharp
     static void LinqQueryInts()
     {
         // LINQ !
         int [] numbers = {10, 20, 30, 40, 50 };
         var subset = from i in numbers where i < 30 select i;
         foreach (int number in subset)
         {
             Console.WriteLine("{0}", number);
         }
     }
   #+end_src

*** Enum.Parse() 를 사용하면 문자열을 특정 enum형으로 변경가능
   
   #+begin_src csharp
   DayOfWeekEnumType dow = Enum.Parse(typeof(DayOfWeekEnumType), "Monday");
   #+end_src

*** switch 문이 enum/문자 뿐만 아니라 *문자열*까지 case할 수 있다!

   #+begin_src csharp
     string lang = "c#";
     switch (lang)
     {
     case "c#":
         break;
     case "c++":
         break;
     case "objc":
         break;
     }
   #+end_src

   와우

** 4장. Core C# 2편
*** 함수 인자 수식어(Parameter Modifier)

	- (none) : pass-by-value. reference type의 pass-by-value 는 역시
            reference임에 유의. 원래값의 복제본이 넘어간다.
   	- ref : pass-by-reference. 원래값의 참조값이 넘어간다.
	- out : pass-by-reference. 함수구현부에서 값을 설정하지 않으면
            컴파일 오류발생
	- params : 가변인자. params 인자는 가장 마지막에 와야함.
   
   ref/out은 함수선언시에도 사용하고, 호출시에도 사용해야 한다.
   params 은 선언시에만 사용하고, 배열형식으로 인자가 선언되어야 한다.

   #+begin_src csharp
     public static int Main(string[] args)
     {
         CalcAvg(10, 1, 2, 3, 4, 5, 6, 7, 8, 9);
         return 0;
     }
     static void CalcAvg(double multiplier, params double [] values)
     {
         double avg = 0;
         foreach (double value in values)
         {
             avg += (value * multiplier);
         }
         avg = avg / values.Length;
         Console.WriteLine("average = {0}", avg);
     }   
   #+end_src

*** 선택적 인자의 사용이 가능.

	C++ 동일한 방식으로 디폴트 값을 가지는 인자를 만들 수 있다.

	#+begin_src csharp
	static void EnterLogData(string message, string owner="Programmer")
	#+end_src

*** 이름있는 인자(Named Parameter)

	보통 우리가 쓰는 걸 positional parameter(위치별 인자)라고 하고,
	인자의 이름 뒤에 콜론을 붙이는 식으로 인자전달 하는 걸 named
	parameter 라고 한다. 가독성이 좋아지는 부분도 있고, COM
	상호운용성(거기에도 Named Parameter가 있다)을 높이기도 하지만,
	그닥... 이란다.

	positional parameter 와 named parameter 는 섞어서 쓸 수 도 있다.
	그런경우 positional 은 순서가 함수 시그너쳐와 맞아야 하고, named
	는 	항상 그 뒤에 따라 와야 한다.

	COM등에서 사용되는 named parameter의 용례는 다음과 같은 경우로
	느낌을 받을 수 있다.

	#+begin_src csharp
      static void DisplayFancyMessage(Color text = blue,
                                      Color background = yellow,
                                      string message = "TestMessage")
      {
          // text색상으로 background색상 위에 message를 표시.
      }
      // 아래와 같이 호출 가능
      DisplayFancyMessage(message: "Hello!");
      DisplayFancyMessage(text:red);
	#+end_src

*** C# 은 인자타입에 따른 메소드 오버로딩이 가능하다.

	C++ 과 동일하다. 근데, VB.NET은 그게 안된단다.
	*Generic* 을 사용하면 C++ template class 처럼 *type placeholder* 를
	정의하여 구현을 일반화할 수 있다.

*** C# 배열

	초기화 구문예는 다음과 같은 종류

	#+begin_src csharp
      static void ArrayInit()
      {
          string[] array1 = new string[] {
              "one",
              "two",
              "three"
          };
          bool[] boolArray = {
              false,
              false,
              true
          };
          int[] intArray = new int[4] {
              20, 22, 23, 0
          };
      
          // oops compile error
      
          // int[] intArray2 = new int[2] {
          //  20, 22, 23, 0
          // }
      }
	#+end_src

	암시적인 형 *var* 를 사용해서도 정의 가능. 가능한 일반적인 형으로
	유추되더라. 똑똑한 var.

	#+begin_src csharp
      void VarArray()
      {
          var data = new[] { 1, 10, 100, 1000 };
          Console.WriteLine("typeof(data)={0}", data.GetType()); // System.Int32[]
          a[1] = 50;
          foreach (var i in data)
          {
              Console.WriteLine("i = {0}", i);
          }
          var b = new[] { 1, 3.5, 10 };
          Console.WriteLine("typeof(b)={0}", b.GetType()); // System.Double[]
      
          // // 섞어 쓰면 컴파일 에러
          // var d = new [] { 1, "one", 2 };
      }
	#+end_src

	System.Object 즉, object 형을 배열로 만들면 모든 객체를 하나의
	배열에 담을 수 있다.

	#+begin_src csharp
      object[] myObjects = new object[3];
      myObjects[0] = 10;
      myObjects[1] = new DateTime(1971,12,11);
      myObjects[2] = "hello";
      foreach (object obj in myObjects)
      {
          Console.WriteLine("object = {0}(type:{1})", obj, obj.GetType());
      }
	#+end_src

	배열은 함수의 인자로도, 리턴값으로도 사용가능하단다.

	#+begin_src csharp
      static void PrintArray(int[] intArray);
      static string[] GetStringArray();
	#+end_src

*** .net에서 배열은 System.Array 클래스 객체

	- Clear(): 지우기(전체 혹은 일부구간)
	- CopyTo(): 배열요소 복사하기
	- Length: 배열항목갯수
	- Rank: 몇차원 배열?
	- Reverse(): 정작메소드. 1차원배열인 경우 순서를 역순으로 만듬
	- Sort() : 정적메소드. 정렬.

*** enum

	C# 에서는 enum의 underlying type을 지정이 가능. 아래는 그걸
	int형으로 함.

	#+begin_src csharp
      enum EmpType : int
      {
          Manager, // =0
          Manager =10,
          Contractor, // 11
          VicePresident, // 12
      }
	#+end_src

*** System.Enum

	enum형으로 정의된 타입에 대한 introspection이 가능.

	*모든 enum 값은 System.Object의 파생클래스인 System.Enum 클래스의
     객체*. 따라서 그 어떤 enum 같이라도 다음과 같은 함수에 넘겨서
     정보를 쭈욱 뽑아낼 수 있다.

	 #+begin_src csharp
       static void EvaluateEnum(Enum e)
       {
           Type enumType = e.GetType();
           Console.WriteLine("Enum Type Name: {0} (underlying type={1}",
                             enumType.Name, Enum.GetUnderlyingType(enumType));
           var enumValueList = Enum.GetValues(enumType);
           Console.WriteLine("--> has {0} values.", enumValueList.Length);
           foreach (var enumValue in enumValueList)
           {
               Console.WriteLine("Name:{0}, Value:{0:D}", enumValue);
           }
       }
       // EvaluateEnum(MyEnum.FirstEnumValue)
	 #+end_src

*** .Net struct 형 --> ValueType (cf. class형은 RefType(Reference Type))

	일반적인 객체지향언어에서 경량클래스타입으로 여겨지는 바로 그것.
	수학적/지리학적/원자적 단위의 데이터. 상속을 통해서 무언가를
	이루어 내려는 경우에는 사용이 안됨(그런경우는 class를 사용).

	struct와 class의 스택/힙상에서의 존재, 대입시 참조가 대입되는지
	값이 복사되는지...등등에 대한 내용은 .NetBookZero 에서 배움.

	패스.

***  ValueType과 패스타입의 차이점 정리 

	- 객체가 어디에 정의되는가?
	- 변수는 어떤 것을 표현하는가?
	- 어느 클래스에서 상속 받았는가?
	- 다른 타입의 부모가 될 수 있는가?
	- 파라메터로 전달될때 디폴터 거동에 무슨 차이가 있나?
	- System.Object.Finalize() 를 오버라이드 할 수 있나?
	- 생성자를 정의할 수 있나?
	- 언제 소멸되나?

*** Nullable Type

	- *ValueType의 경우 null 값을 대입할 수 없다*,
	- 그러나 *물음표(?)를 접미사* 로 붙인 ValueType은 NullableType 이
      되어 null 을 대입할 수 있다. 물음표(?) 를 붙이면
      *System.Nullable<T>* 형이 된다.

	#+begin_src csharp
      int? nullableInt = null;
      // 위와 아래는 같음
      System.Nullable<int> nullableInt = null;
	#+end_src

	어떤 NullableType 의 값이 null 인지를 확인한 후, null이면 기본값을
	사용하는 패턴은 많이들 사용하는데 그때 유용한게 이중물음표(??)
	연산자이다.

	#+begin_src csharp
      public static int? GetNullableValue();
      // 위와 같은 함수가 있을때...아래 구문은 null 이 반환될 경우 기본값 10
      // 이 notNullableValue 에 대입된다.
      int notNullableValue = GetNullableValue() ?? 10;
      // 또는 선택적 RefType 인자의 기본값을 null로 한 다음 값을 주는 것도 가능
      class MyClass {
          public MyClass(string name = null) {
              this.Name = name ?? "DefaultName";
          }
          public string Name { get; set; }
      }
	#+end_src

** 5장. 캡슐화

*** 생성자(즉, "인스턴스 생성자(instance constructor)")
   생성자에 관한 얘기가 주욱 나온다. 생성자를 명시적으로 생성하지
   않으면, 컴파일러가 기본 생성자를 만들고 거기서 모든 멤버의 값을
   기본값으로 채운다(ValueType 은 0/false, RefType 은 null).

   *파라메터를 받는 사용자 정의 생성자를 하나라도 정의하면 컴파일러는
    더이상 기본제공 생성자를 만들지 않는다* !

	왜 그럴까? 파라메터 커스텀 생성자는 객체의 멤버가 특수한 방식으로
	초기화될 필요가 있다고 여겨지기 때문에 정의하는 것이다.
	그런경우에는 컴파일러의 기본 디폴트생성자는 아무 의미가 없다. 즉,
	사용자가 따로 인자 없는 디폴트 생성자를 받아서 'this' 키워드를
	사용해서 생성자 초기화 호출을 이어주는 식으로 구성해야
	한다(*constructor chaining*)

	--> objc 에서는 *designated constructor* 라고 하는 유사개념.
	--> 이책에서는 *master constructor* 라고 하는 개념
	--> 가장 많은 인자를 받는 생성자.
	--> 모든 생성자가 이 생성자를 this 키워드를 사용해 호출하도록 함.

*** 정적 생성자(static constructor)

	정적 멤버를 초기화하는 방법은

	=static int staticMemberVar = 18;=

	그런데, 데이터베이스에서 값을 가져와야 하는 식으로 초기화해야
	하는경우는? (즉, 런타임에서야만 값을 초기화할 수 있는 경우는?)

	--> *정적 생성자* 를 쓴다.

	정적생성자의 특징

	- 클래스당 오직 1개만 정의할 수 있다(즉, 오버로딩이 불가)
	- 접근제한자("access modifier" ex: public /protected /private
      /internal ...)등의 사용 불가
	- 그 어떤 해당 클래스 객체가 생성되기 직전에 단 1번만 호출됨
	- 그 클래스의 정적멤버에 접근을 맨 처음 할 때 단 1번만 호출됨

*** 정적 클래스(static class)

	정적 멤버만 가질 수 있고, new 해서 인스턴스를 만들수 없는
	클래스가 정적클래스.

*** 접근 한정자(access modifier)

	- 5가지가 있음 : public/protected/private/internal/protected internal.

	- public/protected/private 의 접근방식은 c++ 과 같다.
	- *Type 자체는 절대 private/protected/protected internal 이 될 수
      없다*. public 혹은 internal 이어야 한다.
	- *public class 가 아니라 그냥 class 는 동일 어셈블리에서는 공유될
      수 있다*. 외부로 노출만 되지 않는다. class의 형은 *private,
      protected, 또는 protected internal 로 선언될 수 없다*
	- internal : 동일 .net assembly 에서만 public으로 사용될 수 있다. 
	- protected internal 은 internal과 같지만 protected로 된다. 따라서
      nested type에 사용이 가능

	- 접근 한정자를 지정하지 않은 경우
      --> 멤버: 암시적으로 private
	  --> 타입: 암시적으로 internal
	  
	  클래스 라이브러리를 만들때는 =public class ClassName= 이런식이
      되어야 되겠다.
	  
    - Nested Type 이외의 타입은 절대 private 타입이 될 수 없다.
	- Nested Type 은 Containting Type 의 private 멤버에 접근할 수 있다.

*** accessor(getter)/mutator(setter) 와 property(속성)

	이미 아는 얘기. 다만, 속성의 set 을 정의할 때 사용되는 "value"
	라는 단어가 C# 키워드가 아니란다. *contextual keyword* 란다.
	즉, 다른 곳에서는 value 라는 이름의 변수를 만들수 는 있지만,
	=property set {}= 안에서는 특수한 의미를 가진단다.

	이걸 잘 쓰는 법.

	생성자에서 올바른 범위의 초기값을 입력받을 때 종종 C++ 에서는
	생성자에서 그런걸 하는데, C# 에서는 property set 에서 그런 일을
	하고, 생성자에서는 변수에 접근하는게 아니라 속성에 접근하도록
	코딩하는 게 바람직 하단다.

	*정적 속성(static property)* 개념 : Data Encapsulation 을 생각하면
	정적 멤버변수에 직접 접근하는 것 보다는 이게 낳다는...

	#+begin_src csharp
      class Savings
      {
          private static double interest = 0.04;
          public static double Interest
          {
              get { return interest; }
              set { intereset = value; }
          }
      }
	#+end_src

	*자동 속성(automatic properties)* 개념 : 그냥 =get;set;= 만 넣으면
     속성이 정의된다는... 그렇다고 =get;= 혹은 =set;= 의 형태로는 안된다

	 #+begin_src csharp
       public string MyProperty { get; set; } // OK
       // public string MyProperty { get;} // 오류
       // public string MyProperty { set;} // 오류
	 #+end_src

	 근데, =get;set;= 형태로는 Read/Write 속성이 정의되는데,
	 *이런식으로는 readonly / writeonly 속성의 정의는 불가하다* 

	 자동 속성의 경우, 모든 hidden-member-variable 을 컴파일러가
	 구성할 텐데, 이들은 초기 값이 0/false(ValueType의 경우) 및
	 null(RefType의 경우)이 된다. RefType 의 경우 자동속성의 값은
	 생성자에서 반드시 =new T= 해 주는 것이 바람직하다.

	 속성값의 지정시 validation이나 기타 처리가 필요한 경우는
	 자동속성이 아닌 직접 만든 속성함수를 사용해야 한다(당연).

*** 객체 초기화 구문(Object Initializer)

	*이건 정말, 객체 생성 코드를 깔끔하게 정리해 주는 구문* 이다.

	원하는 객체 생성자를 선택해서 new 해 준다음, 세미콜론(;) 으로
	구문을 끝내기 전에 중괄호 scope(={}=)를 만들어 그 안에 객체의
	속성값을 설정하는 구문이다.

	이건 has-a 관계로 객체를 포함하고는 있는 타입의 경우에 nested 로
	수행할 수 있다.

	아래의 예를 한번 읽어보되, TestOjbInitr()에서
	- 중괄호들이 nested 로 된점
	- 콤마가 찍힌 위치들(마지막 콤마는 optional이지만, 그냥 찍어두는
      게 나을듯)
	- 생성자 시그너쳐가 그냥 =()= 를 붙였지만, 특수한 생성자를 써도
      된다는 점(또는 아예 =()= 를 생략하여 암시적 기본 생성자가
      사용하도록 할 수 있다는 점)
	  
	에 유념하고 코드를 이해한다.

	#+begin_src csharp
      class Point {
          public int X { get; set; }
          public int Y { get; set; }
      }
      class Rectangle {
          public Point TopLeft { get; set; }
          public Point BottomRight { get; set; }
          public Rectangle() {
              TopLeft = new Point();
              TopLeft = new Point();
          }
          public void PrintInfo() {
              Console.WriteLine("({0},{1}) ~ ({2},{3})",
                                TopLeft.X, TopLeft.Y,
                                BottomRight.X, BottomRight.Y);
          }
      }
      // 어떤 함수에서 아래와 같이 객체 초기화가 가능
      static void TestObjIniter()
      {
          Rectangle r = new Rectangle() {
              TopLeft = new Point() {
                  X = 10, Y = 20,
              },
              BottomRight = new Point() {
                  X = 20, Y = 30,
              },
          };
          r.PrintInfo();
      }
	#+end_src

*** 상수필드(constant field data)

	컴파일시 값이 결정되고 그 이후로는 절대 수정불가한 상수값의 정의가
	가능하다. 겉보기로는 인스턴스 멤버같지만 실제로는 *암시적으로
	static 변수* 이다. 따라서 접근 할 때는 static 멤버와 같은 방식으로
	접근한다.

	#+begin_src csharp
      class MyMath {
          public const double PI = 3.141592;
      };
      static void PrintPi() {
          MyMath mm = new MyMath();
          // Console.WriteLine("pi = {0}", mm.PI); // 컴파일 오류!
          Console.WriteLine("pi = {0}", MyMath.PI); // static멤버처럼 사용!
      }
	#+end_src

*** 읽기전용 필드(readonly field)

	멤버변수 선언하듯이 선언할 때 타입명 앞에 =readonly= 를 넣어주면
	*생성자에서만 값의 대입이 가능하고 그 외에는 쓰기가 불가한* 변수가
	탄생한다.

	#+begin_src csharp
      class MyMath {
          public readonly double PI;
          // 생성자 : 쓰기동작 OK
          MyMath() {
              PI = 3.141592;
          }
          // 기타함수 : 쓰기 불가! ERROR!
          public void TryChangePI() {
              PI = 3.141592; 
          }
      }
	#+end_src

*** Partial Class

	partial 클래스를 사용하면

	- 동일한 이름의 클래스명
	- 동일한 네임스페이스
   
   에 partial 로 시작하는 클래스 정의를 최종컴파일 후 하나의 클래스로
   합친다. 즉, *여러개의 파일에 나누어 클래스 정의* 를 할 수 있다.
   ObjC 에서도 class extension 이 있는데, 이게 partial과 어찌보면
   비슷해 보인다. 
   
   VisualStudio 는 WinForm 프로젝트에서 폼 디자이너를 위한 구현은
   별도의 partial class 로 관리한다. (폼디자이너과 관리하는 정규화된
   코드들 은 IDE가 관리하고, 사용자는 좀 더 구현할 로직에 집중할 수
   있다. UI코드가 복잡하게 주욱 나열된 코드를 건드리다 보면 정규화
   상태가 깨지고, 폼 디자이너가 그걸 관리할 수 없게되지 않겠나).

   책에는 언급되지 않았지만, partial 이되, private 한 것은 .Net
   assembly 밖으로는 공개되지 않는다. 폼디자이너가 관리하는 partial
   class 는 =partial class= 즉, implicit private 으로 정의되고,
   사용자가 로직을 구현하는 class 는 =public partial class= 로
   정의되어있다 

** 6장. 상속(Inheritance)과 다형성(Polymorphism)
*** 상속이란
   
   대부분 OOP적인 얘기. C# 에서 특별한 사항들만 정리

   - class 는 *오직 하나의 base class* 로 부터 상속받을 수 있다. 
	 즉, "다중 상속"은 지원되지 않는다.
   - 하지만 주어진 class/struct 는 *독립적 /interface/ (8장에서 설명됨)
     여러개로 부터 상속* 받을 수 있다.
   - struct 로 부터 상속은 할 수가 없다. 아래의 코드예 참조
	 
	 #+begin_src csharp
       using System;
       namespace StructInheritTest {
       
       struct Point {
           Point(int aX, int aY) {
               x = aX; y = aY;
           }
           // // error CS0573: 'StructInheritTest.Point.x': cannot have
           // instance field initializers in structs
           // 
           // public int x = 0;
           public int x; public int y;
       }
       // // 이런건 안됨.
       // struct Point3d : Point
       // {
       //  public int z;
       // }
       } // StructInheritTest
       
       // --------------------------------------
       namespace ClassInheritTest {
       class Point {
           // warning CS0649: Field 'ClassInheritTest.Point.x' is never
           // assigned to, and will always have its default value 0
           //
           //  public int x;
           public int x = 0; public int y = 0;
       }
       class Point3d : Point {
           public int z = 0;
       }
       
       } // ClassInheritTest
	 #+end_src

*** /sealed/ 키워드, 그리고 /struct/ 의 상속문제

	- /sealed/ 키워드로 정의된 클래스는 다른 클래스의 부모클래스가 될
      수 없다. 꽤 많은 .NET 클래스들이 /sealed/ 더라.(ex : String
      클래스)
	- /struct/ 는 *암시적으로 selaed* 이다. 즉, struct 로 부터는 파생
      /struct/, /class/ 를 만들지 못한다. 상속을 통해 계층을 구조를
      만들려면 /class/ 를 써야 한다.

*** /base/ 키워드

   - vc++ 에서 쓰던 __super 키워드, ObjC 에서 super 와 같이
     파생클래스에서 부모클래스의 public, protected 속성을 접근할 때
     사용.
   - 생성자에서 부모클래스의 타입을 가리킬 때도 유용.
   
*** Nested Type

   3대 특징
   - Non-Nested Type 은 절대 private 으로 타입정의를 할 수 없지만,
     Nested Type은 가능하다(Containing class 밖에서 접근할 수 없게된다)
   - Nested Type 은 Containg class 의 멤버이므로, *Containing Class 의
     private member 에 접근이 가능* 하다.
   - 주로 Helper 의 역할로 유용하게 사용된다.

*** virtual "overridable" method

   - 통상 자식 클래스에서 볼 수 있는 *public, protected 메소드* 가
     virtual 키워드를 뒤에 붙여서 정의하면 자식클래스가 /override/
     키워드를 써서 "overrindg" 한다.
   - *public override* , *protected override* 는 숙어처럼 생각하자
     그냥 override 는 암시적으로 private 이고, 자식클래스가 볼 수
     없다. [중요]
   - VisualStudio 의 C# 에디터는 public override 혹은 protected
     override 라고만 치면 오버라이딩 할 수 있는 메소드 목록이 쭈욱
     나온다.
   - *override sealed* 라고 오버라이딩 하면 더 이상 그 메소드는 이걸
     정의한 클래스 자식들이 오버라이딩 못하게 막게 된다. 
	 
*** /abstract/ class 와 /abstract/ method

   - abstract 키워드를 class 정의 앞에 붙이면 그 클래스의 인스턴스를
     더 이상 만들 수 없다. C++ 에서는 virtual 메소드에 "= 0" 을 맨
     마지막에 붙인 class가 그랬다.
   - abstract class 에는 abstract method 를 정의할 수 있다. c++ 의
     pure virtual function 과 동일한 개념이다.
   
*** shadowing 문제와 /new/ 키워드
	가상함수를 override 키워드 없이 정의할 경우, compiler 가 다음과
	같은 오류 메시지를 뿜음.

	#+begin_example
	Shape.cs(46,14): warning CS0114: 'ThreeDCircle.Draw()' hides
	inherited member 'Circle.Draw()'. To make the current member
	override that implementation, add the override keyword. Otherwise
	add the new keyword.
	#+end_example

	명시적으로 shadowing 을 하려면 new 키워드를 함수 정의시 붙여준다.
	이렇게 하면, 다형성이 깨진다. 아래의 예 확인

	#+begin_src csharp
      using System;
      
      class SuperClass {
          public virtual void DoSomething() {
              Console.WriteLine("Super is doing!");
          }
      }
      class ChildClass : SuperClass {
          public new void DoSomething() {
              Console.WriteLine("Child is doing!");
          }
      }
      class ShadowingTest {
          public static void Main() {
              SuperClass obj = new ChildClass();
              obj.DoSomething(); // --> Super is doing!
              ((ChildClass)obj).DoSomething(); // --> Child is doing!
          }
      }
	#+end_src
	
*** 형변환(Casting Rules)과 /as/ 및 /is/ 연산자

	- 자식 클래스의 객체를 부모클래스의 형으로 가리키는 것(형 격상,
      UpCasting)은 항상 허용(Implicit cast). 그 반대(형 격하,
      DownCasting)은 항상 허용안함. 명시적 형변환(Explicit Casting)이
      필요. C++ 과 동일.
	- 명시적 형변환은  =(ClassIWantToCastTo)referenceIHave= 의 식으로
      구문 작성. RefType 만이 가능?(ValueType 은 상속이 안되므로 이런
      스토리 자체가 안통함).

	- 실제로 가능한 형변환이 아닌데도 명시적 형변환을 해도 *컴파일 시에
      오류가 발생하지 않는다*. 형변환은 컴파일타임이 아니라 *런타임* 시에
      이루어지기 때문이다! --> *조심* 해야 한다. 형변환에 대해
      수비적인 자세의 코딩은 다음과 같다. 
	  
	  #+begin_src csharp
        try {
            Hexagon hex = (Hexagon)aPersonObject;
        } catch (InvalidCastException e) {
            Console.WriteLine(e.Message);
        }
	  #+end_src
	  
	  예외를 사용하지 않는 수비적 방법은 /as/ 키워드 또는 /is/
      키워드를 쓰는 것. 아래의 예만 보면 알게됨. :)
	  
	  #+begin_src csharp
        public static void AsIsKeywordTest()
        {
            Shape shape = new Circle();
            try {
                Hexagon hex = (Hexagon)shape;
            } catch (InvalidCastException e) {
                // 여기 들어옴
                Console.WriteLine("invalid cast. {0}", e.Message);
            }
            Hexagon asHex = shape as Hexagon;
            if (asHex == null) {
                // 여기 들어옴
                Console.WriteLine("asHex is null.");
            }
            if (!(shape is Hexagon)) {
                // 여기 들어옴
                Console.WriteLine("shape is not Hexagon object!");
            }
        }
	  #+end_src
	  
*** Ultimate .net class : *System.Object* class
	부모클래스를 지정하지 않은 모든 클래스 정의는 System.Object 로
	부터 암시적으로 파생된다.(단 struct은 System.ValueType 으로 부터?!)
	다음의 
	
**** public virtual string ToString()
   생각보다 중요하게 쓰일 수 있는 함수다. 가급적이면 /base/ 키워드를
   사용해서 *부모 클래스의 ToString()을 호출하여 얻은 string 문자열에
   자기 자신만의 고유한 정보를 추가하여 반환하도록 한다*

**** public virtual bool Equals(object obj)
	 ValueType의 경우에는 bitwise(즉, memberwise)하게 비교하여 같은
	 값을 가지는지 반환하도록 한다(.NetBookZero에서 배운거). RefType의
	 경우에는 개념적으로 동일 객체인지를 판단하도록 하는게 맞지만(즉,
	 같은 메모리주소의 객체인지), 클래스 정의에 따라 다르게 할 수 도
	 있다. 만일 ToString() 이 아주 잘 정의되어 있다면 그걸 사용해
	 Equals 를 구현할 수 있다.

	 #+begin_src csharp
       public override bool Equals(object obj)
       {
           // obj에 대한 형확인, 멤버값 확인같은거 하지 않고, 잘 정의된
           // ToString() 을 재사용한다.
           return obj.ToString() == this.ToString();
       }
	 #+end_src

**** public int GetHashCode()
	 객체의 상태를 하나의 숫자로 표현한다. 만일 두 문자열 객체가 같은
	 문자열을 가진다면, GetHashCode() 도 같은 값을 반환해야 한다.
	 *System.Object 클래스의 기본 구현은 메모리 주소값을 반환한다*.

	 객체를 만든다음 System.Collections.HashTable 에 저장하도록 한다면
	 GetHasCode()가 호출되어 객체의 bucket을 찾은 다음, Equals() 를
	 호출하여 그 위치를 찾는다.

	 GetHashCode() 의 클래스별 구현은 이렇게 저렇게 하는 방법이
	 있겠지만(책의 예. Person객체는 주민번호 문자열 객체에 대한
	 GetHashCode()를 반환), 잘 만들어진 ToString() 을 통해 문자열
	 객체를 얻은 다음, 그 String 객체의 GetHashCode() 를 활용하는
	 방법을 생각할 수 도 있겠다.

	 #+begin_src csharp
       public override int GetHashCode()
       {
           return this.ToString().GetHashCode();
       }
	 #+end_src

**** public static bool Equals(Object objA, Object objB)

	 인스턴스 메소드 Equals 와 같아 보인다. 디폴트 구현은 RefType 에
	 대해서는 동일 인스턴스 여부를 확인하고, ValueType 에 대해서는
	 각각의 멤버별로 동일성을 확인한다. 
	 
**** public static bool ReferenceEquals(Object objA, Object objB)

	 정확히 두 객체가 동일한 메모리 상의 객체를 가리키는지(즉, 동일
	 instance인지) 확인한다.

**

** 7장. 구조적 예외 처리(Structured Exception Handling = "SEH").

*** try,catch,finally,throw
	SEH 와 관련한 키워드
	
*** .NET SEH의 역할
	어셈블리들 사이들에서도, 리모트 머신에서도 예외가 던져져 들어와서
	받아 처리할 수 있다. 일관된 방법으로! C# 이 아니라 .NET 플랫폼
	상에서 구현되어 있으므로,  .NET을 지원하는 다른 언어들에서도
	사용이 가능하다. 

*** .NET 예외처리의 building block

	- 예외의 상세내용을 담을 수 있는 클래스형
	- 특정상황에서 호출측에 예외를 /throw/ 하는 멤버함수
	- 이 멤버함수를 호출하는 호출측의 코드
	- 호출측에서 예외를 처리(즉 /catch/ ) 하는 코드 블럭

*** System.Exception 클래스

	=public class Exception : ISerializable, _Exception=

	이런식으로 정의됨. 엉. Exception이 _Exception을 상속받네?
	- *_Exception 인터페이스를 통해 COM(=unmanaged code)과의 예외처리를
	  할 수 있다네*
	- *ISerializable 인터페이스를 통해 예외를 저장할 수 있다네*

	생성자는
	메시지와 이전 예외에 대한 객체를 받을 수 있음.

	주요한 속성은 다음과 같음.(대부분 읽기 전용에 virtual 임)

	- Message :  에러에 대한 텍스트 설명을 포함.
	- Source : 이 예외객체를 throw 한 어셈블리의 이름
	- StackTrace : 와우! 디버깅에 편하겠네. 로그에 남겨두면 좋을 듯
	- InnerException : 예외를 연속해서 던질 경우, 이 예외를 throw하게
      만든 이전의 예외.
	- Data : IDictionary 사전형 인터페이스를 사용한 예외에 대한
      key/value 쌍 정보
	- TargetSite : MethodBase 객체를 반환하는데, 예외를 던지
      메소드에 대한 정보를 닫고 있단다.

*** 예외 던지기

	=throw new MyExceptionClass(생성자 인자들)= 이런식.

	예외를 만들때 TargetSite, StackTracke, HelpLink, Data 가
	포함된다는 사실을 기억.

	이중에서 HelpLink, Data 는 던져질 때 설정한다(HelpLink, Data 는 몇 안되는
	ReadWrite 속성, Exception의 대부분 속성은 ReadOnly)

	#+begin_src csharp
      Exception ex = new Exception("Something Error Exception!");
      ex.HelpLink = "http://www.wiseplanet.co.kr";
      // 아래꺼를 하려면 using System.Collections; 해주어야 한다.
      ex.Data.Add ("라이브러리명", "쿠다라이브러리를 쓴 알고리즘");
      ex.Data.Add ("루틴명", "패널모서리 검출루틴");
      throw ex;
	#+end_src
	
	catch() 블럭에서

	- e.TargetSite.ToString()--> ex: Void accellerate(Int32)
	- e.TargetSite.DeclaringType() --> ex: SimpleExceptionTest.Car
	- e.TargetSite.MemberType --> ex: "Method"
	- e.Source --> ex: "SimpleException"
	- e.Message -> ex: "Zippy has overheated"
	- e.StackTrace --> 예외를 던지는 순간부터 현재 호출측까지의 call stack
	- e.Data 는 아래같이
   
     #+begin_src csharp
       // throw 한 쪽에서 넘겨주는 custom data들을 출력해본다
       foreach (DictionaryEntry dataEntry in e.Data)
           Console.WriteLine("->{0}: {1}", dataEntry.key, dataEntry.Value);
       }
     #+end_src

*** 시스템수준 예외(System.SystemException)

	.NET 플랫폼이 던지는 예외를 말함. 이 예외가 던져지면 복구할 수
	없는 치명적 오류가 발생했음을 의미한다.

	IndexOutOfRangeException, StackOverflowException 등등
	--> 모두 System.SystemException 에서 파생된 예외 클래스들.

	이 예외는 거의 crash 급에 해당하는 것들이다.

*** 응용수준 예외(System.ApplicationException)

	사용자의 코드에서 예외를 던질때 예외클래스는 가급적 Exeption
	클래스가 아니라 ApplicationException 클래스에서 파생되도록 한다.
	...고 말했지만, 대부분의 개발자들은 단순히 System.Exception 예외를
	코드에서 던져버린단다. MSDN 에서도 "실제적으로는"
	ApplicationException 으로 부터 파생받은 클래스를 정의하는 것이
	그다지 큰 유용성이 없다고 하네. 원래는 다른 모든 타입의
	Exception과 타입의 차이를 두기 위해 만들었다고 하네.

	MSDN 왈

	#+begin_example
	User applications, not the common language runtime, throw custom
	exceptions derived from the ApplicationException class. The
	ApplicationException class differentiates between exceptions
	defined by applications versus exceptions defined by the system.

	If you are designing an application that needs to create its own
	exceptions, you are advised to derive custom exceptions from the
	Exception class. It was originally thought that custom exceptions
	should derive from the ApplicationException class; however in
	practice this has not been found to add significant value. For
	more information, see Best Practices for Handling Exceptions.
	#+end_example

	하지만 Exception 말고 ApplicationException 을 부모클래스로 하는
	예외클래스를 정의하는게 머 그리 나쁜건 아닐듯.

*** 사용자 정의 예외 클래스 만들기

	- Exception 또는 ApplicationException 에서 파생
	- [System.Serializable] 어트리뷰트 지정
	- (1) 기본생성자 (2) Inner Exception지정하는 생성자 (3) 직렬화를
      처리하는 생성자

     visual studio 의 예외 code snippet 기능을 써보자.
	 Exception이라 에디터에 치고 TAB을 두번 치면
	 
	 #+begin_src csharp
       [Serializable]
       public class CarException : ApplicationException
       {
           public CarException() { }
           public CarException(string message) : base(message) { }
           public CarException(string message, Exception inner) : base(message, inner) { }
           protected CarException(
                   System.Runtime.Serialization.SerializationInfo info,
                   System.Runtime.Serialization.StreamingContext context)
               : base(info, context) { }
       }
	 #+end_src
	 
	 이런식으로 만들어진다. 추가적인 멤버넣고 만들면 된다.

*** catch() 가 여러개 오는 경우

	상위 클래스의 Exception 클래스형이 더 나중에 와야 컴파일 에러가
	나지 않는다. 즉, more specific exception 이 먼저 catch() 되도록
	해야 한다.

*** 일반화된 catch 구문

	C++ 의 catch(...) 이 C# 에서는 "catch"

	#+begin_src csharp
      try
      {
          myCar.accelerate(90);
      }
      catch
      {
          // any exception!
      }
	#+end_src

*** rethrowing

	받은 예외를 다시 밖으로..
	catch 블럭 안에서 =throw;= 라고만 치면 된다.

	일반적인 처리를 하고, 다시 바깥세상에 이 예외발생을 알려야 하는
	경우에 사용한다.

*** Inner Exception

	생소한 개념일 수 있지만, 예외처리를 하다 예외가 또 발생하는 경우,
	처리하던 예외가 Inner Exception이 된다. 아래의 예만 보면 바로
	이해.

	#+begin_src csharp
      try
      {
          // 무언가를 하다 CarIsDeadException 이 던져지는 코드 블럭이 여기
          // 있다고 가정
      }
      catch (CarIsDeadException e)
      {
          try
          {
              FileStream fs = File.Open(@"C:\carErrors.txt", FileMode.Open);
              // ...
          }
          catch (Exception e2)
          {
              // 어쨌든 CarIsDeadException이므로 Inner Exception은 e2 가
              // 된다. 맨 바깥쪽 try 문에서 하던 작업에 대한 예외가 Outer
              // Exception.
              throw new CarIsDeadException(e.Message, e2);
          }
      }
	#+end_src

*** finnaly 블럭
	반드시 있어야 하는 블럭은 아니다. optional이다. 무슨 짓을 하더라도
	try/catch 의 내용이 다 실행되고 난다음 반드시 실행되는 블럭이다. 

	파일을 close 하거나 데이터베이스 객체를 detach 하거나 하는 작업이
	보통 이루어지는 곳이다. 
*** 대체 누가 무슨 예외를 던지는 거야? 그리고 꼭 해야되?
	대답은 .NET SDK문서를 봐! 또는 Visual Studio 에디터의 툴팁을
	활용해! 이다.
	Java 는 checked exception 개념을 메소드 선언시에 포함시켜 "반드시
	예외처리를 해야하는 함수"를 정의할 수 있지만, .Net은 그런거 없다.
	하지만, 왠만하면 하지....인가.
*** Unhandled Exception. the Crash...
	근데, 디버거상에서 이게 발생하면 분석하기 쉬운 대화상자가 뜬다. 오.
	
** 8장. 인터페이스로 작업하기
*** 인터페이스 타입이란.
	- 공식 정의 : named set of /abstract/ members
	- 음. /abstract/ 메소드를 가지는 /class/ 와 유사하네.
	- C# 에서는 class형을 통한 다중상속은 불가능하다.
	- 다중상속을 통해서 깔끔하게 해결할 수 있는 문제들은 interface
      type 으로 해결한다.
	  
*** 인터페이스 타입 정의하기

	- 데이터 필드를 정의할 수 없다. *하지만 속성은 포함할 수 있다(auto
      property인데, 읽기쓰기,읽기전용,쓰기전용 모두 된다! class에서는
      auto property는 읽기쓰기만 되었지만!)*
	- 생성자를 정의할 수 없다.
	- 메소드는 암묵적으로 'public abstract'. *굳이 public 을 명시하지
      않아도 됨*
	- 메소드 구현을 포함하면 안된다.

	#+begin_src csharp
      public interface IPointy
      {
          // 'abstract'를 안써도 'abstract'.
          // 'public' 을 안써도 'public'
          byte GetNumberOfPoints();
          // 아래와 같은 자동속성 선언을 할 수 있다. class에서는 get;set; 을
          // 다써야 되었지만..
          byte Points { get; }
      }
	#+end_src

	- 인터페이스 정의자체로는 인스턴스 생성못함(C++의 ABC와 동일한 개념)
	
*** 인터페이스 상속받아 구현하기.

	- all or nothing 방식 : 인터페이스의 모든 내용이 전부 구현되기
      전에는 해당 인터페이스 상속 class/struct 는 생성하지 못한다.
	- *인터페이스의 선언은 public을 쓰지 않지만*, 실제로 이를 구현할
      class/struct 의 정의에서는 *public을 명시해야 한다*.
	- 단, *명시적 인터페이스 정의* 의 경우 암시적으로 private 이되므로
      구현시 *오히려 public 을 사용하지 않는다*.
	- 인터페이스 정의시 *override 키워드를 쓰지 않는다*

*** /is/ , /as/ 키워드 및 InvalidCastException

	- /is/ : 역시 형격상 및 형격하 문제. /is/ 를 사용하여 다른 언어에서
      /isKindOfClass(클래스명)/ 방식의 형 유추를 할 수 있다.
	- /as/ : VB 에서 사용하던 개념과 비슷하네. 형 유추가 되지 않으면
      null 값이 반환된다.
	  
	  #+begin_src csharp
        IPointy pointy = hex as IPointy;
        if (pointy != null)
        {
            Console.WriteLine("hex는 IPointy 형을 지원");
        }
	  #+end_src

	- InvalidCastExcpetion 예외
   
	  /is/ 나 /as/ 를 사용하지 않고, 일단 강제적으로 형변환을 시키는
      경우, 형이 맞지 않으면 이 예외가 던져진다. /is/ 나 /as/ 는 이
      예외를 발생시키지 않는다.

*** 인터페이스간 이름충돌해결 및 명시적 인터페이스 구현(Explicit Interface Impl)

	2개 이상의 인터페이스로 부터 상속받는 경우, 그 2개 이상의
	인터페이스에 동일한 시그너쳐의 메소드, 속성이 있는 경우, 단순한
	방법으로는 이들을 구분할 방법이 없다. 그런 경우,

	=returnType InterfaceName.MethodName(params) {}=

	의 방식으로 "어떤 인터페이스의 메소드를 정의하는지"를 명확히 할 수
	있다. *단, 이 경우 구현된 메소드는 자동으로 private 이 되므로,
	public 접근자를 붙이면 안된다*.

	좀 긴 예를 만들어봄.

	#+begin_src csharp
      using System;
      
      public interface IGdiDrawer {
          void Draw();
      }
      public interface IQtDrawer {
          void Draw();
      }
      public interface IWxDrawer {
          void Draw();
      }
      
      class UltraDrawer : IGdiDrawer, IQtDrawer, IWxDrawer {
          void IGdiDrawer.Draw() {
              Console.WriteLine("IGdiDrawer.Draw()");
          }
          void IQtDrawer.Draw() {
              Console.WriteLine("IQtDrawer.Draw()");
          }
          void IWxDrawer.Draw() {
              Console.WriteLine("IWxDrawer.Draw()");
          }
      }
      
      class ExplicitInterfaceImpl {
          static void DrawQt(IQtDrawer drawer) {
              drawer.Draw();
          }
          public static void Main() {
              UltraDrawer drawer = new UltraDrawer();
              DrawQt(drawer);
          }
      }
	#+end_src

	추가로, *명시적 인터페이스 구현은 이름 충둘이 없는 경우에도
	쓰인다는 점* 이다. 명시적 인터페이스 구현을 할 경우, 자동으로 그
	메소드는 외부로 노출이 되지 않기 때문에(기본이 protected 이며,
	public 을 지정할 수 없기때문에), 어떤 인터페이스의 구현을 외부로
	노출하지 않고자 하는 경우에도 사용된다.

*** 인터페이스로 상속계층 구성하기

	- 어떤 인터페이스 'B' 는 다른 인터페이스 'A' 로 부터 상속받은
      상태에서 인터페이스를 선언/정의할 수 있다. 그런 경우, 이 새로운
      'B' 인터페이스를 구현할 때는 부모 'A' 인터페이스를 포함한 모든
      메소드/속성을 정의해야 한다.
	- 다중상속시 name clash (이름 충돌)을 대비하기 위해 명시적
      인터페이스 구현(explicit interface implementation)을 항상 염두에
      두자.
	  
*** 실제예 : IEnumerable 과 IEnumerator 인터페이스

	어느 객체든 =IEnumerable= 의 =IEnumerator GetEnumerator()= 을
	구현하는 놈이면 =foreach= 구문을 사용해 순회할 수 있다.

	#+begin_src csharp
      public interface IEnumerable
      {
          IEnumerator GetEnumerator();
      }
      public interface IEnumerator
      {
          bool MoveNext(); // 커서를 다음 항목으로
          object Current { get; } // 현재 항목 얻기(읽기 전용)
          void Reset(); // 첫번째 항목 바로 앞으로 커서 이동(past to start)
      }
	#+end_src

	- *반드시 IEnuemrable로 부터 상속받지 않아도 되더라.*
	- *단순히 IEnumerator GetEnumerator() 만 추가하면 되더라*
	- *yield 를 쓰면 구체적으로 IEnumerator의 여러 메소드를 구현하지
      않아도 쉽게 구현을 마칠 수 있더라*

	- 이름이 있는 named enumerator 의 구현을 쓰면 좀 더 특이한
      순회방법을 제공할 수 있더라(예: 역순으로 순회, 어떤 값을 가지는
      놈들만 순회,...) *단, 반환타입이 IEnumerator 가 아니라
      IEnumerable 임에 유의*

	  #+begin_src csharp
        public class Garage// : IEnumerable
        {
            Car[] carArray;
            public Garage()
            {
                carArray = new Car[] {
                    new Car("Rusty", 30),
                    new Car("Clunker", 55),
                    new Car("Shiny", 90),
                    new Car("OldTred", 10)
                };
            }
            // 디폴트 enumerator 반환자. 전체를 순서대로 순회. 
            public IEnumerator GetEnumerator()
            {
                foreach (Car car in carArray)
                {
                    yield return car;
                }
            }
            // 이름있는 enumerator. 속도가 어느 이상되는 놈들만 순회
            // 반환 타입이 IEnumerable 임에 유의!!!!!
            public IEnumerable CarsFasterThan(int maxSpeed)
            {
                foreach (Car car in carArray)
                {
                    if (car.MaxSpeed >= maxSpeed)
                    {
                        yield return car;
                    }
                }
            }
        }
	  #+end_src

*** 실제예 : ICloneable 인터페이스

	

	ICloneable 는 다음과 같은 인터페이스

	#+begin_src csharp
      public interface ICloneable
      {
          object Clone();
      }
	#+end_src

	의 메소드는 아니지만, 이 인터페이스는 =System.Object=
	의 =MemberWiseClone()= 메소드와 연관지어 알아두어야 한다.
	*MemberWiseClone() 은 클래스 내부에서만 사용되는 protected
	메소드이며, deep copy 가 아니라 shallow copy 를 수행한다*
	하지만, shallow copy 라는 말의 의미가 ValueType 멤버에 대해서는
	조금 다른 의미가 된다.

	실제 MSDN 의 MemberwiseClone() 의 설명을 보면 다음과 같다. 

	#+begin_example
	 MemberwiseClone 메서드는 새 개체를 만들고 현재 개체의 비정적
	 필드를 새 개체로 복사하여 단순 복사본을 만듭니다.필드가 값 형식인
	 경우 필드의 비트별 복사가 수행됩니다.필드가 참조 형식인 경우
	 참조는 복사되지만 참조되는 개체는 복사되지 않으므로 원본 개체와
	 복사된 개체는 동일한 개체를 참조합니다
	#+end_example

	즉, MemberwiseClone 으로 복제된 ValueType 은 복제된 객체에서의 값
	변경이 원본의 값변경을 의미하지 않지만, RefType 은 복제된
	객체에서의 값 변경이 원본의 값변경을 의미하게 된다.

	완전한 DeepCopy 를 수행하려면, RefType 에 대한 명시적 복제가
	이루어져야 한다.

	즉,

	#+begin_src csharp
      using System;
      
      public class IdInfo {
          public int IdNumber; 
          public IdInfo(int IdNumber) {
              this.IdNumber = IdNumber;
          }
      }
      
      public class Person  {
          public int Age;
          public string Name;
          public IdInfo IdInfo;
          public Person ShallowCopy() {
             return (Person)this.MemberwiseClone();
          }
          // 전체객체를 독립적으로 새로 생성
          public Person StandAloneDeppCopy() {
              Person other = new Person();
              other.Age = this.Age;
              other.Name = this.Name;
              other.IdInfo = new IdInfo(this.IdInfo.idNumber);
              return other;
          }
          // 얕은 복사후 bitwise copy 된 ValueType을 제외한 나머지 RefType에
          // 대해서만 새로운 객체를 수작업 생성/복제
          public Person DeepCopy() {
             Person other = (Person) this.MemberwiseClone(); 
             other.IdInfo = new IdInfo(this.IdInfo.IdNumber);
             return other;
          }
      }    
	#+end_src

*** 실제예 : IComparable 인터페이스

	객체 목록을 =Sort()= 할 때 predicator 역할을 하게되는 인터페이스

	#+begin_src csharp
      public interface IComparable
      {
          int CompareTo(Object o);
      }
	#+end_src

    | CompareTo()의 반환값 | 설명                                            |
    |----------------------+-------------------------------------------------|
    | 0 보다 작은 값       | 이 객체가 인자로 넘어온 객체보다 앞에 오게 된다 |
    | 0                    | 동일 위치                                       |
    | 0 보다 큰 값         | 이 객체가 인자로 넘어온 객체보다 뒤에 오게 된다 |

	구현 예는 다음과 같다.

	#+begin_src csharp
      class Car : IComparable {
          int IComparable.CompareTo(object obj) {
              Car rhs = obj as Car;
              if (rhs!=null) {
                  if (this.CarId > temp.CarId) {
                      return 1;
                  } else if (this.CarId < temp.CarId) {
                      return -1;
                  } else {
                      return 0;
                  }
              }
          }
      }
	#+end_src

	위와 같이 IComparable 인터페이스를 구현한 객체들의 목록(예:
	배열)은 =Array.Sort(객체목록)= 의 =System.Array= 클래스메소드를
	사용해 정렬할 수 있다.

	#+begin_src csharp
      Car[] carList = new Car[] {
          // 여기서 자동차 목록을 초기화
      };
      
      // 이제 정렬
      Array.Sort(carList);
	#+end_src

	이 객체를 정렬하는 기준을 여러가지로 한다면(자동차 이름순,
	최고속도 순...등등) *이름있는 별도의 IComparer 구현객체*
	생성함수를 만들어 주면 된다.

	#+begin_src csharp
      public class NameComparer : IComparer {
          int IComparer.Compare(object o1, object o2) {
              Car c1 = o1 as Car;
              Car c2 = o2 as Car;
              if (c1 != null && c2 != null) {
                  return String.Compare(c1.Name, c2.Name);
              } else {
                  throw new ArgumentException("Parameter is not Car!");
              }
          }
      }
      
      // 유용한 관례. IComparer 를 반환하는 정적 속성을 정의
      // 이름은 "SortBySomeCondition" 이런식으로..
      class Car {
          static public IComparer SortByName {
              get {
                  return (IComparer)new NameComparer();
              }
          }
      }
	#+end_src

	위와 같은 .NET 에서의 관례를 따라 별도의 IComparer 객체를 생성할
	수 있게 되면 다음과 같이 깔끔하게 정렬루틴을 호출가능(코드를
	읽기도 아주 편함)

	#+begin_src csharp
      Array.Sort(myCarList, Car.SortByName);
	#+end_src

** 9장. 컬렉션(Collections)과 제네릭(Generics)
*** 컬렉션(그리고 제네릭)이 등장한 이유.
	자료구조를 담는 용도로 가장 기초적인 "배열"은 *고정크기* 의
	컨테이너이기 때문. 추가/삭제에 용이하고 성능이 좋은 어떤
	컨테이너가 필요하게 됨. --> System.Collections 등장 --> .NET 2.0
	부터는 System.Collections.Generic 등장

	Generic 은 NonGeneric 에 비해 TypeSafe 하고, 메모리효율을 좋게한
	컨테이너이다. 
*** System.Collections 네임스페이스
	최근 추세(?)는 *더이상 System.Collections 네임스페이스를 안쓴다* 는
	것이다. 대부분 *System.Collections.Generic 네임스페이스* 를 쓴다.

	System.Collections 의 모든 컬렉션은 ICollection(IEnumarable
	파생클래스), ICloneable 의 인터페이스를 구현한다

    | 클래스     | 실생활에서의 예    | 주요 인터페이스 |
    |------------+--------------------+-----------------|
    | ArrayList  | 동적크기. 시퀀셜   | IList,          |
    |            |                    | ICollection,    |
    |            |                    | IEnumerable,    |
    |            |                    | ICloneable      |
    |------------+--------------------+-----------------|
    | BitArray   | 비트의 compact배열 | ICollection,    |
    |            |                    | IEnumerable     |
    |            |                    | ICloneable      |
    |------------+--------------------+-----------------|
    | HashTable  | std::unordered_map | IDictionary,    |
    |            | QHashMap           | ICollection     |
    |            |                    | IEnumerable,    |
    |            |                    | ICloneable      |
    |------------+--------------------+-----------------|
    | Queue      | FIFO               | ICollection,    |
    |            |                    | IEnumerable     |
    |            |                    | ICloneable      |
    |------------+--------------------+-----------------|
    | SortedList | std::map(키 정렬)  | IDictionary,    |
    |            |                    | ICollection,    |
    |            |                    | IEnumerable,    |
    |            |                    | ICloneable      |
    |------------+--------------------+-----------------|
    | Stack      | std::stack         | ICollection,    |
    |            |                    | IEnumerable,    |
    |            |                    | ICloneable      |

	주요 인터페이스 정리

    | 인터페이스  | 실생활 예                       |
    |-------------+---------------------------------|
    | ICollection | size, enumeration, 쓰레드안정성 |
    | ICloneable  | 복제                            |
    | IDictionary | 키/값 쌍                        |
    | IEnumerable | IEnumerator 구현 객체 반환      |
    | IEnumerator | foreach 순회방법 구현           |
    | IList       | add/remove/index접근            |

*** System.Collections.Specialized 네임스페이스

	결국 Generic 을 쓰게 되겠지만, 이런 것도 있다.

    | 클래스           | 실생활 예                                            |
    |------------------+------------------------------------------------------|
    | ListDictionary   | 10개정도 이하의 작은수의 항목들에 유리. 단일연결목록 |
    | HybridDictionary | ListDictionary 를 사용해 IDictionary 구현            |
    |                  | 갯수가 늘면 HashTable로 변환해야 성능이 나옴         |
    | StringCollection | 꽤 많은 양의 문자열 데이터를 핸들링                  |
    | BitVector32      | 32비트 메모리에 Bool값을 담기에 적당                 |

*** NonGeneric Collection 의 문제
	- 모든 항목을 System.Object 에 담기 때문에 ValueType 의 경우,
      Boxing/Unboxing을 할 텐데, 그러는 과정중에 메모리 복사가 계속
      일어나 성능저하를 일으킨다.
	- TypeSafe 하지 않게된다. 
	
*** Generic Collection 기초
	전반적으로 C++ template class와 거의 동일 개념. IEnumerable<T> 는
	"IEnumerable of type T" 라고 읽는다.
	=T= 라는 것을 보통 *placeholder* 라고 하는데, 그 이름은 개발자가
	마음대로 지을 수 있으나(즉, T 가 아닌 다른 이름), 일반적으로 T 는
	Type을, TKey 나 K 는 /key/ 의 type을 TValue 나 V 는 /value/ 의
	type을 지칭하도록 하는게 일반적이다.

	#+begin_src csharp
      public class Car : IComparable<Car>
      {
          // ...
      
          // 입력 인자가 Object형이 아니라 Car형이 된다.
          int IComparable<Car>.CompareTo(Car otherCar)
          {
              // object형을 car 로 unboxing할 필요가 없다.
              if (this.CarId > otherCar.CarId) {
                  return 1; // out-of-order
              } else if (this.CarId < otherCar.CarId) {
                  return -1; // in-order
              } else {
                  return 0; // same
              }
          }
      }
      // 실제 사용시..
      Array<Car> carList;
      carList.Add (new Car(...));
      // ...추가
      Array.Sort(carList);
	#+end_src

	System.Collections.Generic 네임스페이스에는 다음과 같은
	인터페이스와 클래스가 있다.


    |---------------------------+---------------------------------------|
    | 인터페이스                | 실생활 예                             |
    |---------------------------+---------------------------------------|
    | ICollection<T>            | size, enum, thread의 특징을 구현      |
    | IComparer<T>              | 2 객체를 비교하는 방법                |
    | IDictionary<TKey, TValue> | Key/Value 쌍으로 된 내용을 집합       |
    | IEnumerable<T>            | IEnumerator<T> 를 반환                |
    | IEnumerator<T>            | foreach 형태로 순회하도록 구현        |
    | IList<T>                  | 순차객체 목록을 add/remove/index 처리 |
    | ISet<T>                   | 집합 개념을 처리                      |
    |---------------------------+---------------------------------------|

	모든 Collections.Generic 클래스는 위 인터페이스 중 ICollection<T>,
	IEnumerable<T> 는 반드시 구현한다( 단, *Queue<T> 와 Stack<T> 는
	ICollection<T> 가 아니라 ICollection 을 구현한다* ).

	(MSDN 을 보니, List<T> 는 IList<T>뿐 아니라, IList도,
	ICollection<T> 뿐 아니라 ICollection 도, IEnumerable<T> 뿐 아니라
	IEnumerable 도 구현하고 있네!)

    |-------------------------------+--------------------------+----------------------------|
    | 클래스                        | 추가 구현 인터페이스     | 실생활 예                  |
    |-------------------------------+--------------------------+----------------------------|
    | Dictionary<TKey, TValue>      | IDictionary<TKey,TValue> | key/value 집합             |
    | LinkedList<T>                 |                          | 이중연결목록               |
    | List<T>                       | IList<T>                 | 동적크기 변경가능 순차목록 |
    | Queue<T>                      | ICollection(! <T>아님!!) | FIFO 목록                  |
    | SortedDictionary<TKey,TValue> | IDictionary<TKey,TValue> | 정렬된 key/value 집합      |
    | SortedSet<T>                  | ISet<T>                  | 중복없이 정열된 객체 집합  |
    | Stack<T>                      | ICollection(! <T>아님!!) | LIFO 목록                      |

	얘들은 모두 mscorlib.dll, System.dll, System.Core.dll 에 구현이
	흩어져 있다.

*** Generic 사용법 기초 : 컬렉션 초기화 구문(Collection Initialization Syntax)
	객체 초기화 구문(Object initialization syntax)에 대한 Generic 의
	counterpart. /new/ 로 객체생성 바로 직후 세미콜론 찍기 전에
	중괄호를 사용해 초기화할 객체의 목록을 기록. 객체 초기화 구문과
	유사함. 객체 초기화 구문을 사용해 각각의 항목을 초기화 가능.

	#+begin_src csharp
      List<Point> myPointList = new List<Point>
      {
          new Point { X=2, Y=3 }, 
          new Point { X=10, y=4 },
          new Point(PointColor.BloodRed) { X=4, Y=5},
      };
      // 위의 초기화 구문이 없었다면, 아래처럼 ...
      myPointList.Add (new Point { X=2, Y=3 });
      myPointList.Add (new Point { X=10, y=4 });
      myPointList.Add (new Point(PointColor.BloodRed) { X=4, Y=5});
	#+end_src

*** List<T> 사용법

	- 생성자 : List<T>(IEnumerable<T>) 는 다른 컬렉션에서 요소 복사,
      List<T>(Int32) 는 초기용량을 지정하여 생성
	- 속성 : Count 는 갯수, Capacity 는 용량, Item 은 Index 속성
	- 메소드 : 
      Add/AddRange 는 항목1개/여러항목을 뒤에 추가,
	  Insert/InsertRange 는 항목1개/여러항목을 특정위치에 추가,
	  RemoveAt/RemoveRange 는 항목1개/여러항목을 특정위치에서 제거,
	  Remove/RemoveAll 는 넘겨진 객체와 같은(EqualityComparer<T>)
      객체를 먼 처음1개 또는 전체 삭제
	  IndexOf 는 특정개체를 찾아 위치를 반환.
	  Sort/Reverse 는 정렬/역정렬
	  Clear 는 전체 삭제ㄱ
	
	#+begin_src csharp
      List<Person> people = new List<Person>() {
          // 컬렉션 초기화 구문으로 초기화
      };
      people.Insert(2, new Person("준환", 42));
      
      // 어느때라도 배열로 변환이 가능.
      Person[] personArray = people.ToArray();
      Console.WriteLine("first person = {0}", personArray[0]);
	#+end_src

*** Stack<T> 사용법

	- Push : 객체를 stack 에 밀어넣음.
	- Pop : 맨 마지막에 넣은 객체를 빼내옴.
	- Peek : 맨 마지막에 넣은 객체를 확인함.

*** Queue<T> 사용법

    - Enqueue : 맨 뒤쪽에 항목을 추가함
	- Dequeue : 맨 앞쪽의 항목을 빼내옴
	- Peek    : 맨 앞쪽의 항목을 확인함

*** SortedSet<T> 사용법

	T 형의 클래스가 IComparer<T> 형을 구현하고 있다면, SortedSet<T>
	컬렉션을 써서, 정렬된 상태를 위지하며 중복이 되지 않는 목록을
	구성한다.

	#+begin_src csharp
      class SortByAgeComparer : IComparer<Person> {
          int IComparer<Person>.Compare(Person lhs, Person rhs) {
              if (lhs.Age < rhs.Age)
                  return -1; // in order
              else if (lhs.Age > rhs.Age)
                  return 1; // out of order
              else
                  return 0; // same
          }
      }
      public static void Main()
      {
          // Person 의 IComparable.CompareTo()에 따라 정렬된 Set
          SortedSet<Person> personSet = new SortedSet<Person> {
              new Person("준환", 42),
              new Person("신영", 38),
              new Person("서연", 11),
              new Person("은서", 5)
          };
          // 나이 순서로 정렬된 Set
          SortedSet<Person> personSet = new SortedSet<Person>(new SortByAgeComparer()) {
              new Person("준환", 42),
              new Person("신영", 38),
              new Person("서연", 11),
              new Person("은서", 5)
          };
      }
	#+end_src

*** System.Collections.ObjectModel 네임스페이스
	어떤 컬렉션에 항목이 추가/삭제/전체Referesh등의 동작이 수행될 경우
	외부에 그 사실을 통지해 줄 수 있는 class 들이 들어있는
	네임스페이스.

    | Type                            | 실제 예                                                   |
    |---------------------------------+-----------------------------------------------------------|
    | ObservableCollection<T>         | 항목추가/삭제/전체갱신등이 이루어 질 때                   |
    |                                 | 외부에 그 사실을 통지할 수 있는 동적 데이터 컬렉션을 구현 |
    | ReadOnlyObservableCollection<T> | ObservableCollection<T> 와 동일하지만, 읽기 전용 버젼     |

*** ObservableController<T> 사용하기
	이 클래스는 /CollectionChanged/ 라는 이벤트를 지원한다. 컬렉션에
	변경이 가해지면 이 이벤트가 fire 된다.

	아래는 가장 간단한 예제.

	#+begin_src csharp
      class People : ObservableCollection<Person> {
          public People() {
              CollectionChanged += LogChange;
          }
          public void LogChange(object sender,
                                System.Collections.Specialized.NotifyCollectionChangedEventArgs e) {
              // e.Action -> NotifyCollectionChangedAction.Add/Remove/Replace/Move/Reset..
              Console.WriteLine("CollectionChanged : reason={0}", e.Action.ToString());
              var people = sender as ObservableCollection<Person>;
              foreach (var person in people) {
                  Console.WriteLine("{0}", person);
              }
          }
      }
      class ObserverTest {
          public static void Main() {
              var people = new People() {
                  new Person("준환", 42),
                  new Person("신영", 38),
                  new Person("서연", 11),
                  new Person("은서", 5)
              };
              foreach (var person in people) {
                  Console.WriteLine("{0}", person);
              }
      
              Console.WriteLine("가족을 추가합니다..");
              people.Add (new Person("가은", 7));
      
              Console.WriteLine("가족을 삭제합니다..");
              people.RemoveAt(people.Count-1);
      
              Console.WriteLine("가족을 클리어합니다...");
              people.Clear();
          }
      }
	#+end_src

	System.Collections.Specialized.NotifyCollectionChangedEventArgs
	타입은
	- /Action/ 속성 :(NotifyCollectionChangedAction enum값) -->
      Add,Remove,Reset,..
	- /OldItems/ 속성 : Remove 된 항목들의 목록
	- /NewItems/ 속성 : Add 된 항목들의 목록
*** 사용자 정의 제네릭 메소드(Custom Generic Method)
	C++ template function 에서와 마찬가지로 생각하면 된다.
	다만, 전역함수를 만들 수가 없네 C# 에서는?
	어쨌든 정적 멤버/인스턴스 멤버 메소드를 template 으로 만들 수
	있다. 이렇게 만들어진 제네릭 메소드를 호출할 때 /<T>/ 에 해당하는
	타입을 명시적으로 넣어서 호출해야 하지만, 종종 타입유추가 뻔한
	경우에는 생략해도 *컴파일러가 알아서 <T> 부분을 넣어준다*

	#+begin_src csharp
      public static class MyGenerics
      {
          public static void Swap<T>(ref T a, ref T b)
          {
              Console.WriteLine("Instance Swaping object of {0} type", a.GetType());
              T temp = a;
              a = b;
              b = temp;
          }    
      }
      
      // 사용할 때 <T> 를 명시해도 되고...
      MyGenerics.Swap<Person>(ref me, ref you);
      // 유추가 가능한 경우에는 그냥 <T> 없이 호출해도 된다.
      MyGenerics.Swap(ref me, ref you);
	#+end_src
*** /default/ 키워드
	/default/ 키워드는 switch/case 문에서도 사용되지만, 어떤 타입에
	대해 함수처럼 호출하면

	- Numeric 의 경우 : 0
	- RefType 의 경우 : null
	- ValueType 의 경우 : 모든 멤버가 0 또는 nil

	  의 값을 가지도록 한 디폴트 값을 반환한다. 

	#+begin_src csharp
      var defaultPoint = default(Point<int>); // x=0, y=0
      int defaultInt = default (int); // 0
	#+end_src

	어떤 타입의 ResetValue() 같은 멤버를 구현할 때 유용.

*** /where/ 키워드로 <T> 의 형식에 제한을 걸기
	종종 <T> 타입이 "...어떠어떠한 타입인 경우에만 사용할 수 있다"는
	식으로 제한을 둘 수 있다.

	- /where T : class/  --> T 는 RefType 이어야 한다.
	- /where T : struct/ --> T 는 ValueType 이어야 한다.
	- /where T : new()/ --> T 는 기본생성자를 가져야 한다. 다시말해,
                /new T()/ 할 수 있어야 한다.
	- /where T : IDrawable/ --> T 는 어떤 인터페이스를 구현해야 한다.
	- /where T : GdiDrawable/ --> T 는 어떤 타입에서 상속된 타입이어야 한다.
    
	이걸 여러개 나열하여 복합 제한을 만들 수 있다. 또한 여러개의 타입
	placeholder 들에 대해서 따로 따로 제한을 둘 수 있다. 최대한
	복잡한(?) 예를 들어보면.

	#+begin_src csharp
      // K 는 SomeBaseClass 의 파생클래스이면서 기본생성자를 가져야 한다.
      // T 는 ValueType 이면서 IComparable<T> 를 구현해야 한다.
      public class MyGenericClass<K, T>
          where K : SomeBaseClass, new ()
          where T : struct, IComparable<T>
      {
          // 구현
      }
      
      // T 가 ValueType이어야 한다.
      static void SwapValueTypeOnly<T>(ref T a, ref T b) 
          where T : struct
      {
          // 
      }
	#+end_src

	이 제약사항이 코드에서 지켜지지 않으면, 컴파일러가 오류 메시지를 뿜는다.

*** Generic 코드에서는 4칙연산을 오버로딩하기가 어렵다.

	Add/Subtract/Divide/Multiply 를 구현을 어떻게 하지? 나중에 알게된단다.
	

** 10장. Delegate(대리자), Event, 그리고 람다표현(Lambda Expression)
*** Delgate 이해하기
	Delegate란 다음의 3가지 정보(혹은 그 목록)를 담고 있는 TypeSafe
	객체.

	1) 호출할 메소드의 어드레스(*정적 메소드 / 인스턴스 메소드 모두 포함*)
	2) 메소드의 파라메터들
	3) 메소드의 반환값
	
	Delegate 를 통해 런타임에 저장된 메소드를 호출하는 방식도

	- *비동기 호출* (오 예!)
	- 동기 호출
   
	*모두* 가능하다.

*** Delegate 정의하는 법 : /delegate/ 키워드

	#+begin_src csharp
      // MyOtherDelegate 라는 이름의 delegate 를 정의
      public delegate string MyOtherDelegate(out bool a, ref bool b, int c);
	#+end_src

	위와 같이 하면 delegate가 정의된다. 실제로 위의 코드를 C#
	컴파일러가 컴파일 하면, /System.MultiCaseDelegate/
	(/System.Delegate/ 의 파생클래스) 로 부터 파생된 Delegate이름(즉,
	MyOtherDelegate)의 *클래스가 정의* 된다. ( *함수처럼 보이지만,
	실제로는 클래스 타입이 정의된다!*)

	#+begin_src csharp
      sealed class MyDelegate: System.MulticastDelegate 
      { 
          public string Invoke(bool a, bool b, bool c); 
          public IAsyncResult BeginInvoke(bool a, bool b, bool c, 
                                          AsyncCallback cb, object state); 
          public string EndInvoke(IAsyncResult result); 
      } 
	#+end_src

	이 중 Invoke() 메소드는 동기호출을, BeginInvoke/EndInvoke 는
	비동기 호출시 사용된다. 하지만, 컴파일러가 생성한 이 클래스의
	객체를 만들어 이들 메소드를 호출 할 일은 없다. C# 이 제공하는
	별도의 구문을 써서 하게 될 것이다.

*** System.MulticastDelegate 와 System.Delegate 기반클래스

	요약하면 아래와 같이 생긴 클래스(일부 멤버만 있음!)

	#+begin_src csharp
      public abstract class Delegate : ICloneable, ISerializable 
      { 
          // 호출할 함수들의 목록을 추가/삭제하는 기능
          public static Delegate Combine(params Delegate[] delegates);
          public static Delegate Combine(Delegate a, Delegate b); 
          public static Delegate Remove(Delegate source, Delegate value); 
          public static Delegate RemoveAll(Delegate source, Delegate value); 
      
          // 오버로딩된 연산자들
          public static bool operator ==(Delegate d1, Delegate d2); 
          public static bool operator !=(Delegate d1, Delegate d2); 
      
          // delegate의 대상에 대한 정보
          public MethodInfo Method { get; } // 함수 포인터 역할
          public object Target { get; }  // static 함수가 아닌 경우 객체의 포인터가 필요하다.
      }
      
      public abstract class MulticastDelegate : Delegate 
      { 
          // 가리키고 있는 메소드들의 목록
          public sealed override Delegate[] GetInvocationList();
      
          // 오버로딩된 연산자
          public static bool operator ==(MulticastDelegate d1, MulticastDelegate d2); 
          public static bool operator !=(MulticastDelegate d1, MulticastDelegate d2); 
      
          // Delegate가 관리하는 메소드 목록의 관리를 위한 내부적으로 사용되는 것들
          private IntPtr invocationCount; 
          private object invocationList; 
      }     
	#+end_src

	앞서 보았던 이벤트 처리시 *+=* 연산자는 Combine() 메소드와, *-=*
	연산자는 Remove() 메소드와 관련이 있음.

*** 초간단 Delegate 사용해보기
	#+begin_src csharp
      public delegate int BinaryOp(int x, int y);
      
      class SimpleMath {
          public static int Add (int a, int b) {
              return a + b;
          }
          public static int Subtract(int a, int b) {
              return a - b;
          }
      }
      class SimpleDelegateTest {
          public static void Main() {
              BinaryOp b = new BinaryOp(SimpleMath.Add);
              // b(10,5) 하면 실제로는 b.Invoke(15,5) 가 수행
              Console.WriteLine("b(10,5) = {0}",b(10,5)); // = 15
              b = new BinaryOp(SimpleMath.Subtract);
              Console.WriteLine("b(10,5) = {0}", b(10,5)); // = 5
          }
      }
	#+end_src
*** Delegate 실제예

	실무에서 사용하는 작업수순은 다음과 같다.

	#+begin_src csharp
      class Car {
          public Car() {
              speed = 0;
          }
          public int Speed {
              get {
                  return speed;
              }
              set {
                  Console.WriteLine("speed configured : {0}", value);
                  if (speed != value) {
                      OnSpeedChanged(speed, value);
                      speed = value;
                  }
              }
          }
          private int speed;
      
          // 1. Delegate 정의하기(SpeedChangeHandler 라는 클래스가 만들어진다)
          public delegate void SpeedChangeHandler(int beforeSpeed, int afterSpeed);
          // 2. Delegate 객체 정의하기(private 필드 + 접근메소드)
          private SpeedChangeHandler speedChangeHandler;
          public void RegisterSpeedChangeHandler(SpeedChangeHandler handler) {
              speedChangeHandler += handler;
          }
          public void UnregisterSpeedChangeHandler(SpeedChangeHandler handler) {
              speedChangeHandler -= handler;
          }
          // 3. 어떤 상황에서 호출되어 Delegate를 호출하는 함수 만들기.
          public virtual void OnSpeedChanged(int beforeSpeed, int afterSpeed) {
              if (speedChangeHandler != null) {
                  speedChangeHandler(beforeSpeed, afterSpeed);
              }
          }
      }
      
      class PracticalDelegateTest {
          // 4. 핸들러 만들기
          public static void LogSpeedChange(int beforeSpeed, int afterSpeed) {
              Console.WriteLine("speed change : {0} --> {1}", beforeSpeed, afterSpeed);
          }
          public static void Main() {
              Car tucson = new Car();
      
              tucson.Speed = 10;
              // 5. 핸들러 등록하기
              Car.SpeedChangeHandler handler = new Car.SpeedChangeHandler(LogSpeedChange);
              tucson.RegisterSpeedChangeHandler(handler);
      
              tucson.Speed = 20;
              tucson.Speed = 30;
      
              // 5.1 핸들러 등록 해제하기
              tucson.UnregisterSpeedChangeHandler(handler);
      
              tucson.Speed = 40;
          }
      }
	#+end_src

	위 코드에서 SpeedChangeHandler 를 그냥 public 필드로 놓고 써도
	되었겠지만, 필자는 필드는 무조건 private 로 하고 속성이나 접근자를
	만드는게 원칙이라는.. 쿨럭.

*** 메소드 그룹 변환(Method Group Conversion) 문법 : 가독성이 좋음
	대리자가 실은 클래스 타입이라는 점에서는 객체로 생성하여 전달하는
	것이 자연스럽지만, 읽고 쓰기에는 번잡하다.

	#+begin_src csharp
      // 객체로 대리자를 보는 경우
      car.RegisterSpeedChangeHandler(new Car.SpeedChangeHandler(logger.LogSpeedChange));
      // 함수 포인터로 대리자를 보는 경우(=메소드 그룹 변환 문법)
      car.RegisterSpeedChangeHandler(logger.LogSpeedChange);
	#+end_src

	위의 두 줄은 동일한 일을 한다. /new DelegateType()/ 부분이
	불필요하게 된다. 마치 C/C++ 에서 함수 포인터를 넘기는 느낌.
	이 구문은 C# /event/ 처리시 유용하게 사용된다. 
	
*** 제네릭 대리자(Generic Delegate)
	Delegate 를 <T> 를 써서 타입 중립적으로 만든다.

	#+begin_src csharp
      public delegate void MyGenericDelegateInt(int arg);
      public delegate void MyGenericDelegateString(string arg);
      // ...
      // 이런 종류의 정의들을 한방에 끝낸다. 
      public delegate void MyGenericDelegate<T>(T arg);
      
      // 사용시에는
      var intFunction = new MyGenericDelegate<int>(functionForInt);
      var stringFunction = new MyGenericDelegate<string>(functionForString);
      
      
	#+end_src
	
	
* 기타 메모
** string 키워드

   System.String 의 alias 에 불과하다. 유니코드 캐릭터 집합이고, @""
   문자열을 쓰면 이스케이프 특수문자를 그대로 입력받을 수 있단다.
   그리고, 중요한 사실은 *immutable(변경불가)* 타입이다.

** System.Object 와 System.ValueType, 그리고, System.Enum

   .net 에서는 모든 타입이 암묵적으로 이 두가지로 부터 파생된다(사실
   =System.ValueType= 은 =System.Object= 의 파생클래스이며
   =System.Enum= 의 부모클래스이다). 
   ValueType(/value type/)인 경우  =System.ValueType= 로 부터 암묵적 상속을
   받으며, RefType(/reference type/) 인 경우 =System.Object= 로 부터
   파생된다. *암묵적*이라는 말에 유념. 명시적으로 상속받도록 코딩할 수
   없다(/sealed/ 클래스임).

** Boxing 과 Unboxing

   모든 타입은 System.Object(즉 =object=)형에 담을 수 있는데, 이게 바로
   boxing. boxing 은 암시적이어서 명시적으로 =(System.Object)intValue=
   이런식으로 하지 않아도 된다.

   #+begin_src csharp
     // 실제로 존재하지 않는 개념적 클래스 sealed class Box<T>:
     System.ValueType<Type T>
     {
         T value;
         public Box(T t)
         {
             value = t;
         }
     }
     
     // 아래와 같이 하면.
     int i = 123;
     object box = i; // boxing!
     
     // 실제로는 다음과 같이 되는 개념이 boxing
     int i = 123;
     object box = new Box<int>(i); // boxing!
   #+end_src

   unboxing은 위의 반대. unboxing 은 object에 저장된 걸 다시 원래대로
   복구하는것. 값객체의 경우, boxing/unboxing시 값의 복제가 이루어지게
   되므로, 시간이 걸린다. c++에서
   std::vector<VeryLargeSizeOfStructure> 같은 것이 그런 예가 될 수
   있겠다. 아래는 [[http://msdn.microsoft.com/ko-kr/library/ms173196.aspx][MSDN에서 찾은 글]]이다.

   #+begin_example
    System.Collections.ArrayList 같은 제네릭이 아닌 컬렉션 클래스의
    예와 같이 많은 수의 boxing이 필요한 경우에는 값 형식을 사용하지
    않는 것이 좋습니다. System.Collections.Generic.List<T> 같은 제네릭
    컬렉션을 사용하면 값 형식의 boxing을 방지할 수 있습니다. boxing 및
    unboxing 과정에는 많은 처리 작업이 필요합니다. 값 형식을 boxing할
    때는 완전히 새로운 개체가 만들어져야 하며, 이러한 작업은 간단한
    참조 할당보다 최대 20배의 시간이 걸립니다. unboxing을 할 때는
    캐스팅 과정에 할당 작업보다 4배의 시간이 걸릴 수 있습니다. 자세한
    내용은 Boxing 및 Unboxing을 참조하십시오.
   #+end_example

** 빈 소멸자는 피하라.
   객체가 파괴될 때, 소멸자들이 Finalize큐에 들어가서 자식->부모 순서대로(상속을
   고려하여) 호출된다. 소멸자가 없으면 아예 호출이 일어나지 않으므로
   성능이 향상될 수 있단다. 

** partial class

   멋지다. patial class는 아래의 예를 보면 한번에 느낌이 온다. 어떤
   함수를 partial 로 선언하면, 구현을 포함하지 않을때는 아예 호출하는
   코드 자체가 없어진다고 한다. 그러다 구현을 포함한 추가 partial
   class를 따로 정의하면 그때 partial로 정의한 함수의 호출루틴이 다시
   살아난다.

   #+begin_src csharp
     partial class Customer
     {
         string name;
         public string Name
         {
             get
             {
                 return name;
             }
             set
             {
                 OnNameChanging(value);
                 name = value;
                 OnNameChanged();
             }
         }
         public override string ToString()
         {
             Console.WriteLine("tostring is called.");
             return string.Format("고객:이름={0}", name);
         }
         partial void OnNameChanging(string name);
         partial void OnNameChanged();
     }
     
     partial class Customer
     {
         partial void OnNameChanging(string name)
         {
             Console.WriteLine("OnNameChanging({0})", name);
         }
         partial void OnNameChanged()
         {
             Console.WriteLine("OnNameChanged()");
         }
     }
     
     class PartialClassTest
     {
         static void Main()
         {
             Console.WriteLine("Partial 클래스 테스트...");
             Customer customer = new Customer();
             customer.Name = "이준환";
             // Console.WriteLine("객체 정보 : {0}", customer);
         }
     }
     
   #+end_src

   위 코드의 실행결과는

   #+begin_example
     Partial 클래스 테스트...
     OnNameChanging(이준환)
     OnNameChanged()
   #+end_example

** 가비지콜렉션을 제어. IDisposable과 using 구문

   using 키워드는 원래 네임스페이스의 사용을 선언하는 키워드. 하지만
   구문내에서는 특정 객체를 생성하고 사용이 끝나면 파괴하는 일을
   깔끔하게 해주는 용도로 사용됨.

   #+begin_src csharp
     using (Font font1 = new Font("Arial", 10.0f))
     {
         byte charset = font1.GdiCharSet;
     }
   #+end_src

   위 구문은 아래의 구문으로 컴파일된다 함. 

   #+begin_src csharp
     {
         Font font1 = new Font("Arial", 10.0f);
         try
         {
             byte charset = font1.GdiCharSet;
         }
         finally
         {
             if (font1 != null)
                 ((IDisposable)font1).Dispose();
         }
     }
   #+end_src

   using에는 여러개의 객체할당 구문을 콤마로 해서 넣을 수 있다.

   #+begin_src csharp
     using (Font font3 = new Font("Arial", 10.0f), 
            font4 = new Font("Arial", 10.0f))
     {
         // Use font3 and font4.
     }
   #+end_src

   다만 다음과 같이 using 구문 바깥쪽에서 선언/정의된 객체의 사용은
   바람직하지 않다(using {} 구문을 벗어나면 할당해제되기
   때문이기도...

   #+begin_src csharp
     Font font2 = new Font("Arial", 10.0f);
     using (font2) // not recommended
     {
         // use font2
     }
     // font2 is still in scope
     // but the method call throws an exception
     float f = font2.GetHeight(); 
   #+end_src

** 숫자 리터럴의 suffix들
   [[http://www.dotnetperls.com/suffix][여기]] 에 정리가 잘됨.

   - m 또는 M : =decimal myMoney = 300.5m;=
   - f 또는 F : =float f1 = 100.50F;=
   - u 또는 U : =uint u1 = 1000u;=
   - ul 또는 UL : =ulong u2 = 1000200300400500ul;=
   - l 또는 L : =long x = 1000L;= 
	 
	 가급적이면 대문자를 쓰는게 덜 헛갈릴 수 있다(ex: l vs L ==> l 은
     숫자 1과 비슷해 보인다).

** C# 에서 {void|int} Main([string[] args])

   C# 에서는

    - public static void Main();
	- public static void Main(string[] args);
	- public static int Main();
	- public static int Main(string[] args);

   의 Entry Point 사용이 가능하다. C/C++ 과 다른 점은,

   - Shell Pattern 확장이 자동이 아님.
   - 프로그래명이 =args[0]= 가 아님. =arg[0]= 은 첫번째 argument 임.
   - int argc 는 필요없음. args.Length 하면 얻을 수 있음.

** @ 스트링 리터럴 : 이스케이프 문자가 없는 문자열.
   ="c:\\my\\temp\\dir"= 보다는 =@"c:\my\temp\dir"= 이 읽기 편하다.
   @스트링 리터럴이 가지는 유일한 특수처리 문자는 따옴표 그
   자체다(이를 포함하려면 연속으로 따옴표 2개를 입력)
** Directory/File/Environment 클래스의 클래스 정적 메소드들
   - File.Exists(filePath) / Directory.Exists(dirName)
   - File.Delete(filePath)
   - Directory.CreateDirectory(dirPath)
   - Environment.GetLogicalDrives()
   - Environment.CurrentDirectory()
   - Environment.CommandLine()

** C# String Format

   - Excel에서 보았던 형식이 가능하다.
	 
	 String.Format("{0:0000.00}", 142.1340); --> 0142.13

   - C에서 온 numeric
	 
	 String.Format("{0:f2}", 142.1340); --> 142.13

** string s = new string("hello") 같은 구문은 C# 에서 안된다?!
   생성자에는 있는데????
