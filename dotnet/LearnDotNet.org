#+TITLE:LearnDotNet

* .NetBookZero

** 1장 ~ 11장
*** static readonly/const 그리고, c++에서의 local static 변수

   	정적 상수 멤버(static readonly)는 런타임에,
   	그냥 상수 변수(const)는 컴파일시에 설정된다.

   	#+begin_src csharp
      class MyClass
      {
          // strDelimter는 런타임에 세팅된다.
          static readonly strDelimiter = ",";
          // strDelimter2 는 컴파일 타임에 세팅된다.
          const strDelimiter2 = ",";
      }
   	#+end_src

   	위 두 가지는 실제로는 큰차이가 없다. 하지만 c++에서

   	#+begin_src c++
      class MyClass
      {
      public:
          void MyFunc()
          {
              static int callCounter = 0;
              ++callCounter;
          }
      };
   	#+end_src

   	하던 식으로 사용하던 *로컬정적변수는 C# 에서는 사용 불가*.

*** void Do(ref int i) 와 void Do(out int i) 의 차이점

   - out 을 쓰면 인자를 넘겨줄때도 Do(out myValue) 이런식으로 해야
     한다.
   - ref로 넘겨줄 때는 *반드시 초기화가 되어 있어야 한다*.
   - out으로 넘겨줄 때는 *초기화 되어 있지 않아도 된다*.
	 
*** void Do(ref {값타입} var) 와 void Do({참조타입} var) 

   - 값타입은 ref 로 명시해야만 pass-by-ref.
   - 참조타입은 원래 pass-by-ref. 단, 원래의 참조값 자체에 대한 참조를
     위해서는 ref 를 해야 함. 아래 예 참조
	 
	 #+begin_src csharp
       class MyClass
       {
           public static void AllocArray(int [] myArray)
           {
               myArray = new int [] { 1000, 2000, 3000 };
           }
           public static void AllocArrayRef(ref int [] myArray)
           {
               myArray = new int [] { 1000, 2000, 3000 };
           }
       }
	 #+end_src
	 
	 위 경우, AllocArray()로 넘겨진 myArray의 원래 참조는 바뀌지
     않는다. AllocArrayRef()의 경우에는 호출측의 myArray가 바뀐다.
     *C++에서의 Double Pointer개념*.

*** Unified type system : 모든 것은 object 의 파생 클래스다.

   	int 나 double 같은 primitive type 까지 포함해서....

*** .net 에서 라이브러리에 해당하는 "어셈블리"가  *.dll.

   	csc /target:library acme.cs    이런식으로 생성한다.
   	한편 /target:module 하면 생기는 건 모듈. 이건 나중에 어셈블리에
   	합칠 수 있다. 어셈블리=동적라이브러리, 모듈=정적라이브러리 라고
   	정리해 두자.

*** C# 에서는 "클래스 정적 const 배열을 만들 수가 없다."

   	static readonly int [] myArray = { 0 , 1, 2 ,3 };

   	이렇게 선언했다고 하더라도, 결국

   	#myArray[0] = 19# 이런식으로 변경하는게 가능하기 때문이다.

   	이걸 막으려면, 외부에서 접근하는 방식을 막아야 한다. 

*** 로컬에서 생성한 상수배열의 성능
   	상수배열은 new {Type} 하지 않고, 특정 함수내에 그냥 정의하는 것.

   	int [] myNumbers = { 0, 1, 2, 3, 4};

   	정적으로 선언/정의한 상수배열은 아래와 같이..

   	static [readonly] int [] myNumbers = { 0, 1, 2, 3, 4 }

   	정적 버젼이 단 1번만 초기화 되므로(아마 런타임시에), 훨씬 빠르지만,
   	상수배열을 로컬에 선언한다고 해서 그게 그리 큰 문제가 되지 는
   	않는다(최적화가 어느정도 이루어 진다?!)

** 12장. 예외처리
*** 어떤 예외를 catch 할 건가.
   이를 테면, Console.ReadLine() 은 IOException,
   ArgumentOutOfRangeException, OutOfMemoryException 의 3가지 예외를
   뿜을 수 있는데,.... 극도로 부정적인 사람은 모든 ReadLine 호출시
   마다, try/catch 로 감싸고, 이 세가지 예외처리를 넣을 수 도 있겠다.
   하지만, 이 경우, 다른 2가지 예외와는 달리 OutOfMemoryException
   정도는 언제든지 발생할 수 있다는 생각 정도는 하고 코딩을 하는게
   유용할 거다.

*** Double.TryParse 와 Double.Parse
   전자는 리턴값으로 오류발생을, 후자는 예외를 throw 하여 오류처리를
   해야 한다. 이런식으로 .net 에는 동일한 동작을 예외throw 유무가 있는
   버젼도 있다.

** 13장. Class ,Struct, 그리고 Object

   - struct는 value type, class 는 reference type. *struct는 자신으로
     부터 다른 타입을 파생시킬 수 없다*.

   - struct MyData {...} 는 ~MyData myData;~ 하면, 모든 멤버가
     uninit'ed 상태로 stack에 생성. 접근하는 코드가 보이면 컴파일
     오류. ~MyData myData = new MyData();~ 하면 *마찬가지로 stack에
     생성(new했어도)*. 하지만 이 경우, 모든 멤버가 zero로 초기화.

   - class MyData {...} 는 ~MyData myData;~ 하면, stack에 초기화 되지
     않은 reference 가 생김. 모든 멤버에 대한 접근 코드는 컴파일 오류.
     반드시 ~myData = new MyData();~ 한 다음 접근해야 컴파일 오류안남.
     new 하는 순간 모든 멤버가 0 으로 초기화된 상태로 heap에 생성. 한편
     ~MyData myData = null~ 로 null 초기화 하면, 컴파일 오류는 발생하지
     않으나(경고만 뜸), 프로그램 실행시 멤버 접근 코드는 exception을
     발생시킴.

   - 함수인자로 넘길때, struct건 class건 'ref' 를 인자type 앞에
     명시하지 않으면 무조건 pass-by-value. 하지만, reference type은
     reference value(즉, 주소값)이 value이므로 마치 reference가
     넘어가는 것 같은 느낌을 받게 될 뿐이다. reference가 가리키는
     주소의 내용은 바꿀 수 있지만, reference값 자체는 바꿀 수 없다.
     그럴려면, 'ref'를 명시해야 한다.

   - ~struct MyData {...}~ 인 경우, ~MyData [] myDataArray = new
     MyData[27]~ 은 27개의 sizeof(MyData) 영역이 Heap 에 할당되고,
     stack에는 그 heap영역을 가리키는 sizeof(pointer)크기 만큼이
     할당된다. 그리고, 그 heap 영역의 모든 값이 zero out된다(멤버의
     값이 0 이 된다).

   - ~class MyData {...}~ 인 경우, 위와 동일하게 배열을 할당하면,
     stack에는 동일한 sizeof(pointer) 크기 만큼이 할당되지만, heap에는
     27개의 sizeof(pointer) 공간이 할당되며, 각각의 pointer값은 null 
	 이 된다. 이를 제대로 할당하기 위해서는 27개의 모든 요소에 대해서
     ~myDataArray[i] = new MyData()~ 이런 식으로 new 해 주어야 하고,

** 14장. 인스턴스 메쏘드
** 15장. 생성자

   1. 생성자에는 2가지 종류가 있다. *Instance Constructor(인스턴스
      생성자)* 와 *Class Constructor(클래스 생성자)*. 아무말 없이
      사용하면 인스턴스 생성자라고 알아두면 될 듯. 아래 5~6 항목 참조

   2. struct의 소멸자는 /parameterless/ 할 수가 없다(/value type/
      자체가 배열등으로 만들어질 때 초기화시 속도를 빨리하게끔 하기
      위해 만든 제약사항이란다. 잘 이해는 안가지만). 17장에 나온
      힌트인데, *모든 값을 zero로 만드는 struct의 parameterless
      생성자로 인 zero가 아닌 값으로 초기화하는 방법은 속성을 개조하여
      원래값에 오프셋을 주도록 하는 방법이 있겠다*

   4. class 의 생성자는 /parameterless/ 할 수 있다.

   5. 생성자를 명시적으로 만들지 않으면, struct의 경우 모든 인자를
      /zero out/ 하는 생성자를 컴파일러가 만들어준다.

   6. class 의 /non parameterless/ 생성자를 1개라도 만들면, 컴파일러
      자동으로 생성해 주던 기본 /parameterless/ 생성자는 만들어지지
      않더라. (언어사양 $10.4.4 "If a class contains no instance
      constructor declarations, a default instance constructor is
      automatically provided." --> 이 말의 의미는 인스턴스 생성자가
      1개라도 있으면, 디폴트로 만들어지던 생성자는 자동으로 제공되지
      않는다가 된다.)

   7. struct 의 경우, class 와는 달리 /non-parametereless/ 생성자를
      만들었는지 여부와 상관없이 컴파일러가 항상 디폴트 parameterless
      생성자를 제공해 준다. 오히려 사용자가 정의한 /parameterless/
      생성자를 만들 수가 아예 없다.

   8. 인스턴스 생성자에서 인스턴스 메쏘드를 호출하는 경우에는 극도로
      주의를 해야 한다. 특정 필드의 값이 아직 정상적으로 설정되지
      않았을 수 있기 때문이다. 이런 이유때문에 인스턴스 생성자에서는
      가급적 클래스 메쏘드(정적 메쏘드)를 사용하도록 유도(?)하는 것
      같다. 이렇게 해서 *여러 생성자가 동일한 루틴을 공유하도록 하는
      것이 가능하다*

   9. 위 7번에서 정적 메쏘드를 사용하는 방법 말고 루틴공유 방법으로
      /Constructor Initializer/ 가 있다.

	  #+begin_src csharp
        public class Date
        {
            public Date(int year, int month, int day)
            {
                this.year = year;
                this.month = month;
                this.day = day;
            }
            public Date(int year)
                : this (year, 1, 1) // constructor initializer
            {
            }
        }
	  #+end_src

** 16장. 등가 개념(Concept of Equality)

   - struct 는 디폴트로 값비교를 bitwise equality을 하지만, 참조타입인
     class 는 레퍼런스가 같은지 비교한단다. (C에서 포인터 등가 비교를 생각).

   - =public virtual bool Equals(object obj)= 이런식으로 등가비교
     연산자를 재정의 할 수 있다. 하지만, 이 경우 GetHashCode() 를
     구현해야 한다.

   - operator=() 연산자는 public static 으로 클래스 메쏘드가 되어야 한단다.

   - 등가비교는 항상 조심해야 할 것 같은 느낌이다.

** 17장. 필드와 프로퍼티
*** 접근가능자가 5개 = public + private + (protected + internal + internal protected)

   - 멤버변수를 정의할 때, public 을 타입 앞에 붙이지 않으면 디폴트가
     private 이다.

*** readonly : 이건 오직 field에만 쓸 수 있다.

   - 어떤 멤버변수의 값을 외부에서 기록하지 못하게 하기 위해 c++
     에서는 해당 멤버를 protected/private으로 놓고, getter()를
     사용하였지만, C# 에서는 단순히 =public readonly int year;= 
	 이런 식으로 하면 된다.

   - struct가 아닌 class의 경우, readonly 변수의 초기값을 
	 =public readonly int year = 1=; 이런식으로 할 수 있다. 또는
     생성자를 통해서 단 1번만 설정하게 할 수 있다. 이렇게 하면
     immutable 객체가 된다.

*** const : C++ 과는 달리 필드에만 쓸 수 있다(?)

	어떤 멤버를 const 로 선언하면 동시에 초기값을 설정하여야 하며,
	본질적으로 모든 const 멤버는 클래스 범위에서 접근해야
	한다(Math.PI)

*** 프로퍼티를 정의할 때 사용하는 set/get 은 키워드가 아니다.

	단지 프로퍼티 정의시에만 독특한 의미로 사용된다. 다른 곳에서
	변수명으로 써도 된다.

*** 프로퍼티 이름이 MyProp이면 Set_MyProp/Get_MyProp 은 사용불가

   컴파일러가 내부적으로 생성한 getter/setter 함수명과 충돌하기 때문에
   사용할 수가 없다.

*** 프로퍼티 = private 변수선언 + get/set함수의 특별한 정의   

   *private으로 선언한 변수의 이름이 프로퍼티 이름과 동일하면 안된다*.

   #+begin_src csharp
     class Person
     {
         string name;
         public string Name {
             get {
                 return name;
             }
             set {
                 name = value;
             }
         }
     }
   #+end_src
  
*** 프로퍼티는 반드시 값을 그대로 리턴할 필요가 없다.
	set과 get간의 관계만 명확하면 된다. ex: get()할때 -1 해서
	반환한다면, set할 때 +1 해서 저장해 두면 된다.. 이런식.

*** 프로퍼티를 배열처럼 선언할 수 있다.

	#+begin_src csharp
      class DateClass {
          static string[] strMonths = new string[] {
              "January", "Feburary", "March", "April"
          };
          public static string[] MonthName {
              get {
                  return strMonths;
              }
          }
      }
      
      class ArrayProp {
          static void Main() {
              Console.WriteLine("DateClass.Month[2] = {0}", DateClass.MonthName[2]);
              foreach (string monthName in DateClass.MonthName) {
                  Console.WriteLine("{0}", monthName);
              }
          }
      }
	#+end_src

	위 결과는

	#+begin_example
          DateClass.Month[2] = March
          January
          Feburary
          March
          April
	#+end_example

*** Indexer!!!

	- =public int this[int i];= 이런 멤버함수는 객체의 속성을 배열인덱스
	  처럼 접근할 수 있다.
	- =public int this[string str];= 이렇게 하면, dictionary 처럼
      접근이 가능하다.
	- 모든 indexer 는 속성과 마찬가지로 get/set 두 구간으로 나눌 수
      있다.
	- MSDN 문서에는 indexer 에 대해 이름 붙일때 "Items" 를 일반적으로
      쓰지만, String 클래스의 Indexer와 같이 "Chars" 라는 이름을
      사용하기도 한다. 실제로 C#은 내부적으로 "set_Item" 과 "get_Item"
      이라는 이름으로 된 접근함수를 만들어낸다(이 2개의 이름으로 된
      멤버는 만들 수 없다).
	
** 18장. 상속

   - 우선 C# 에는 protected/private 상속이 없다. 
	 =public Foo : private Bar { }= 이런식으로 할 수가 없다.

   - 파생클래스는 부모클래스의 생성자를 그대로 쓸 수 없다(C++과
     동일).인자 있는 생성자를 상속클래스에 따로 정의를 다시 해야
     한다(또 그렇게 하면 기본 /parameterless contstructor/ 는
     만들어지지 않는다.

   - 파생클래스에서 부모클래스의 생성자를 호출하려면 *base* 키워드를
     사용한다(15장에서 언급한 /constructor initializer/ 의 한 종류가
     된다. 그때는 this 를 썼지만 여기서는 base를 썼을 뿐). 생성자
     호출순서는 C++과 같이 부모클래스->자식클래스 이다.
	 
	 #+begin_src csharp
       class ExtendedDate: Date
       {
           public ExtendedDate()
           {
           }
           public ExtendedDate(int year, int month, int day)
               : base(year, month, day)
           {
           }
       }
	 #+end_src

   - 멤버 변수/메소드 에 대한 public/protected/private 은 C++과 비슷해
     보인다.

** 19장. 가상화(Virtuality)
*** up/down cast문제와 C++의 dynamic_cast같은 'as' 연산자

   C++에서의 down casting 및 up casting 개념이 C# 에도 있다. up
   casting은 문제 없다.

   #+begin_src csharp
   ExtendedDate exDate = new ExtendedDate();
   object obj = exDate;
   #+end_src

   근데, down casting은 역시나 문제가 있다. 명시적 형변환이 필요.
   c++에서의 dynamic_cast<> 같은 개념이 필요할 수 있다(즉, 실제로 그
   객체가 그 형인지 알려면...

   #+begin_src csharp
     // 안전하지 않은 방식(obj 가 실제로 ExtendedDate 가 아니면
     // InvalidCastException이 발생한다)
     ExtendedDate exDate = (ExtendedDate)obj;
     // 안전(?)한 방식
     ExtendedDate exDate = obj as ExtendedDate;
     if (exDate)
     {
         // obj 가 ExtendedDate 였다.
     }
     else
     {
         // obj 가 ExtendedDate 가 아니였다.
     }
   #+end_src

*** Object의 GetType() 또는 typeof() 연산자로 얻은 Type 객체.

   어떤 객체의 타입에 대한 정말 많은 정보를 얻을 수 있다. 이를 테면.

   #+begin_src csharp
     object obj = new Date;
     Type objType = obj.GetType(); // 또는 typeof(Date)
     Console.WriteLine("obj type name : {0}", objType);
     foreach (MemberInfo mi in objType.GetMembers())
     {
         Console.WriteLine("member : {0}", mi);
     }
   #+end_src

   그리고, Type 객체는 형이 정의되면 생기는 형 별로 딱 1개 생기는
   전역객체를 가리키는 레퍼런스(포인터)이다. 따라서, 등가비교를 하는
   것이 가능하다.

   #+begin_src csharp
   obj.GetType() == typeof(ExtendedDate)
   #+end_src

*** 'is' 연산자

	인스턴스 메소드인 GetType() 이나 C# 연산자인 typeof() 를 사용하지
	않고 어떤 객체가 특정형인지 알 수 있게 해주는 것이 'is' 연산자.
	GetType() 은 인스턴스 메소드 이므로 객체가 null인 경우 예외가
	발생하지만, is 연산자는 그런일이 없다. 그냥 false 로 평가된다. 

	#+begin_src csharp
      if (obj is Date)
      {
          Console.WriteLine("object is Date type!");
      }
	#+end_src

*** 오버라이드 가능한 멤버 = virtual 메소드 , virtual 속성

	부모 클래스에서

	public virtual string ToString();

	하고, 자식 클래스에서

	public override string ToString();

	하는 식.

*** 부모클래스의 메소드를 명시적으로 hiding하는 'new' 키워드(생성할때의 new와 다른것)

	부모가

	public void NonVirtualMethod();

	했는데, 자식이

	public void NonVirtualMethod();

	하면 컴파일러가 경고를 띄운다. 무심코 부모클래스의 기능 하나가
	hiding되기 때문이다. 이런 경우 의도한 바라면,
	자식 클래스에서

	public new void NonVirtualMethod();

	하면 경고가 사라지며, 명시적으로 부모 클래스의 메소드를 막는다.

	NonVirtualMethod() 는 부모클래스형으로 호출하는 경우와
	자식클래스형으로 호출하는 경우가 구분된다. (virtual 함수는 그렇지
	않다. 항상 실제 형의 루틴이 호출된다. C++과 동일하다. --> "다형성")

*** abstract class , abstract method

	abstract class Musician {}

	으로 정의한 클래스의 객체는 못만듬.

	public abstract  decimal CalculatePay();

	함수는 반드시 override 되어야 하는 메소드.

*** struct 형 객체를 object 형으로 형변환 : boxing / unboxing

	- *struct 는 스택에 생성되는 값 객체이므로, 서로 다른 형 끼리는
      대입하지 못한다*.

	- *struct 형* 을 선언하면 스택에 해당형의 크기만큼이 할당된다. 근데,
      struct 역시 object로 부터 파생된 형이므로, *object에 대입이
      가능* 하다.

	- object형으로 대입될 때 힙에 struct형을 담을 수 있는 공간이
      확보되어 거기에 해당 struct의 모든 멤버의 값이 복사된다. 이를
      *Boxing* 이라고 한다. --> 퍼포먼스에 영향을 줄 수 있음.

	- object가 가리키는 struct의 내용을 역참조할때는 *Unboxing* 을
      하게 된다. 이 경우도 복사가 일어난다. --> 퍼포먼스!!!

	- 가급적 boxing/unboxing이 일어나지 않도록 구체적인 struct형을
      주고 받는 식으로 메소드들을 오버라이딩 하는 게 바람직.(ex: WriteLine)
	
** 20장. 연산자 재정의(Operator Overloading)

   먼저 말해 두지만, struct는 값을 위한 타입이고 파생클래스를 만들 수
   없다. 자신이 가지는 연산자도 당연, 파생될 수가 없고, 이것은 말이
   된다. 사실 class의 오퍼레이터도 자신의 파생클래스에는 문제가 될
   소지가 있다(파생클래스에서 Add 같은 연산자가 리턴하는 값의 타입은
   파생클래스가 될까? Add연산자를 매번 새로 정의하지 않으면
   부모클래스의 객체가 반환될 거다!!!)

   숫자들로 구성된 데이터를 다루고, 그것에 대한 연산자를 오버로딩하는
   것은 struct 형을 통해서 하는 것이 바람직하다.(바로 위에 문장에
   의하면,  struct가 파생될 수 없는 점이 이 경우에는 강점이 된다).

*** 계산을 위한 연산자 재정의
   
   - 연산자 재정의는 무조건 static 으로 해야 한다. 또한 빼기 연산자를
객체에 대해 수행하지 못하는 프로그래밍 언어를 위해 명시적인 Add,
Subtract, Multiply, Divide 같은 이름을 사용한 함수를 만들어야 할 필요도
있게 된다. 결국 아래와 같은 식으로 구현.

   #+begin_src csharp
     public static int operator - (Date lhs, Date rhs)
     {
         return Subtract(lhs, rhs);
     }
     public static int Subtract(Date lhs, Date rhs)
     {
         int daysDifference = lhs.value - rhs.value;
         return daysDifference;
     }
     public static Date operator + (Date lhs, int days)
     {
         return Add (lhs, rhs);
     }
     public static Date Add (Date lhs, int days)
     {
         Date v = new Date;
         v.value = lhs.value + days;
         return v;
     }
   #+end_src

   - 연산자 재정의 시 2개 인자의 순서도 중요하다(연산잔 교환법칙이
     성립되지 않는 경우를 고려).

*** 등가 연산자 재정의

   - 등가 연산자(Equals 또는 operator ==) 의 구현시, Object 루트
     클래스는 Object형 2개를 인자로 받는 static 메소드이므로, struct와
     같이 ValueType 형의 객체는 boxing/unboxing이 발생한다. 명시적인
     형을 받는 Equals 를 구현해 놓는게 좋다.

   - 등가연산자 구현시 Equals 및 GetHashCode 메소드를 override해야
     한다. GetHasCode는 32비트 정수형을 반환하는데, 값에 따라 2의 32승
     가짓수를 넘어서는 값의 종류가 있다면 유일성은 포기해야 한다.

   - 타입변환 연산자도 재정의가 된다. 다만, 사이드 이펙트로 변환되는
     것을 막기 위해 explicit 키워드를 사용해 주는게 좋다. 
	 
	 public static explicit operator int (SuperDate sd);
	 
	 위의 역 변환도 가능하게 할 수 있다. 
	 
	 public static explicit operator SuperDate(int value);
	 
*** partial 키워드	 

	partial class SuperDate : ExtendedDate {}

	처럼 하면, SuperDate 의 구현을 2개 이상의 파일에서 할 수 있단다.

	partial은 

**** 책에 나온 Date class 보다는 CommonEraDay 정수값 1개를 가지는 Date struct

	펫졸드 아저씨는 설명을 위해서 Date를 class로 만들었지만, 실제로
	본인도 이것 보다는 값 형식인 struct를 사용하고 내부의 값은
	심플하게 정수형 1개로 표현할 수 있는 Date struct가 훨씬 낫단다.

** 21장. 인터페이스(Interfaces)

   - interface 는 메소드의 구현이 전혀 없다(C++ 순수가상클래스와
     비슷).
   - class 는 다른 class 1개로 부터만 상속받을 수 있으나, interface를
     상속받는 경우는 여러개 상속이 가능하다.
   
	 ex : class SuperDate : ExtendedDate, IComparable

   - IComparable 을 사용하되 partial 키워드를 사용해 원본 클래스
     소스코드를 전혀 손대지 않고, 구현이 가능했다.

   #+begin_src csharp
     partial class Person : IComparable
     {
         public int CompareTo(Object obj)
         {
             // 여기에 구현을 넣는다.
         }
     }
   #+end_src

   *interface 에 선언된 메소드를 정의할 때는 override 키워드를 쓰면
   안된다.* C++을 생각하면 당연히 virtual일거라 생각했는데, 아니네..

   *Array.Sort()* 클래스 정적 메소드는 keyList와 valueList 두개를 모두
    받는 버젼이 있더라. (key가 정렬되는 순서대로 valueList도 함께
    정렬되더라. 굳이 자료구조를 구성해서 정렬할 필요가 없어 조으네).

** 22장. 상호운용성(Interoperability)

   P/Invoke 를 통해 Win32 DLL을 호출하는 방법에 대해 설명.

** 23장. Date와 Time

   일단 스킵

** 24장 Event와 Delegate

   - A 에 무슨일 이 생길때 그 사실을 B에 알려주는 방법 : Polling &
     Event 의 2가지방법. Event가 더 좋다는 얘기...
   - =public delegate void EventHandler(Object sender, EventArgs e);=
     이런식으로 EventHandler 라는 이름의 delegate를 정의했다...함은
     void(Object,EventArags) 시그너쳐를 가지는 함수포인터같은 개념을
     정의했다는 의미

   - =public event EventHandler InformationAlert;= 라고 하면,
     EventHandler 라는 시그너쳐를 가지는 InformationAlert 라는
     메소드의 정의를 말함.

   - Event처리기의 등록
	 
	 #+begin_src csharp
       // B 쪽 생성자 등에서 핸들러와 이벤트를 연계할때 2가지 방법이 모두 가능
       a.InformationAlert += new EventHandler(MyInformationAlertHandler);
       // 또는
       a.InformationAlert += MyInformationAlertHandler; // .NET 2.0 이상에서 가능구문
       
       // B 클래스의 메소드
       void MyInformationAlertHandler(object sender, EventArgs e)
       {
           // 여기서 실제 이벤트 처리루틴
       }
       
       // A 클래스에서는
       {
           // 이벤트를 날려야 되는 순간이 되었다!! (fire or raise Event!)
       
           if (InformationAlert != null)
           {
               // 이벤트 헨들러가 등록된게 있다. 통지 하자.
               InformationAlert(this, new EventArgs(...));
           }
       }
	 #+end_src
	 
	 등록 시의 구문이 += 연산자를 써서 여러개의 핸들러를 등록시킬 수
     있기 때문에, InformationAlert.Lenght 같은 식으로 확인해야 할 것
     같은데, null 로 확인하는 점이 헛갈린다.
	 
	 등록 해제 하려면 -= 연산자를 써서 할 수 있다.
	 
	 #+begin_src csharp
	 a.InformationAlert -= new EventHandler(MyInformationAlertHandler);
	 #+end_src
	 
	 .NET 2.0의 깔끔한 핸들러 등록 구문을 써서 예제 하나. 이벤트
     핸들러 메소드를 마치 변수 다루듯이 한 점을 유심히!
	 
	 아래 코드는 
	 
	 1. 객체의 멤버함수를 핸들러로 등록("객체.메소드" 구문
	 2. 익명 메소드를 핸들러로 등록("delegate" 구문) - Full/Short version!
	 3. 정적 메소드를 핸들러로 등록("public static 함수")
	 
	 의 3가지 종류에 대한 핸들러 등록을 하고 있다. 등록 순서대로
     이벤트 발생시 호출이 일어난다. 
	 
	 *익명메소드를 사용하기는 우아하지만, 로컬변수와 관련하여서는 좀
     tricky 할 수 있다.*

	 #+begin_src csharp
       using System;
       using System.Timers;
       class TimerHandlingClass {
           public void OnElapsed(Object sender, ElapsedEventArgs e) {
               Console.WriteLine("object handled event(data={0}) handled event!", data);
           }
           public int data;
       }
       class TimerEventTest {
           static void Main() {
               TimerHandlingClass thc = new TimerHandlingClass();
               thc.data = 18; // 객체가 그 객체가 맞는지 확인.
               Timer timer = new Timer();
               timer.Interval = 500;
       
               // 객체의 멤버함수
               timer.Elapsed += thc.OnElapsed;
               // 익명 메소드(anonymous method) - full version
               timer.Elapsed += delegate (Object sender, ElapsedEventArgs e) {
                   Console.WriteLine("Lambda delegator handled event!!!");
               };
               // 익명 메소드 - short version
               timer.Elapsed += delegate {
                   Console.WriteLine("Simple Lambda delegator handled event!!!");
               };
               // 정적함수
               timer.Elapsed += TesterHandler;
       
               timer.Start();
               Console.ReadLine();
           }
           public static void TesterHandler(Object sender, ElapsedEventArgs e) {
               Console.WriteLine("TesterHandler handled event!!!");
           }
       }
	 #+end_src

** 25장. 파일과 스트림

   - System.IO 네임스페이스관련 내용. XML파일 IO는 System.XML 을 쓰라.
***  Stream(추상클래스)

BufferedStream, FileStream, MemoryStream, NetworkStream 의 4가지
종류파생클래스가 있다. Stream자체는 다음의 메소드를 가짐

   - CanRead, ReadByte(1바이트읽음), Read(여러바이트읽음)
   - CanWrite, WriteByte(1바이트기록), Write(여러바이트쓰기)
   - CanSeek, Length, Position, Seek(SeekOrigin enum을 사용:Begin/Current/End)
   - CanTimeout, ReadTimeout, WriteTimeout

비동기 동작을 위한 메소드도 존재	 

   - BeginRead
   - EndRead
   - BeginWrite
   - EndWrite

*** FileStream

대다수의 파일 관련 동작은 이걸 쓰면 된다. 하지만, C/C++ 처럼 바이너리
버퍼를 특정 struct 형으로 바꿀 수 있는 언어들과는 달리, C# 은 그런일을
할 수 없으므로, 순수(!)하게 바이너리를 읽는 작업 이외에 이 클래스를
사용하게 되는 일은 드물다(*Text File I/O* 혹은 *Binary File I/O* 를
쎄게 된다)

  - 생성자 : 시그너쳐의 종류가 많음. 일반적으로 2개의 인자(FileName과
    FileMode)와 2개의 선택인자(FileAccess=디폴트는
    FileAccess.ReadWrite, FileShare=디폴트는 FileShare.None 이라지만,
    MSDN을 보면 어떤 생성자는 FileShare.Read가 디폴트인 경우도 있음)

  - 생성자를 사용해 초기화하기 때문에 동작실패시 예외가 던져지는
    식으로 처리 --> *항상 try/catch 블럭에 감싸서 호출할 것!*

  - FileMode가 FileMode.Append 인데, 선택인자에 Read가 들어가면
    FileStream의 생성은 무조건 실패. 다음과 같이 함.
	
	=new FileStream(fileName, FileMode.Append, FileAccess.Write)=
	
  - ReadByte는 1 바이트를 읽기는 하지만 int 형으로 형변환된 값을
    반환한다. 0xFF 를 읽으면 0x000000FF 즉 255 가 반환된다. 읽기
    실패(파일의 끝을 지나치는 경우)에는 -1 이 반환된다.	

*** Text File I/O = TextReader(/abstract/) + TextWriter(/abstract/)

	- TextReader = *StreamReader* + StringReader
	- TextWriter = *StreamWriter* + StringWriter
   
   StreamReader/Writer 는 Encoding을 인자로 받기 때문에 Encoding 에
   관한 얘기가 주욱 나온다.

   - UTF8 이 중요할 것 같은데, BOM을 쓰지 않는 경우라면,
     Encoding.Default 를 쓰라는 얘기가 있다.(또는 UTFEncoding(true))
   - 윈도우즈 안시 캐릭터 셋을 쓰려면
     *Encoding.GetEncoding({코드페이지})* 를 쓰란다.
   - MSDN 을 찾아보니 *Encoding.GetEncoding()* 클래스 매소드는 문자열을
     받는 버젼도 있다. 아래와 같은 방식으로 사용
	 
	 #+begin_src csharp
       public class SamplesEncoding
       {
           public static void Main()
           {
               // Get a UTF-32 encoding by codepage.
               Encoding e1 = Encoding.GetEncoding( 65005 );
       
               // Get a UTF-32 encoding by name.
               Encoding e2 = Encoding.GetEncoding( "utf-32" );
       
               // Check their equality.
               Console.WriteLine( "e1 equals e2? {0}", e1.Equals( e2 ) );
           }
       }
       // "e1 euqlas e2? True" 라고 찍힌다.
	 #+end_src
	 
	 또 *Encoding.GetEncodings()* 클래스 매소드는 사용가능한 모든
     EncodingInfo 객체들의 목록을 반환한다.

*** StreamWriter

   - BaseStream 속성 : 자신의 기반이 되는(또는 생성시 사용된) Stream
   - Encoding 속성 : 설정된 인코딩
   - AutoFlush 속성 : 버퍼링사용 여부
   - NewLine 속성 : =\r\n= ?
	 
   - Write 메소드
   - WriteLine 메소드
   - Flush 메소드
   - Close 메소드

   - StreamWriter() 생성자중 *bool detect* 인자를 true 로 하면, 처음
     몇바이트를 가지고 인코딩을 디텍팅해낸다!!!! 거기다가 Encoding을
     명시적으로 알려주면, 혹 디텍팅을 못한 경우에 지정된 Encoding을
     알려준다.

*** StreamReader

	- BaseStream 속성
	- CurrentEncoding 속성 : *읽기를 시작하면서 바뀔 수 있다*
	- Peek 메소드 : 읽기위치를 옮기지 않고 1바이트 얻음. --> -1 에러
	- Read 메소드 : 읽기위치가 옮겨지고    1바이트 얻음. --> -1 에러
	- *ReadLine* 메소드 : 파일끝에 가면 null 객체 반환.
	- *ReadToEnd* 메소드 : 전체 파일 읽기.
   
*** Binary File I/O = BinaryReader + BinaryWriter

	- 모두 Object 에서 바로 상속(cf. StreamReader/Writer는 Object >
      MarshalByRefObject > StreamReader/Writer).
	- 생성자에서 Stream 을 받고, 나중에 BaseStream 속성으로 다시 얻을
      수 있음.

*** BinaryWriter

	- Write 메소드 : bool, byte, byte[], char, char[], string, short,
      int, float, ... 18개 형에 대한 오버로딩이 존재!!! --> 타입에
      대한 정보는 기록하지 않고, 단순히 데이터값만 기록한다.
	  배열의 경우, *배열의 길이정보 역시 기록하지 않는다*.
	  문자열의 경우, *7비트 인코딩된 정수값으로 길이가 기록된다?*

	- Seek 메소드
	- Flush 메소드
	- Close 메소드 : underlying Stream을 Close 한다.
   
*** BinaryReader

	- ReadBoolean, ReadByte, ReadBytes, ReadSByte, ... 이런식으로 값을
      반환하는 읽기 메소드가 존재한다.-> EOF 에 다다르면, EndOfStream
      예외가 발생한다(반환값 자체가 데이터이므로 반환값으로 호출
      성공여부를 알 수 없겠다) --> Reader의 경우 오퍼레이션을
      try/catch 로 감싸야 한다.
	- PeekChar 메소드 : 다음에 오는 1 바이트를 읽고 위치 변경 X
	- Read 메소드     : 다음에 오는 1 바이트를 읽고 위치 변경 O

* Apress Pro C#
** Chap3. Core C# 1편
*** checked 키워드

	checked 키워드를 =check(연산식)= 혹은 =checked { 구문들; }=
	이런식으로 사용하여 오버플로우 등 연산오류 발생시 예외가 던져지게
	할 수 있다.
	
	#+begin_src csharp
      try
      {
          // 계산이 유효하지 않게 되면 예외가 던져진다.
          checked
          {
              int sum = 1000000;
              byte byteSum = (byte)sum;
          }
      } catch (OverflowException e)
      {
          Console.WriteLine(e.Message);
      }
	#+end_src

	만일 컴파일러 옵션 =/checked= 를 사용하면 전체 프로젝트에
	checked를 사용하는 효과를 보게 된다.

*** var 지시어(?. C# keyword 가 아님!)
	
	암시적으로 형을 유추할 수 있는 경우에 원래의 형 대신 쓰게 된다.
	C++11 의 auto 와 유사.

	LINQ 구문과 같이 리턴되는 값의 형이 복잡한 경우에 쓰면 코드가
	깔끔하다.

	var 는 초기값을 설정하는 경우(즉, *타입을 유추할 수 있는 경우*)
	로컬 변수선언 시에만 쓸 수 있다. 다음과 같은 경우에는 사용 불가

	- 필드 X
	- 리턴값 X
	- 초기값 설정을 하지 않는 로컬변수 선언시 X
	- null값으로 설정하는 변수 X
   
   var 형은 겉보기로는 Variant 같은 형과 비슷하지만, 전혀 다르다.
   유추하는 것만 자유롭지, 일단 유추되면 그 형의 타입으로 고정된다.
   (즉, 타입세이프하게 된다)

   LINQ 사용시 유용한 예

   #+begin_src csharp
     static void LinqQueryInts()
     {
         // LINQ !
         int [] numbers = {10, 20, 30, 40, 50 };
         var subset = from i in numbers where i < 30 select i;
         foreach (int number in subset)
         {
             Console.WriteLine("{0}", number);
         }
     }
   #+end_src

*** Enum.Parse() 를 사용하면 문자열을 특정 enum형으로 변경가능
   
   #+begin_src csharp
   DayOfWeekEnumType dow = Enum.Parse(typeof(DayOfWeekEnumType), "Monday");
   #+end_src

*** switch 문이 enum/문자 뿐만 아니라 *문자열*까지 case할 수 있다!

   #+begin_src csharp
     string lang = "c#";
     switch (lang)
     {
     case "c#":
         break;
     case "c++":
         break;
     case "objc":
         break;
     }
   #+end_src

   와우

** Chap4. Core C# 2편
*** 함수 인자 수식어(Parameter Modifier)

	- (none) : pass-by-value. reference type의 pass-by-value 는 역시
            reference임에 유의. 원래값의 복제본이 넘어간다.
   	- ref : pass-by-reference. 원래값의 참조값이 넘어간다.
	- out : pass-by-reference. 함수구현부에서 값을 설정하지 않으면
            컴파일 오류발생
	- params : 가변인자. params 인자는 가장 마지막에 와야함.
   
   ref/out은 함수선언시에도 사용하고, 호출시에도 사용해야 한다.
   params 은 선언시에만 사용하고, 배열형식으로 인자가 선언되어야 한다.

   #+begin_src csharp
     public static int Main(string[] args)
     {
         CalcAvg(10, 1, 2, 3, 4, 5, 6, 7, 8, 9);
         return 0;
     }
     static void CalcAvg(double multiplier, params double [] values)
     {
         double avg = 0;
         foreach (double value in values)
         {
             avg += (value * multiplier);
         }
         avg = avg / values.Length;
         Console.WriteLine("average = {0}", avg);
     }   
   #+end_src

*** 선택적 인자의 사용이 가능.

	C++ 동일한 방식으로 디폴트 값을 가지는 인자를 만들 수 있다.

	#+begin_src csharp
	static void EnterLogData(string message, string owner="Programmer")
	#+end_src

*** 이름있는 인자(Named Parameter)

	보통 우리가 쓰는 걸 positional parameter(위치별 인자)라고 하고,
	인자의 이름 뒤에 콜론을 붙이는 식으로 인자전달 하는 걸 named
	parameter 라고 한다. 가독성이 좋아지는 부분도 있고, COM
	상호운용성(거기에도 Named Parameter가 있다)을 높이기도 하지만,
	그닥... 이란다.

	positional parameter 와 named parameter 는 섞어서 쓸 수 도 있다.
	그런경우 positional 은 순서가 함수 시그너쳐와 맞아야 하고, named
	는 	항상 그 뒤에 따라 와야 한다.

	COM등에서 사용되는 named parameter의 용례는 다음과 같은 경우로
	느낌을 받을 수 있다.

	#+begin_src csharp
      static void DisplayFancyMessage(Color text = blue,
                                      Color background = yellow,
                                      string message = "TestMessage")
      {
          // text색상으로 background색상 위에 message를 표시.
      }
      // 아래와 같이 호출 가능
      DisplayFancyMessage(message: "Hello!");
      DisplayFancyMessage(text:red);
	#+end_src

*** C# 은 인자타입에 따른 메소드 오버로딩이 가능하다.

	C++ 과 동일하다. 근데, VB.NET은 그게 안된단다.
	*Generic* 을 사용하면 C++ template class 처럼 *type placeholder* 를
	정의하여 구현을 일반화할 수 있다.

*** C# 배열

	초기화 구문예는 다음과 같은 종류

	#+begin_src csharp
      static void ArrayInit()
      {
          string[] array1 = new string[] {
              "one",
              "two",
              "three"
          };
          bool[] boolArray = {
              false,
              false,
              true
          };
          int[] intArray = new int[4] {
              20, 22, 23, 0
          };
      
          // oops compile error
      
          // int[] intArray2 = new int[2] {
          //  20, 22, 23, 0
          // }
      }
	#+end_src

	암시적인 형 *var* 를 사용해서도 정의 가능. 가능한 일반적인 형으로
	유추되더라. 똑똑한 var.

	#+begin_src csharp
      void VarArray()
      {
          var data = new[] { 1, 10, 100, 1000 };
          Console.WriteLine("typeof(data)={0}", data.GetType()); // System.Int32[]
          a[1] = 50;
          foreach (var i in data)
          {
              Console.WriteLine("i = {0}", i);
          }
          var b = new[] { 1, 3.5, 10 };
          Console.WriteLine("typeof(b)={0}", b.GetType()); // System.Double[]
      
          // // 섞어 쓰면 컴파일 에러
          // var d = new [] { 1, "one", 2 };
      }
	#+end_src

	System.Object 즉, object 형을 배열로 만들면 모든 객체를 하나의
	배열에 담을 수 있다.

	#+begin_src csharp
      object[] myObjects = new object[3];
      myObjects[0] = 10;
      myObjects[1] = new DateTime(1971,12,11);
      myObjects[2] = "hello";
      foreach (object obj in myObjects)
      {
          Console.WriteLine("object = {0}(type:{1})", obj, obj.GetType());
      }
	#+end_src

	배열은 함수의 인자로도, 리턴값으로도 사용가능하단다.

	#+begin_src csharp
      static void PrintArray(int[] intArray);
      static string[] GetStringArray();
	#+end_src

*** .net에서 배열은 System.Array 클래스 객체

	- Clear(): 지우기(전체 혹은 일부구간)
	- CopyTo(): 배열요소 복사하기
	- Length: 배열항목갯수
	- Rank: 몇차원 배열?
	- Reverse(): 정작메소드. 1차원배열인 경우 순서를 역순으로 만듬
	- Sort() : 정적메소드. 정렬.

*** enum

	C# 에서는 enum의 underlying type을 지정이 가능. 아래는 그걸
	int형으로 함.

	#+begin_src csharp
      enum EmpType : int
      {
          Manager, // =0
          Manager =10,
          Contractor, // 11
          VicePresident, // 12
      }
	#+end_src

*** System.Enum

	enum형으로 정의된 타입에 대한 introspection이 가능.

	*모든 enum 값은 System.Object의 파생클래스인 System.Enum 클래스의
     객체*. 따라서 그 어떤 enum 같이라도 다음과 같은 함수에 넘겨서
     정보를 쭈욱 뽑아낼 수 있다.

	 #+begin_src csharp
       static void EvaluateEnum(Enum e)
       {
           Type enumType = e.GetType();
           Console.WriteLine("Enum Type Name: {0} (underlying type={1}",
                             enumType.Name, Enum.GetUnderlyingType(enumType));
           var enumValueList = Enum.GetValues(enumType);
           Console.WriteLine("--> has {0} values.", enumValueList.Length);
           foreach (var enumValue in enumValueList)
           {
               Console.WriteLine("Name:{0}, Value:{0:D}", enumValue);
           }
       }
       // EvaluateEnum(MyEnum.FirstEnumValue)
	 #+end_src

*** .Net struct 형 --> 값 타입(Value Type) (cf. class형은 참조타입(Reference Type))

	일반적인 객체지향언어에서 경량클래스타입으로 여겨지는 바로 그것.
	수학적/지리학적/원자적 단위의 데이터. 상속을 통해서 무언가를
	이루어 내려는 경우에는 사용이 안됨(그런경우는 class를 사용).

	struct와 class의 스택/힙상에서의 존재, 대입시 참조가 대입되는지
	값이 복사되는지...등등에 대한 내용은 .NetBookZero 에서 배움.

	패스.

***  값타입과 패스타입의 차이점 정리 

	- 객체가 어디에 정의되는가?
	- 변수는 어떤 것을 표현하는가?
	- 어느 클래스에서 상속 받았는가?
	- 다른 타입의 부모가 될 수 있는가?
	- 파라메터로 전달될때 디폴터 거동에 무슨 차이가 있나?
	- System.Object.Finalize() 를 오버라이드 할 수 있나?
	- 생성자를 정의할 수 있나?
	- 언제 소멸되나?

*** Nullable Type

	보통 값타입의 경우 null 값을 대입할 수 없지만, 물음표(?)를 접미사로
	붙인 값타입은 nullable type 이 되어 null 을 대입할 수 있다.
	물음표(?) 를 붙이면 System.Nullable<T> 형이 된다.

	#+begin_src csharp
      int? nullableInt = null;
      // 위와 아래는 같음
      System.Nullable<int> nullableInt = null;
	#+end_src

	어떤 nullable type의 값이 null 인지를 확인한 후, null이면 기본값을
	사용하는 패턴은 많이들 사용하는데 그때 유용한게 이중물음표(??)
	연산자이다.

	#+begin_src csharp
      public static int? GetNullableValue();
      // 위와 같은 함수가 있을때...아래 구문은 null 이 반환될 경우 기본값 10
      // 이 notNullableValue 에 대입된다.
      int notNullableValue = GetNullableValue() ?? 10;
	#+end_src

** 5장. 캡슐화

*** 생성자(즉, "인스턴스 생성자(instance constructor)")
   생성자에 관한 얘기가 주욱 나온다. 생성자를 명시적으로 생성하지
   않으면, 컴파일러가 기본 생성자를 만들고 거기서 모든 멤버의 값을
   기본값으로 채운다(Value Type은 0/false, 참조타입은 null).

   *파라메터를 받는 사용자 정의 생성자를 하나라도 정의하면 컴파일러는
    더이상 기본제공 생성자를 만들지 않는다* !

	왜 그럴까? 파라메터 커스텀 생성자는 객체의 멤버가 특수한 방식으로
	초기화될 필요가 있다고 여겨지기 때문에 정의하는 것이다.
	그런경우에는 컴파일러의 기본 디폴트생성자는 아무 의미가 없다. 즉,
	사용자가 따로 인자 없는 디폴트 생성자를 받아서 'this' 키워드를
	사용해서 생성자 초기화 호출을 이어주는 식으로 구성해야
	한다(*constructor chaining*)

	--> objc 에서는 *designated constructor* 라고 하는 유사개념.
	--> 이책에서는 *master constructor* 라고 하는 개념
	--> 가장 많은 인자를 받는 생성자.
	--> 모든 생성자가 이 생성자를 this 키워드를 사용해 호출하도록 함.

*** 정적 생성자(static constructor)

	정적 멤버를 초기화하는 방법은

	=static int staticMemberVar = 18;=

	그런데, 데이터베이스에서 값을 가져와야 하는 식으로 초기화해야
	하는경우는? (즉, 런타임에서야만 값을 초기화할 수 있는 경우는?)

	--> *정적 생성자*를 쓴다.

	정적생성자의 특징

	- 클래스당 오직 1개만 정의할 수 있다(즉, 오버로딩이 불가)
	- 접근제한자("access modifier" ex: public /protected /private
      /internal ...)등의 사용 불가
	- 그 어떤 해당 클래스 객체가 생성되기 직전에 단 1번만 호출됨
	- 그 클래스의 정적멤버에 접근을 맨 처음 할 때 단 1번만 호출됨

*** 정적 클래스(static class)

	정적 멤버만 가질 수 있고, new 해서 인스턴스를 만들수 없는
	클래스가 정적클래스.

*** 접근 한정자(access modifier)

	- 5가지가 있음 : public/protected/private/internal/protected internal.

	- public/protected/private 의 접근방식은 c++ 과 같다.
	- *nested type 은 절대 public/internal 이 될 수 없는 것 같다*.
	- *Type 자체는 절대 private/protected/protected internal 이 될 수
      없다*. public 혹은 internal 이어야 한다.
	- internal : 동일 .net assembly 에서만 public으로 사용될 수 있다. 
	- protected internal 은 internal과 같지만 protected로 된다. 따라서
      nested type에 사용이 가능

	- 접근 한정자를 지정하지 않은 경우
      --> 멤버: 암시적으로 private
	  --> 타입: 암시적으로 internal
	  
	  클래스 라이브러리를 만들때는 =public class ClassName= 이런식이
      되어야 되겠다.

*** accessor(getter)/mutator(setter) 와 property(속성)

	이미 아는 얘기. 다만, 속성의 set 을 정의할 때 사용되는 "value"
	라는 단어가 C# 키워드가 아니란다. *contextual keyword* 란다.
	즉, 다른 곳에서는 value 라는 이름의 변수를 만들수 는 있지만,
	=property set {}= 안에서는 특수한 의미를 가진단다.

	이걸 잘 쓰는 법.

	생성자에서 올바른 범위의 초기값을 입력받을 때 종종 C++ 에서는
	생성자에서 그런걸 하는데, C# 에서는 property set 에서 그런 일을
	하고, 생성자에서는 변수에 접근하는게 아니라 속성에 접근하도록
	코딩하는 게 바람직 하단다.

	*정적 속성(static property)* 개념 : Data Encapsulation 을 생각하면
	정적 멤버변수에 직접 접근하는 것 보다는 이게 낳다는...

	#+begin_src csharp
      class Savings
      {
          private static double interest = 0.04;
          public static double Interest
          {
              get { return interest; }
              set { intereset = value; }
          }
      }
	#+end_src

	*자동 속성(automatic properties)* 개념 : 그냥 =get;set;= 만 넣으면
     속성이 정의된다는... 그렇다고 =get;= 혹은 =set;= 의 형태로는 안된다

	 #+begin_src csharp
       public string MyProperty { get; set; } // OK
       // public string MyProperty { get;} // 오류
       // public string MyProperty { set;} // 오류
	 #+end_src

	 근데, =get;set;= 형태로는 Read/Write 속성이 정의되는데,
	 *이런식으로는 readonly / writeonly 속성의 정의는 불가하다* 

	 자동 속성의 경우, 모든 hidden-member-variable 을 컴파일러가
	 구성할 텐데, 이들은 초기 값이 0/false(ValueType의 경우) 및
	 null(RefType의 경우)이 된다. RefType 의 경우 자동속성의 값은
	 생성자에서 반드시 =new T= 해 주는 것이 바람직하다.

	 속성값의 지정시 validation이나 기타 처리가 필요한 경우는
	 자동속성이 아닌 직접 만든 속성함수를 사용해야 한다(당연).

*** 객체 초기화 구문(Object Initializer)

	이건 정말, 객체 생성 코드를 깔끔하게 정리해 주는 구문이다.

	원하는 객체 생성자를 선택해서 new 해 준다음, 세미콜론(;) 으로
	구문을 끝내기 전에 중괄호 scope(={}=)를 만들어 그 안에 객체의
	속성값을 설정하는 구문이다.

	이건 has-a 관계로 객체를 포함하고는 있는 타입의 경우에 nested 로
	수행할 수 있다.

	아래의 예를 한번 읽어보되, TestOjbInitr()에서
	- 중괄호들이 nested 로 된점
	- 콤마가 찍힌 위치들(마지막 콤마는 optional이지만, 그냥 찍어두는
      게 나을듯)
	- 생성자 시그너쳐가 그냥 =()= 를 붙였지만, 특수한 생성자를 써도
      된다는 점(또는 아예 =()= 를 생략하여 암시적 기본 생성자가
      사용하도록 할 수 있다는 점)
	  
	에 유념하고 코드를 이해한다.

	#+begin_src csharp
      class Point {
          public int X { get; set; }
          public int Y { get; set; }
      }
      class Rectangle {
          public Point TopLeft { get; set; }
          public Point BottomRight { get; set; }
          public Rectangle() {
              TopLeft = new Point();
              TopLeft = new Point();
          }
          public void PrintInfo() {
              Console.WriteLine("({0},{1}) ~ ({2},{3})",
                                TopLeft.X, TopLeft.Y,
                                BottomRight.X, BottomRight.Y);
          }
      }
      // 어떤 함수에서 아래와 같이 객체 초기화가 가능
      static void TestObjIniter()
      {
          Rectangle r = new Rectangle() {
              TopLeft = new Point() {
                  X = 10, Y = 20,
              },
              BottomRight = new Point() {
                  X = 20, Y = 30,
              },
          };
          r.PrintInfo();
      }
	#+end_src

*** 상수필드(constant field data)

	컴파일시 값이 결정되고 그 이후로는 절대 수정불가한 상수값의 정의가
	가능하다. 겉보기로는 인스턴스 멤버같지만 실제로는 *암시적으로
	static 변수* 이다. 따라서 접근 할 때는 static 멤버와 같은 방식으로
	접근한다.

	#+begin_src csharp
      class MyMath {
          public const double PI = 3.141592;
      };
      static void PrintPi() {
          MyMath mm = new MyMath();
          // Console.WriteLine("pi = {0}", mm.PI); // 컴파일 오류!
          Console.WriteLine("pi = {0}", MyMath.PI); // static멤버처럼 사용!
      }
	#+end_src

*** 읽기전용 필드(readonly field)

	멤버변수 선언하듯이 선언할 때 타입명 앞에 =readonly= 를 넣어주면
	*생성자에서만 값의 대입이 가능하고 그 외에는 쓰기가 불가한* 변수가
	탄생한다.

	#+begin_src csharp
      class MyMath {
          public readonly double PI;
          // 생성자 : 쓰기동작 OK
          MyMath() {
              PI = 3.141592;
          }
          // 기타함수 : 쓰기 불가! ERROR!
          public void TryChangePI() {
              PI = 3.141592; 
          }
      }
	#+end_src

*** Partial Class

	
	
	
* 기타 메모

** string 키워드

   System.String 의 alias 에 불과하다. 유니코드 캐릭터 집합이고, @""
   문자열을 쓰면 이스케이프 특수문자를 그대로 입력받을 수 있단다.
   그리고, 중요한 사실은 *immutable(변경불가)* 타입이다. 

** System.Object 와 System.ValueType, 그리고, System.Enum

   .net 에서는 모든 타입이 암묵적으로 이 두가지로 부터 파생된다(사실
   =System.ValueType= 은 =System.Object= 의 파생클래스이며
   =System.Enum= 의 부모클래스이다). 
   값타입(/value type/)인 경우  =System.ValueType= 로 부터 암묵적 상속을
   받으며, 참조타입(/reference type/) 인 경우 =System.Object= 로 부터
   파생된다. *암묵적*이라는 말에 유념. 명시적으로 상속받도록 코딩할 수
   없다(/sealed/ 클래스임).

** Boxing 과 Unboxing

   모든 타입은 System.Object(즉 =object=)형에 담을 수 있는데, 이게 바로
   boxing. boxing 은 암시적이어서 명시적으로 =(System.Object)intValue=
   이런식으로 하지 않아도 된다.

   #+begin_src csharp
     // 실제로 존재하지 않는 개념적 클래스 sealed class Box<T>:
     System.ValueType { T value; public Box(T t) { value = t; } }
     
     // 아래와 같이 하면.
     int i = 123;
     object box = i; // boxing!
     
     // 실제로는 다음과 같이 되는 개념이 boxing
     int i = 123;
     object box = new Box<int>(i); // boxing!
   #+end_src

   unboxing은 위의 반대. unboxing 은 object에 저장된 걸 다시 원래대로
   복구하는것. 값객체의 경우, boxing/unboxing시 값의 복제가 이루어지게
   되므로, 시간이 걸린다. c++에서
   std::vector<VeryLargeSizeOfStructure> 같은 것이 그런 예가 될 수
   있겠다. 아래는 [[http://msdn.microsoft.com/ko-kr/library/ms173196.aspx][MSDN에서 찾은 글]]이다.

   #+begin_example
    System.Collections.ArrayList 같은 제네릭이 아닌 컬렉션 클래스의
    예와 같이 많은 수의 boxing이 필요한 경우에는 값 형식을 사용하지
    않는 것이 좋습니다. System.Collections.Generic.List<T> 같은 제네릭
    컬렉션을 사용하면 값 형식의 boxing을 방지할 수 있습니다. boxing 및
    unboxing 과정에는 많은 처리 작업이 필요합니다. 값 형식을 boxing할
    때는 완전히 새로운 개체가 만들어져야 하며, 이러한 작업은 간단한
    참조 할당보다 최대 20배의 시간이 걸립니다. unboxing을 할 때는
    캐스팅 과정에 할당 작업보다 4배의 시간이 걸릴 수 있습니다. 자세한
    내용은 Boxing 및 Unboxing을 참조하십시오.
   #+end_example

** 빈 소멸자는 피하라.
   객체가 파괴될 때, 소멸자들이 Finalize큐에 들어가서 자식->부모 순서대로(상속을
   고려하여) 호출된다. 소멸자가 없으면 아예 호출이 일어나지 않으므로
   성능이 향상될 수 있단다. 

** partial class

   멋지다. patial class는 아래의 예를 보면 한번에 느낌이 온다. 어떤
   함수를 partial 로 선언하면, 구현을 포함하지 않을때는 아예 호출하는
   코드 자체가 없어진다고 한다. 그러다 구현을 포함한 추가 partial
   class를 따로 정의하면 그때 partial로 정의한 함수의 호출루틴이 다시
   살아난다.

   #+begin_src csharp
     partial class Customer
     {
         string name;
         public string Name
         {
             get
             {
                 return name;
             }
             set
             {
                 OnNameChanging(value);
                 name = value;
                 OnNameChanged();
             }
         }
         public override string ToString()
         {
             Console.WriteLine("tostring is called.");
             return string.Format("고객:이름={0}", name);
         }
         partial void OnNameChanging(string name);
         partial void OnNameChanged();
     }
     
     partial class Customer
     {
         partial void OnNameChanging(string name)
         {
             Console.WriteLine("OnNameChanging({0})", name);
         }
         partial void OnNameChanged()
         {
             Console.WriteLine("OnNameChanged()");
         }
     }
     
     class PartialClassTest
     {
         static void Main()
         {
             Console.WriteLine("Partial 클래스 테스트...");
             Customer customer = new Customer();
             customer.Name = "이준환";
             // Console.WriteLine("객체 정보 : {0}", customer);
         }
     }
     
   #+end_src

   위 코드의 실행결과는

   #+begin_example
     Partial 클래스 테스트...
     OnNameChanging(이준환)
     OnNameChanged()
   #+end_example

** 가비지콜렉션을 제어. IDisposable과 using 구문

   using 키워드는 원래 네임스페이스의 사용을 선언하는 키워드. 하지만
   구문내에서는 특정 객체를 생성하고 사용이 끝나면 파괴하는 일을
   깔끔하게 해주는 용도로 사용됨.

   #+begin_src csharp
     using (Font font1 = new Font("Arial", 10.0f))
     {
         byte charset = font1.GdiCharSet;
     }
   #+end_src

   위 구문은 아래의 구문으로 컴파일된다 함. 

   #+begin_src csharp
     {
         Font font1 = new Font("Arial", 10.0f);
         try
         {
             byte charset = font1.GdiCharSet;
         }
         finally
         {
             if (font1 != null)
                 ((IDisposable)font1).Dispose();
         }
     }
   #+end_src

   using에는 여러개의 객체할당 구문을 콤마로 해서 넣을 수 있다.

   #+begin_src csharp
     using (Font font3 = new Font("Arial", 10.0f), 
            font4 = new Font("Arial", 10.0f))
     {
         // Use font3 and font4.
     }
   #+end_src

   다만 다음과 같이 using 구문 바깥쪽에서 선언/정의된 객체의 사용은
   바람직하지 않다(using {} 구문을 벗어나면 할당해제되기
   때문이기도...

   #+begin_src csharp
     Font font2 = new Font("Arial", 10.0f);
     using (font2) // not recommended
     {
         // use font2
     }
     // font2 is still in scope
     // but the method call throws an exception
     float f = font2.GetHeight(); 
   #+end_src

** 숫자 리터럴의 suffix들

   [[http://www.dotnetperls.com/suffix][여기]] 에 정리가 잘됨.

   - m 또는 M : =decimal myMoney = 300.5m;=
   - f 또는 F : =float f1 = 100.50F;=
   - u 또는 U : =uint u1 = 1000u;=
   - ul 또는 UL : =ulong u2 = 1000200300400500ul;=
   - l 또는 L : =long x = 1000L;= 
	 
	 가급적이면 대문자를 쓰는게 덜 헛갈릴 수 있다(ex: l vs L ==> l 은
     숫자 1과 비슷해 보인다).


   
** C# 에서 {void|int} Main([string[] args])

   C# 에서는

    - public static void Main();
	- public static void Main(string[] args);
	- public static int Main();
	- public static int Main(string[] args);

   의 Entry Point 사용이 가능하다. C/C++ 과 다른 점은,

   - Shell Pattern 확장이 자동이 아님.
   - 프로그래명이 =args[0]= 가 아님. =arg[0]= 은 첫번째 argument 임.
   - int argc 는 필요없음. args.Length 하면 얻을 수 있음.

** @ 스트링 리터럴 : 이스케이프 문자가 없는 문자열.
   ="c:\\my\\temp\\dir"= 보다는 =@"c:\my\temp\dir"= 이 읽기 편하다.
   @스트링 리터럴이 가지는 유일한 특수처리 문자는 따옴표 그
   자체다(이를 포함하려면 연속으로 따옴표 2개를 입력)
** Directory/File/Environment 클래스의 클래스 정적 메소드들
   - File.Exists(filePath) / Directory.Exists(dirName)
   - File.Delete(filePath)
   - Directory.CreateDirectory(dirPath)
   - Environment.GetLogicalDrives()
   - Environment.CurrentDirectory()
   - Environment.CommandLine()

** C# String Format

   - Excel에서 보았던 형식이 가능하다.
	 
	 String.Format("{0:0000.00}", 142.1340); --> 0142.13

   - C에서 온 numeric
	 
	 String.Format("{0:f2}", 142.1340); --> 142.13

** string s = new string("hello") 같은 구문은 C# 에서 안된다?!
   생성자에는 있는데????
